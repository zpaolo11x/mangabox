<!DOCTYPE html>
<html lang="en">

<head>
	<title>MangaBox</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">

	<meta name="theme-color" content="black">

	<!--<link rel="icon" href="ab_16_alpha.png" type="image/png">-->
	<link rel="icon" href="logo/mangabox-logo-new-favicon.svg" type="image/svg+xml">
	<link rel="apple-touch-icon" href="logo/mangabox-logo-new-red.png">


	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="manifest" href="manifest.json">
	<link rel="stylesheet" type="text/css" href="style-auth.css">

	<link rel="stylesheet" href="fontawesome/all.min.css">

	<link rel="stylesheet" href="style-mangabox-blankstart.css">
	<link rel="stylesheet" href="style-mangabox-main.css">
	<link rel="stylesheet" href="style-mangabox-reader.css">

	<script>
		let mbPrefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
		let toDark = mbPrefersDarkMode.matches ? true : false
		document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');
	</script>

</head>

<body>
	<div id="mainLoader" class="hidden"><span class="fa-solid fa-gear"></span></div>
	<div id="mainUI">
		<div id="menuBars">
			<div id="stickyContainer" class="hidden">
				<ul id="librariesList"></ul>
				<ul id="librariesRightBlock">
					<!--
					<li id="readlistsButton2" title="Read Lists" class="library-item no-grow press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-book-bookmark glyph-dark"></span>
						</div>
					</li>
					<li id="collectionsButton2" title="Collections" class="library-item no-grow press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-box-archive glyph-dark"></span>
						</div>
					</li>
					-->
					<li id="fullscreenChanger" title="Toggle Fullscreen" class="library-item press-button">
						<div class="button-wrapper">
							<span id="fullscreenLabel" class="fa-expand fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="themeChanger" title="Light/Dark Theme" class="library-item press-button">
						<div class="button-wrapper">
							<span id="themeLabel" class="theme-label fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="colorChanger" title="Theme Color" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-paint-roller glyph-dark mb-accent"></span>
						</div>
					</li>
					<li id="offlineLibrary" title="Offline Books" class="library-item no-grow press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-download glyph-dark"></span>
						</div>
						<div id="downloadSpinner" class="download-overlay">
							<span class="fa-solid fa-spinner glyph-dark mb-accent"></span>
							<span class="fa-solid fa-spinner glyph-dark mb-accent layer"></span>
						</div>
					</li>
					<li id="searchField" title="Search" class="library-item search-field no-grow press-button">
						<div id="searchIcon" class="button-wrapper">
							<span class="fa-solid fa-magnifying-glass glyph-dark"></span>
						</div>
						<!--<span id="clearSearchBtn" class="clear-btn fa-solid fa-xmark"></span>-->
						<div id="clearSearchBtn" class="clear-btn mini-buttons-2 press-flat-button" onclick="jumpBookDetailsNext()">
							<span class="x-btn lib-override fa-solid fa-xmark"></span>
						</div>
						<input id="searchInput" type="search" autocomplete="off" role="searchbox" class="search-input" placeholder="Search...">
					</li>
					<li id="logOut" title="Logout" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-arrow-right-from-bracket glyph-dark"></span>
						</div>
					</li>
				</ul>
				<div id="offlineLed">OFFLINE</div>
			</div>

			<div id="filtersBar" class="extra-bar hidden blankstart">
				<ul id="extraButtons" class="filters-list buttons"></ul>
			</div>

			<div id="colorSwatchBar" class="extra-bar hidden blankstart">
			</div>

		</div>
		<div id="mainScrollBox" class="scrollbox" data-scroll-direction="vertical">
			<div id="mainContainer" class="scrollbox-content">
				<div id="seriesHeader" class="section hidden"></div>

				<div id="seriesGrid" class="section hidden"></div>

				<div id="booksGrid" class="section hidden"></div>

				<div id="offlineGrid" class="section hidden"></div>

				<div id="stripGridContainer" class="section hidden">
					<div id="stripGrid" class="strip-grid"></div>
					<div id="stripGridHeaderContainer" class="stripgrid-header-container">
						<div id="stripGridHeader" class="strip-header">
							<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading
						</div>
						<div id="stripGridRight" class="stripgrid-all">
							<span id="stripPrevPage" title="Previous Page" class="disabled fa-solid fa-play flip-horizontal glyph-dark strip-button press-flat-button"></span>
							<span id="stripNextPage" title="Next Page" class="disabled fa-solid fa-play glyph-dark strip-button press-flat-button"></span>
						</div>
					</div>
				</div>

				<div id="seriesMiniHeader" class="section hidden collapse"></div>

				<div id="homeStripsContainer" class="section hidden"></div>

				<div id="searchStripsContainer" class="section hidden">

					<div class="home-strip-parent">
						<div id="homeStripSeriesResults" class="series-results search-results"></div>
						<div class="strip-header-container">
							<div class="strip-header"><span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Series Results</div>
						</div>
					</div>

					<div class="home-strip-parent">
						<div id="homeStripBooksResults" class="books-results search-results"></div>
						<div class="strip-header-container">
							<div class="strip-header"><span class="fa-solid fa-book glyph-dark"></span>&nbsp;Books Results</div>
						</div>
					</div>
				</div>

				<!--
					<div id="offlineBooksGrid" class="section hidden"></div>
				-->

				<div id="bookDetailsContainer" class="section hidden blankstart">
					<div class="book-details-pic-container">
						<div class="mini-controls">
							<div class="mini-buttons-2 press-flat-button" title="Previous book" onclick="jumpBookDetailsPrev()">
								<span class="fa-solid fa-chevron-left"></span>
							</div>
							<div class="mini-buttons-2 press-flat-button" title="Go to library" onclick="jumpBookLibrary()">
								<span class="fa-solid fa-layer-group"></span>
							</div>
							<div class="mini-buttons-2 press-flat-button" title="Next book" onclick="jumpBookDetailsNext()">
								<span class="fa-solid fa-chevron-right"></span>
							</div>
						</div>
						<div id="bookDetailsContainerThumbnailWrapper" class="book-details-thumbnail-wrapper" title="Open Book" onclick="navigateToReadBook(mb.currentBook, mb.seriesData.metadata.readingDirection)">
							<img id="bookDetailCover" class="book-thumbnail hidden" src="transparent.png">
						</div>
					</div>
					<div>
						<div id="bookDetailsTitle" class="book-details-title"></div>
						<div class="ul-container">
							<ul id="bookDetailsSummary">
							</ul>
						</div>
					</div>
					<div class="close-details dialog-button press-button" onclick="closeBookDetails()">
						<span class="fa-solid fa-xmark"></span>
					</div>
				</div>

				<div id="blanker" style="opacity:1"></div>
			</div>
			<div class="scrollbox-scrollbar">
				<div class="scrollbox-thumb"></div>
			</div>
		</div>
	</div>

	<div id="readerContainer" class="section hidden">
		<div id="readerBackground" class="hidden"></div>

		<div id="readerViewer">
		</div>

		<div id="readerViewerWebtoon">
			<div id="webtoonContainer" class="hide-scrollbar"></div>
		</div>
	</div>

	<div id="readerOverlay" class="section hidden">
		<div id="incognitoMark" class="blankstart"></div>

		<div id="controlPanel" class="hidden">

			<div id="thumbStrip" class="scrollbox" data-scroll-direction="horizontal">
				<div id="thumbStripScrollContent" class="scrollbox-content">
					<div id="thumbStripInner"></div>
				</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			<div id="thumbStripButton">
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
			</div>

			<div id="thumbStripWT" class="scrollbox" data-scroll-direction="vertical">
				<div id="thumbStripScrollContentWT" class="scrollbox-content">
					<div id="thumbStripInnerWT"></div>
				</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			<div id="thumbStripButtonWT">
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
			</div>

			<div id="topControls">
				<span id="readerClose" title="Close Reader" class="reader-buttons press-button corner-circle fa-solid fa-xmark"></span>
				<span id="bookName"></span>
				<span id="readerTheme" title="Reader Theme" class="reader-buttons press-button corner-left fa-solid"></span>
				<span id="readerAnimation" title="Reader Animation" class="reader-buttons press-button fa-solid"></span>
				<span id="readerIncognito" title="Incognito Reading" class="reader-buttons press-button corner-right fa-solid fa-ghost"></span>
			</div>

			<div id="zoomControls">
				<span id="scaleDown" title="Scale Down" class="reader-buttons press-button corner-left fa-solid fa-minus" onclick="readerScaleDown()"></span>
				<span id="scaleVal" class="reader-buttons">100%</span>
				<span id="scaleUp" title="Scale Up" class="reader-buttons press-button corner-right fa-solid fa-plus" onclick="readerScaleUp()"></span>
			</div>

			<div id="bottomControls">
				<span id="leftArrow" class="reader-buttons press-button corner-left fa-solid fa-caret-left"></span>
				<span id="leftLimit" class="bar-note press-button corner-right"></span>
				<div id="readerProgressBar" onclick="seek(event)">
					<div id="readerProgress"></div>
					<div id="readerPage"></div>
				</div>
				<span id="rightLimit" class="bar-note press-button corner-left"></span>
				<span id="rightArrow" class="reader-buttons press-button corner-right fa-solid fa-caret-right"></span>
			</div>

			<div id="nextBookPanel" class="modal-content hidden blankstart">
				<button id="nextBookButton" class="ok dialog-button press-button" onclick="handleCloseReader(); setTimeout(()=>{navigateToReadBook(rd.nextBook, rd.direction, true)},500)">GO TO NEXT BOOK</button>
			</div>

			<div id="prevBookPanel" class="modal-content hidden blankstart">
				<button id="prevBookButton" class="ok dialog-button press-button" onclick="handleCloseReader();setTimeout(()=>{navigateToReadBook(rd.prevBook, rd.direction, true)},500)">GO TO PREV BOOK</button>
			</div>

		</div>
	</div>

	<div id="touchPanel" class="section hidden">
		<div id="toLeftPage"></div>
		<div id="openMenu"></div>
		<div id="toRightPage"></div>
	</div>

	<div id="dragbar" class="draggable onLogin">
		<img id="barLogo" src="logo/mangabox-logo-new-favicon.svg">

		<!--<img id="barLogo" src="logo/mangabox-logo-new.svg">-->
		<span id="dragbarAppTitle">MangaBox</span>
		<div id="windowControls" , class="window-controls no-drag">
			<span class="fa-solid fa-window-minimize glyph-dark" id="dragbarMinBtn"></span>
			<span class="fa-regular fa-window-maximize glyph-dark" id="dragbarMaxBtn"></span>
			<span class="fa-solid fa-xmark glyph-dark" id="dragbarCloseBtn"></span>
		</div>
	</div>

	<div id="loginScreen" class="auth-hidden logo-pattern">
		<div id="loginDialog" class="dialog">
			<img id="logoIcon" src="logo/mangabox-logo-new.svg">
			<img id="logoName" src="logo/mangabox-logoname.svg">
			<div class="version-note">v0.3.6</div>
			<div class="input-wrapper" title="Server Address">
				<i class="fas fa-link"></i> <!-- Example icon for the base URL -->
				<input type="text" class="login-input" id="loginBaseUrl" placeholder="Server URL" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="url">
			</div>

			<div class="input-wrapper" title="Username">
				<i class="fas fa-user"></i> <!-- Icon for username -->
				<input type="email" class="login-input" id="loginUsername" placeholder="Username" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="email">
			</div>

			<div class="input-wrapper" title="Password">
				<i class="fas fa-lock"></i> <!-- Icon for password -->
				<!--<i id="passIcon" class="fas fa-eye"></i>  -->
				<input type="password" class="login-input" id="loginPassword" placeholder="Password" autocorrect="off" autocapitalize="none" spellcheck="false" autocomplete="current-password">
			</div>

			<div class="login-buttons">
				<div class="remember-me-container">
					<input type="checkbox" id="loginRememberMe" class="remember-me-checkbox">
					<label for="rememberMe" class="remember-me-label">Keep Me Signed</label>
				</div>
				<button id="loginButton" class="login-button" onclick="login()">
					<i class="fas fa-play"></i>
					<span>Login</login>
				</button>
			</div>

			<button class="login-button-round" id="loginInfo" onClick="infoText.classList.toggle('visible')"><i class="fas fa-question"></i></button>

			<div id="loginError" class="error-message auth-hidden">Invalid credentials or server URL, please try again.</div>
		</div>
	</div>

	<div id="myModal" class="modal">
		<div id="modalContent" class="modal-content">
			<div id="modalWrapper"><img id="modalImage"></div>
			<div id="modalMessage">This is the message content.</div>

		</div>
	</div>

	<div id="fader" class="logo-pattern"></div>

	<div id="infoText" onClick="infoText.classList.toggle('visible')">
		<h1>MangaBox v0.3.6</h1>
		<div>MangaBox is a streamlined client for your Komga media server.
			To access your own, self-hosted server please enter the server URL in the login field, then your username and password. </div>
		<div>MangaBox is not designed to access external sources and does not provide content, it is only designed to display and navigate your own libraries and read your own books.</div>
		<h1>Features:</h1>
		<ul>
			<li>Connect easily to your Komga server from the onboarding screen</li>
			<li>Light and dark themes with custom color highlights</li>
			<li>Touch and gesture support for tablets and phones</li>
			<li>Beautiful two-pages reading with paper-style visuals, page-turn animations and thumbnail previews</li>
			<li>Sync reading progress with the server</li>
			<li>Download books for offline reading</li>
			<li>Quick filter libraries by language, read status, and direction</li>
			<li>Global search for series and volumes</li>
		</ul>
	</div>

	<div id="debuggerObj"></div>

	<script>
		// Set to true to disable per-device and per-platform feature select
		const fullDebugMode = false;

		// Enable for live debug on the main UI
		const enableDebugPrint = false;
		debuggerObj.style.display = enableDebugPrint ? 'block' : 'none';

		const debugPrint = enableDebugPrint
			? text => (debuggerObj.innerText += text + "\n")
			: () => { };


		const isElectron = !!window.electronAPI;
		const isCapacitor = !!window.Capacitor && window.Capacitor.isNativePlatform && window.Capacitor.isNativePlatform();

		const isStatusBar = isCapacitor && !!Capacitor.Plugins.StatusBar;
		const isEdgeToEdge = isCapacitor && !!Capacitor.Plugins.EdgeToEdge;
		const isNavBar = isCapacitor && !!Capacitor.Plugins.NavigationBar;

		let capacitorPlatform = null;

		let enableFullscreen = true;
		let enableDownload = true;

		let filesFolder = 'DOCUMENTS';

		if (isCapacitor) {
			capacitorPlatform = Capacitor.getPlatform();
			fullscreenChanger.remove();
			enableFullscreen = false;
			if (capacitorPlatform == 'android') {
				filesFolder = 'DATA';
			}
		}

		if (!isElectron && !isCapacitor && !fullDebugMode) {
			offlineLibrary.remove();
			enableDownload = false;
		}

		debugPrint("enabledownload" + enableDownload)

	</script>

	<script src="script-transliterate.js"></script>
	<script src="script-auth.js"></script>

	<script>
		if ("serviceWorker" in navigator) {
			window.addEventListener("load", () => {
				navigator.serviceWorker.register("/script-sw.js")
					.then(reg => console.log("Service Worker registered:", reg.scope))
					.catch(err => console.error("Service Worker registration failed:", err));
			});
		}

		executeFade(1);

		function isOrientationLandscape() {
			return window.matchMedia("(orientation: landscape)").matches;
		}

		function getSharpCornerIphone() {
			if (!/iPhone/.test(navigator.userAgent)) return false;

			const ratio = window.devicePixelRatio || 1;
			const width = Math.min(screen.width, screen.height) * ratio;
			const height = Math.max(screen.width, screen.height) * ratio;

			// List of iPhones with sharp corners (non-notch models)
			const sharpCornerModels = [
				// iPhone SE 2020 / SE 2022 / 8 / 7 / 6s / 6
				{ w: 750, h: 1334 },
				// iPhone SE (1st gen)
				{ w: 640, h: 1136 },
				// iPhone 8 Plus / 7 Plus / 6s Plus / 6 Plus
				{ w: 1242, h: 2208 },
			];

			return sharpCornerModels.some(m =>
				(m.w === width && m.h === height) || (m.h === width && m.w === height)
			);
		}

		/*
		const isPWA = window.matchMedia('(display-mode: standalone)').matches
			|| window.navigator.standalone === true;
		*/

		const isSharpCornerIphone = getSharpCornerIphone();

		if (isStatusBar) {
			if (isSharpCornerIphone) {
				Capacitor.Plugins.StatusBar.hide();
			} else {
				Capacitor.Plugins.StatusBar.show();
			}
		}

		async function setAndroidInsets() {
			if (isEdgeToEdge) {
				let ratio = window.devicePixelRatio || 1;
				await Capacitor.Plugins.EdgeToEdge.enable()
				let result = await Capacitor.Plugins.EdgeToEdge.getInsets();

				document.documentElement.style.setProperty('--mb-android-inset-top', (result.top / ratio) + 'px');
				document.documentElement.style.setProperty('--mb-android-inset-bottom', (result.bottom / ratio) + 'px');
				document.documentElement.style.setProperty('--mb-android-inset-left', (result.left / ratio) + 'px');
				document.documentElement.style.setProperty('--mb-android-inset-right', (result.right / ratio) + 'px');
				Capacitor.Plugins.EdgeToEdge.disable()
			}
		}

		(async () => {
			await setAndroidInsets();
		})();


		//MB Pinch To Zoom
		// ===== Two-Finger Pinch + Pan for MangaBox =====

		//const page = document.getElementById("touchPanel");
		//const pageTarget = document.getElementById("readerContainer");

		function getDistance(touches) {
			if (touches.length === 1) {
				return (0);
			}
			if (touches.length == 2) {
				const dx = touches[0].clientX - touches[1].clientX;
				const dy = touches[0].clientY - touches[1].clientY;
				return Math.sqrt(dx * dx + dy * dy);
			}
		}

		function getMidpoint(touches) {

			// If there is only one touch, return its coordinates
			if (touches.length === 1) {
				return {
					x: touches[0].clientX,
					y: touches[0].clientY
				};
			}

			// Two or more touches → midpoint between the first two
			if (touches.length === 2) {
				return {
					x: (touches[0].clientX + touches[1].clientX) / 2,
					y: (touches[0].clientY + touches[1].clientY) / 2
				};
			}
		}



		let gesture = {
			startDist: 0,
			startScale: 1,
			startMid: { x: 0, y: 0 },
			startContent: { x: 0, y: 0 }
		};

		/*
				function createPanResponse(page, pageTarget) {
					let isDragging = false;
					let lastX = 0, lastY = 0;
					let offsetX = 0, offsetY = 0; // accumulated pan
		
					page.addEventListener("touchstart", (e) => {
						if (rd.scale > 1 && e.touches.length === 1) {
							isDragging = true;
							lastX = e.touches[0].clientX;
							lastY = e.touches[0].clientY;
						}
					});
		
					page.addEventListener("touchmove", (e) => {
						if (isDragging && e.touches.length === 1) {
							e.preventDefault(); // stop native scrolling
							const dx = e.touches[0].clientX - lastX;
							const dy = e.touches[0].clientY - lastY;
		
							offsetX += dx;
							offsetY += dy;
		
							lastX = e.touches[0].clientX;
							lastY = e.touches[0].clientY;
		
							updateTransform();
						}
					});
		
					page.addEventListener("touchend", (e) => {
						if (e.touches.length === 0) {
							isDragging = false;
						}
					});
		
					function updateTransform() {
						// clamp offsets so you can’t drag past edges
						const maxX = (rd.scale - 1) * page.clientWidth / 2;
						const maxY = (rd.scale - 1) * page.clientHeight / 2;
		
						offsetX = Math.min(maxX, Math.max(-maxX, offsetX));
						offsetY = Math.min(maxY, Math.max(-maxY, offsetY));
		
						pageTarget.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${rd.scale})`;
					}
				}
		*/

		function createPinchAndPanResponse(page, pageTarget) {
			let isDragging = false;

			// --------------------------
			// Touch handlers
			// --------------------------
			page.addEventListener("touchstart", e => {
				if (e.touches.length === 2) {
					pageTarget.style.transformOrigin = `0 0`;
					rd.touchLock = false;
					e.preventDefault();

					gesture.startDist = getDistance(e.touches);
					gesture.startScale = rd.scale;
					gesture.startMid = getMidpoint(e.touches);

					const rectPage = page.getBoundingClientRect();
					const rectPageTarget = pageTarget.getBoundingClientRect();
					gesture.startContent.x = (gesture.startMid.x - rectPageTarget.left);
					gesture.startContent.y = (gesture.startMid.y - rectPageTarget.top);
				} else if ((rd.scale > 1) && (e.touches.length === 1)) {
					isDragging = true;
					e.preventDefault();
					gesture.startDist = 0;
					gesture.startScale = rd.scale;
					gesture.startMid = getMidpoint(e.touches);
					const rectPage = page.getBoundingClientRect();
					const rectPageTarget = pageTarget.getBoundingClientRect();
					gesture.startContent.x = (gesture.startMid.x - rectPageTarget.left);
					gesture.startContent.y = (gesture.startMid.y - rectPageTarget.top);
				}
			}, { passive: false });

			page.addEventListener("touchmove", e => {

				if (e.touches.length == 2) {
					rd.touchLock = false;

					e.preventDefault();

					const newDist = getDistance(e.touches);
					const factor = newDist / gesture.startDist;
					let newScale = Math.max(1, Math.min(4, gesture.startScale * factor));

					const newMid = getMidpoint(e.touches);

					const rectPage = page.getBoundingClientRect();
					const rectPageTarget = pageTarget.getBoundingClientRect();


					let calcOffsetX = newMid.x - gesture.startContent.x * newScale / gesture.startScale;
					let calcOffsetY = newMid.y - gesture.startContent.y * newScale / gesture.startScale;

					let newOffsetX = Math.max(Math.min(0, calcOffsetX), rectPage.width - rectPage.width * newScale)
					let newOffsetY = Math.max(Math.min(0, calcOffsetY), rectPage.height - rectPage.height * newScale)

					rd.scale = newScale;
					rd.offsetX = newOffsetX;
					rd.offsetY = newOffsetY;

					pageTarget.style.transform = `translate(${rd.offsetX}px, ${rd.offsetY}px) scale(${rd.scale})`;
				} else if (isDragging && e.touches.length === 1) {
					e.preventDefault();

					const newMid = getMidpoint(e.touches);

					const rectPage = page.getBoundingClientRect();
					const rectPageTarget = pageTarget.getBoundingClientRect();

					let calcOffsetX = newMid.x - gesture.startContent.x;
					let calcOffsetY = newMid.y - gesture.startContent.y;

					let newOffsetX = Math.max(Math.min(0, calcOffsetX), rectPage.width - rectPage.width * rd.scale)
					let newOffsetY = Math.max(Math.min(0, calcOffsetY), rectPage.height - rectPage.height * rd.scale)

					rd.offsetX = newOffsetX;
					rd.offsetY = newOffsetY;

					pageTarget.style.transform = `translate(${rd.offsetX}px, ${rd.offsetY}px) scale(${rd.scale})`;
				}
			}, { passive: false });

			page.addEventListener("touchend", e => {
				if (e.touches.length == 1) {
					rd.touchLock = false;
					if (rd.scale > 1) {
						isDragging = true;
						gesture.startDist = 0;
						gesture.startScale = rd.scale;
						gesture.startMid = getMidpoint(e.touches);
						const rectPage = page.getBoundingClientRect();
						const rectPageTarget = pageTarget.getBoundingClientRect();
						gesture.startContent.x = (gesture.startMid.x - rectPageTarget.left);
						gesture.startContent.y = (gesture.startMid.y - rectPageTarget.top);
					}
				}
				else if (isDragging && (e.touches.length == 0)) {
					isDragging = false;
				}
			});
		}

		createPinchAndPanResponse(touchPanel, readerContainer);
		createPinchAndPanResponse(webtoonContainer, readerContainer);


		//MB Manage Electron titlebar

		function enableDragbar(enabled) {
			if (!enabled) {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '0px');
				document.getElementById('dragbar').style.display = 'none';
			} else {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '22px');
				document.getElementById('dragbar').style.display = '';
			}
		}


		if (isElectron) {
			dragbarMinBtn.addEventListener('click', () => {
				window.electronAPI.minimize();
			});

			dragbarMaxBtn.addEventListener('click', () => {
				window.electronAPI.maximize();
			});

			dragbarCloseBtn.addEventListener('click', () => {
				window.electronAPI.close();
			});

			window.electronAPI.onFullscreenChange((isFullscreen) => {
				enableDragbar(!isFullscreen);
			});

			window.electronAPI.onMaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-maximize');
				dragbarMaxBtn.classList.add('fa-window-restore');
			});

			window.electronAPI.onUnmaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-restore');
				dragbarMaxBtn.classList.add('fa-window-maximize');
			});

			window.electronAPI.getAppVersion().then(version => {
				dragbarAppTitle.textContent = 'MangaBox v' + version;
			});
		}

		// Hide dragbar in PWA mode
		(function () {
			enableDragbar(isElectron);
		})();

		//MB Offline Events Response

		function obUpdateProgressResponse(bookId, completed, total) {
			//DEBUG THIS IS CHECK FOR DOUBLE ELEMENTS
			let duplicates = document.querySelectorAll(`#${CSS.escape(bookId)}`);

			if (duplicates.length > 1) {
				console.warn(`Duplicate ID found for ${bookId}:`, duplicates);
			} else if (duplicates.length === 1) {
				console.log(`Only one element found for ${bookId}.`);
			} else {
				console.log(`No element found for ${bookId}.`);
			}


			const percent = Math.round((completed / total) * 100);
			obSetBookProgress(bookId, percent);
			obSetSpinner(true);

			let tempDiv = document.getElementById(bookId);
			if (tempDiv) {
				let tempDivChild = tempDiv.querySelector('.book-downloader');
				tempDivChild.style.bottom = percent + '%';
				tempDivChild.innerText = percent + '%';

				let tempDivChild2 = tempDiv.querySelector('.download-book');
				tempDivChild2.innerHTML = obRedrawDownloadButton(bookId);
			}

		}

		function obDownloaDcompleteResponse(bookId, completed, total) {
			let tempDiv = document.getElementById(bookId);

			let tempDivChild = tempDiv.querySelector('.book-downloader');
			tempDivChild.innerText = '100%';
			tempDivChild.classList.add('done');

			obSetBookCompleted(bookId);
			obSetSpinner(false);

			let tempDivChild2 = tempDiv.querySelector('.download-book');
			tempDivChild2.innerHTML = obRedrawDownloadButton(bookId);
		}

		if (isCapacitor || isElectron) {
			window.addEventListener('download-progress', (event) => {
				const { bookId, completed, total } = event.detail;
				obUpdateProgressResponse(bookId, completed, total);
			});

			window.addEventListener('download-complete', (event) => {
				const { bookId, completed, total } = event.detail;
				obDownloaDcompleteResponse(bookId, completed, total)
			});
		}


		//MB General Functions 

		//let mb.readerScale = getComputedStyle(document.documentElement).getPropertyValue('--mb-reader-scale');

		function addItem(itemkind, properties) {
			const { style, ...rest } = properties;
			const element = Object.assign(document.createElement(itemkind), rest);
			if (style) Object.assign(element.style, style);
			return element;
		}

		function getScreenAR() {
			return (window.innerWidth / window.innerHeight);
		}

		function toggleFullscreen() {
			if (!document.fullscreenElement) {
				document.documentElement.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		}

		document.addEventListener('fullscreenchange', updateFullscreenLabel);

		function updateFullscreenLabel() {
			const isFull = !!document.fullscreenElement;
			fullscreenLabel.classList.toggle('fa-compress', isFull);
			fullscreenLabel.classList.toggle('fa-expand', !isFull);
		}

		//MB Main Variable Setup 
		function initMB() {
			return (
				{
					libMenuVisible: null,
					swatchMenuVisible: false,

					baseUrl: localStorage.getItem('mbBaseUrl'),
					authToken: false,

					basePath: '', //'/mangabox/'
					darkTheme: false,

					// Scaling of selected item control
					currentlyScaled: null,

					// Current book references for book details
					currentBook: null,
					seriesData: null,
					prevBook: null,
					nextBook: null,

					// Screen aspect ratio functions
					screenAR: getScreenAR(),
					readerMaxRatio: 1,
					readerHorizontal: true,
					resizeTimeout: null,

					// Filter table placeholders
					filterTable: null,
					filterButtons: null,
					filterSizer: null,

					libraryMenuButtons: {},

					libSizer: {}, // Used to calculate libraries button size
					dashboardBin: '',
					/*
						When an item from a bin is opened, the mb.dashboardBin is set, so when the dashboard is reloaded
						it reads this variable, if it is not "" the focus is shifted to the bin, and the variable is cleared.
						In this way subsequent clicks on dashboard button will load the top position.
						This variable is cleared whenever a new "Navigate To" is called that is not to dashboard
					*/

					// Theme management variables
					themeControl: [
						{
							label: 'Light theme',
							icon: 'fa-sun',
							isDark: 0
						}, {
							label: 'Dark theme',
							icon: 'fa-moon',
							isDark: 1
						}, {
							label: 'System theme',
							icon: 'fa-wand-magic-sparkles',
							isDark: 2
						}
					],

					readerThemeControl: [
						{
							label: 'Classic theme',
							icon: 'fa-palette',
							style: 'classic'
						}, {
							label: 'Dark accent',
							icon: 'fa-moon',
							style: 'dark-accent'
						}, {
							label: 'Light accent',
							icon: 'fa-sun',
							style: 'light-accent'
						}, {
							label: 'Transparent',
							icon: 'fa-square',
							style: 'transparent'
						}, {
							label: 'White',
							icon: 'fa-w',
							style: 'white'
						}, {
							label: 'Black',
							icon: 'fa-b',
							style: 'black'
						}
					],

					readerAnimationControl: [
						{
							label: 'No Page Animation',
							icon: 'fa-pause',
							value: 0
						}, {
							label: 'Animate Pages',
							icon: 'fa-right-left',
							value: 1
						}
					],

					swatchesHi: getComputedStyle(document.documentElement)
						.getPropertyValue('--mb-swatches-hi')
						.match(/hsl\([^)]*\)/g)
						.map(swatch => swatch.match(/(\d+%?)/g)),

					swatchesLo: getComputedStyle(document.documentElement)
						.getPropertyValue('--mb-swatches-lo')
						.match(/hsl\([^)]*\)/g)
						.map(swatch => swatch.match(/(\d+%?)/g)),

					// Media Cache
					mediaCacheRAM: new Map(), 	//Media cache table structure
					cacheLimitRAM: 250,			//Limit of items in media cache

					clickingTile: null,
					pointerItem: null,

					webtoonScale: 100,
					readerScale: 100,

					offlineBooks: JSON.parse(localStorage.getItem('mbOfflineBooks') ?? '{}')

				}
			)
		}
		// Main MangaBox data structure, for variables that are common to the whole app
		let mb = initMB();

		//TODO: make this a function that repsonds to theme changes and create/colorizes the blocks? and maybe use it at bootsequence
		const colorValues = getComputedStyle(document.documentElement)
			.getPropertyValue('--mb-swatches-hi')
			.match(/hsl\([^)]*\)/g);

		colorValues.forEach((value, index) => {
			const appleColor = [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1];
			const colorSwatch = addItem('span', {
				className: 'color-swatch press-flat-button', //TODO tornare ai vecchi modi?
				innerHTML: appleColor[index] == 1 ? '<i class="fa-brands fa-apple"></i>' : '',
				style: {
					backgroundColor: value,
				},
			});
			addPressEvents(colorSwatch, scaleDownShallow, scaleUp);
			colorSwatch.addEventListener('click', (event) => {
				event.stopPropagation();
				mb.accentColor = index;
				applyAccent();
			});
			colorSwatchBar.append(colorSwatch);
		});

		function buildRequest(authToken, method, body) {
			const requestTable = {
				method: method,
				...(!isElectron && { credentials: 'include' }),
				headers: {
					'Content-Type': 'application/json',
					'X-Requested-With': 'XMLHttpRequest',
					'skip_zrok_interstitial': '1',
					...(isElectron && { 'X-Auth-Token': authToken })
				},
				...(body && { body }),
			}
			return requestTable
		}

		function buildRequestMedia(authToken, method, body) {
			const requestTable = {
				method: method,
				...(!isElectron && { credentials: 'include' }),
				headers: {
					'X-Requested-With': 'XMLHttpRequest',
					'skip_zrok_interstitial': '1',
					...(isElectron && { 'X-Auth-Token': authToken })
				},
			}
			return requestTable
		}

		function cacheKeyFromUrl(url) {
			return 'cache_' + url.replace(/[^a-z0-9]/gi, '_');
		}

		async function onlineCheck() {
			try {
				const res = await fetch(
					`${mb.baseUrl}/api/v1/client-settings/global/list`,
					{ method: 'GET', cache: 'no-store' }
				);

				console.log(res);

				if (!res.ok) {
					console.log("Server reachable but unhealthy:", res.status);
					setNetworkStatus('offline');
					return;
				}

				console.log("Server OK");
				setNetworkStatus('online');

			} catch (err) {
				console.log("Network error, still offline");
				setNetworkStatus('offline');
			}
		}




		//MB API Call Function 

		async function callAPI(cacheKey, API_url, method = 'GET', body = null, returnval = true) {
			const db = await openIndexedDB();
			console.log("API Call, offlineSession: " + offlineSession)
			if (offlineSession) {
				await onlineCheck() //TODO forse qui await?
			};

			if (offlineSession) {
				console.log(`Offline mode: using cache for ${API_url}`);
				if (cacheKey != null) {
					const cached = await getCachedData(db, cacheKey);
					if (cached) return cached;
				}
				console.warn(`No cached data for ${API_url} while offline`);
				return null; // or throw if needed
			}

			if (!offlineSession) {
				await obRefreshReadStatus();
			}

			try {
				const response = await fetch(`${mb.baseUrl}${API_url}`, buildRequest(mb.authToken, method, body));
				if (response.status === 404 || response.status === 204) {
					console.warn(`API ${API_url} ${body} returned ${response.status}`);
					return null;
				}

				if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);

				setNetworkStatus('online');

				if (returnval) {
					const output = await response.json();
					if (cacheKey != null) await cacheData(db, cacheKey, output);
					return output;
				}
			} catch (error) {
				console.error(`Fetch error for ${API_url}:`, error);
				setNetworkStatus('offline');

				return (callAPI(cacheKey, API_url, method, body, returnval));

				throw error;
			}
		}
		/*
		async function fetchWithFallback(url, key) {
		  try {
			 const res = await fetch(url);
			 if (!res.ok) throw new Error('HTTP error');
			 const data = await res.json();
		
			 // cache for offline use
			 localStorage.setItem(key, JSON.stringify(data));
		
			 return data;
		  } catch (err) {
			 console.warn('Fetch failed, using cached data:', err);
			 const cached = localStorage.getItem(key);
			 if (cached) return JSON.parse(cached);
			 throw err; // nothing cached → still fail
		  }
		}
		*/

		async function getUserSettings() {
			let mangaboxFlat = null;
			const settings = await callAPI('c_usersettings', '/api/v1/client-settings/user/list', 'GET');

			mangaboxFlat = Object.fromEntries(
				Object.entries(settings)
					.filter(([key]) => key.startsWith('mangabox'))
					.map(([key, obj]) => [key, obj.value])
			);
			return mangaboxFlat
		}

		async function setUserSettings(key, value) {

			const db = await openIndexedDB();

			const payload = {
				[key]: { value: value },
			};
			userSettings[key] = value;

			// Ensure local cache mirrors the API structure
			const cached = await getCachedData(db, 'c_usersettings') || '{}';

			cached[key] = { value }; // keep the nested shape
			cacheData(db, 'c_usersettings', cached);

			await callAPI(null, '/api/v1/client-settings/user', 'PATCH', JSON.stringify(payload), false);
		}

		async function delUserSettings() {
			await callAPI(null, '/api/v1/client-settings/user', 'DELETE', JSON.stringify([
				'mangabox.ui.accentcolor',
				'mangabox.ui.themeprefs',
				'mangabox.ui.readerthemeprefs',
				'mangabox.ui.libraryfilters',
				'mangabox.ui.libraryicons',
			]), false);
		}

		let userSettings;

		//delUserSettings()

		function applyUserSettings() {
			// Server user variable setup
			mb.accentColor = Number(userSettings['mangabox.ui.accentcolor'] ?? 0);
			mb.themePrefs = Number(userSettings['mangabox.ui.themeprefs'] ?? 0);
			mb.readerThemePrefs = Number(userSettings['mangabox.ui.readerthemeprefs'] ?? 0);
			mb.libraryFilters = JSON.parse(userSettings['mangabox.ui.libraryfilters'] || '{}');
			mb.libraryIcons = JSON.parse(userSettings['mangabox.ui.libraryicons'] || '{}');

			// Local storage variable setup
			mb.webtoonScale = Number(localStorage.getItem('c_webtoonScale') ?? 100);
			mb.readerScale = Number(localStorage.getItem('c_readerScale') ?? 100);
			mb.readerAnimation = Number(localStorage.getItem('c_readerAnimation') ?? 1)
		}


		//MB Theme Management 

		function warmth(hue) {
			const warmth = (Math.cos((hue - 50) * Math.PI / 180) + 1) / 2;
			return warmth;
		}

		function applyAccent() {
			const swatches = mb.darkTheme ? mb.swatchesLo : mb.swatchesHi;

			['--mb-h', '--mb-s', '--mb-l'].forEach((varName, index) => {
				document.documentElement.style.setProperty(varName, swatches[mb.accentColor][index]);
			});
			document.documentElement.style.setProperty('--mb-h-deg', swatches[mb.accentColor][0] + 'deg');

			document.documentElement.style.setProperty('--mb-gradient-1', Number(swatches[mb.accentColor][0]));
			document.documentElement.style.setProperty('--mb-gradient-2', Number(swatches[mb.accentColor][0]) - 10);

			setUserSettings('mangabox.ui.accentcolor', mb.accentColor);
		}

		function swapThemeClass(classSelector, lightClass, darkClass, toDark) {
			Array.from(document.getElementsByClassName(classSelector)).forEach((item) => {
				if (!item.classList.contains('no-theme-icon')) {
					item.classList.toggle(darkClass, toDark);
					item.classList.toggle(lightClass, !toDark);
				}
			});
		}

		function changeLoginTheme(toDark) {
			document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');
		}

		function changeTheme() {

			let toDark = false;

			if (mb.themePrefs != 2) {
				toDark = (mb.themePrefs == 1)
			} else {
				toDark = mbPrefersDarkMode.matches ? true : false
			}

			// Set css theme to dark or light
			document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');

			mb.themeControl.forEach(item => {
				themeLabel.classList.remove(item.icon);
			});

			themeLabel.classList.add(mb.themeControl[mb.themePrefs].icon);
			themeLabel.title = mb.themeControl[mb.themePrefs].label;
			// Change fa icons for light or dark theme
			swapThemeClass('fa-file', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-calendar', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-clock', 'fa-regular', 'fa-solid', toDark);

			// Save theme setting in local storage
			setUserSettings('mangabox.ui.themeprefs', mb.themePrefs);

			mb.darkTheme = toDark;

			applyAccent(); //TODO Maybe this substitutes other accent color changes?
		}


		mbPrefersDarkMode.addEventListener('change', () => {
			if (isLoginScreenHidden()) {
				changeTheme()
			} else {
				changeLoginTheme(mbPrefersDarkMode.matches ? true : false)
			}
		});

		// Show/Hide section functions
		function sectionHide(item) {
			if (!item.classList.contains('hidden')) item.classList.add('hidden');
		}
		function sectionShow(item) {
			item.classList.remove('hidden');
		}
		function sectionToggle(item) {
			item.classList.toggle('hidden');
		}
		function isSectionHidden(item) {
			return (item.classList.contains('hidden'));
		}

		// Show/Hide reader pages/spreads
		function spreadHide(index) {
			rd.spreadsArray[index].uiItem.classList.add('hidden-spread');
		}
		function spreadShow(index) {
			rd.spreadsArray[index].uiItem.classList.remove('hidden-spread');
		}
		function isSpreadHidden(index) {
			return (rd.spreadsArray[index].uiItem.classList.contains('hidden-spread'));
		}

		colorChanger.addEventListener('click', () => {

			const unrollTimeout = isSectionHidden(filtersBar) ? 0 : 200

			if ((mb.libMenuVisible != null)) {
				libMenuDown(mb.libraryMenuButtons[mb.libMenuVisible]);
				sectionToggle(filtersBar);
				mb.libMenuVisible = null;
			}

			setTimeout(() => {
				sectionToggle(colorSwatchBar);
			}, unrollTimeout);

			mb.swatchMenuVisible = !mb.swatchMenuVisible

		});

		themeChanger.addEventListener('click', () => {
			mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
			changeTheme();
		});

		if (enableFullscreen) {
			fullscreenChanger.addEventListener('click', () => {
				// mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
				//changeTheme();
				toggleFullscreen();
			});
		}

		if (enableDownload) {
			offlineLibrary.addEventListener('click', () => {
				navigateTo(`#offlinebooks`);
			});
		}
		/*
			readlistsButton2.addEventListener('click', () => {
				navigateTo(`#readlists`);
			});
						collectionsButton2.addEventListener('click', () => {
				navigateTo(`#collections`);
			});
*/
		logOut.addEventListener('click', async () => {
			let currentUser = await callAPI(null, '/api/v2/users/me')
			if (currentUser == null) currentUser = {
				email: 'Offline'
			}
			let dialogText = `
			<div style="width:100%; text-align:left; display: inline-flex; align-items: center; gap: 10px;">
				<span class="fa-solid fa-user"></span><span>${currentUser.email}</span>
			</div>
			<div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--mb-accent); width:100%; text-align:left; display: inline-flex; align-items: center; gap: 10px;">
				<span class="fa-solid fa-server"></span><span style="word-break: break-all;">${mb.baseUrl}</span>
			</div>
			`
			showModal('', true, dialogText,
				[
					{
						label: 'Logout', runfunction: async () => {
							closeModal();
							navigateTo('#dashboard');
							await executeFaderGradient(1);

							try {
								if (mb.baseUrl) {
									await fetch(`${mb.baseUrl}/api/logout`, {
										method: 'POST',
										credentials: 'include',
										headers: {
											'X-Requested-With': 'XMLHttpRequest',
											'skip_zrok_interstitial': '1',
										},
									});
								}
							} catch (error) {
								console.warn('Logout API call failed:', error);
								// We continue cleanup anyway
							}


							if (isElectron) await deleteToken();

							//sectionHide(stickyContainer);
							//sectionShow(blanker);

							Object.keys(localStorage).forEach(key => {
								if (key.startsWith("c_")) {
									localStorage.removeItem(key);
								}
							});

							await clearIndexedDB();
							localStorage.removeItem("sessionValid");

							mainLoader.classList.add('hidden');

							systemRestart();

						}, high: true
					},
					{
						label: 'Cancel', runfunction: closeModal, high: false
					}
				]
			);
		});

		function updateSearchX() {
			clearSearchBtn.style.display = searchInput.value ? '' : 'none';
			//searchInput.style.paddingRight = searchInput.value ? '30px' : '10px';
		}

		function clearSearchField() {
			searchInput.value = '';
			updateSearchX();
		}

		clearSearchBtn.addEventListener('pointerdown', e => {
			e.stopPropagation();
		});

		clearSearchBtn.addEventListener('pointerup', e => {
			e.stopPropagation();
		});

		searchInput.addEventListener('input', () => {
			updateSearchX()
		});

		searchInput.addEventListener('click', () => {
			updateSearchX()
		});

		clearSearchBtn.addEventListener('click', (e) => {
			e.stopPropagation();

			clearSearchField();
			searchInput.focus();
		});


		searchInput.addEventListener('keydown', (event) => {
			if (event.key === 'Enter') {
				mb.dashboardBin = '';
				if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
			}
		});

		searchIcon.addEventListener('click', () => {
			if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
		})

		//MB Scroll Bars

		function createCustomScrollbar(scrollbox) {
			if (scrollbox.dataset.scrollbarInitialized) return;
			scrollbox.dataset.scrollbarInitialized = 'true';

			// Get direction dynamically
			function isHorizontal() {
				return (scrollbox.dataset.scrollDirection || 'vertical') === 'horizontal';
			}

			const content = scrollbox.querySelector('.scrollbox-content');
			const scrollbar = scrollbox.querySelector('.scrollbox-scrollbar');
			const thumb = scrollbar.querySelector('.scrollbox-thumb');

			let fadeTimeout;

			function showScrollbarTemporarily() {
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
				fadeTimeout = setTimeout(() => {
					scrollbar.classList.remove('visible');
				}, 1000);
			}

			function updateScrollbarThumb() {
				const horizontal = isHorizontal();
				const total = horizontal ? content.scrollWidth : content.scrollHeight;
				const visible = horizontal ? content.clientWidth : content.clientHeight;
				const scroll = horizontal ? content.scrollLeft : content.scrollTop;

				const scrollable = total > visible;

				if (!scrollable) {
					scrollbar.classList.remove('visible');
					thumb.style.display = 'none';
					return;
				}

				thumb.style.display = 'block';

				const margin = 10;

				let thumbSize = Math.max((visible / total) * visible, 30);
				let midBoxRate = (scroll / (total - visible));
				let thumbPos = margin + midBoxRate * (visible - 2 * margin - thumbSize);

				if (horizontal) {
					thumb.style.width = thumbSize + 'px';
					thumb.style.left = thumbPos + 'px';
					thumb.style.height = ''; // reset opposite axis
					thumb.style.top = '';
				} else {
					thumb.style.height = thumbSize + 'px';
					thumb.style.top = thumbPos + 'px';
					thumb.style.width = ''; // reset opposite axis
					thumb.style.left = '';
				}
			}

			content.addEventListener('scroll', () => {
				updateScrollbarThumb();
				showScrollbarTemporarily();
			});

			scrollbox.addEventListener('mouseenter', () => {
				updateScrollbarThumb();
				showScrollbarTemporarily();
			});

			// Drag support
			let isDragging = false;
			let startPos, startThumbPos;

			thumb.addEventListener('mousedown', (e) => {
				isDragging = true;
				const horizontal = isHorizontal();
				startPos = horizontal ? e.clientX : e.clientY;
				startThumbPos = parseInt(thumb.style[horizontal ? 'left' : 'top']) || 0;
				document.body.style.userSelect = 'none';
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				const horizontal = isHorizontal();
				const delta = (horizontal ? e.clientX : e.clientY) - startPos;
				const trackSize = horizontal ? content.clientWidth : content.clientHeight;
				const newThumbPos = Math.min(trackSize - (horizontal ? thumb.offsetWidth : thumb.offsetHeight), Math.max(0, startThumbPos + delta));
				const scrollRatio = newThumbPos / trackSize;
				if (horizontal) {
					content.scrollLeft = scrollRatio * content.scrollWidth;
				} else {
					content.scrollTop = scrollRatio * content.scrollHeight;
				}
			});

			document.addEventListener('mouseup', () => {
				if (isDragging) {
					isDragging = false;
					document.body.style.userSelect = '';
					showScrollbarTemporarily();
				}
			});

			const observer = new MutationObserver(updateScrollbarThumb);
			observer.observe(content, {
				childList: true,
				subtree: true,
				characterData: true,
				attributes: true,
			});

			scrollbox.refreshScrollbar = updateScrollbarThumb;
			updateScrollbarThumb();
		}


		document.querySelectorAll('.scrollbox').forEach(createCustomScrollbar);

		//MB Modal Dialog
		let modalGlobal = [];

		function showModal(image, bg, message, itemsArray) {
			document.querySelectorAll('.modal-button').forEach(el => {
				el.remove();
			});			//modalFunctionsGlobal = functionArray;
			modalWrapper.style.backgroundImage = bg ? '' : 'none';
			modalImage.src = image;
			modalMessage.innerHTML = message;

			modalWrapper.style.display = image == '' ? 'none' : 'block';
			//myModal.style.display = 'flex';

			itemsArray.forEach(item => {
				let uiButton = addItem('button', {
					innerText: item.label,
					className: (item.high ? 'ok' : 'cancel') + ' dialog-button press-button modal-button',
				})
				addPressEvents(uiButton, pressDown, pressUp);
				uiButton.addEventListener('click', item.runfunction);
				modalContent.append(uiButton);
			});

			myModal.classList.add('visible');
		}

		function closeModal() {
			myModal.classList.add('unfade');
			modalImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

			setTimeout(() => {
				// Optional: if you still want to hide it completely from screen readers / tab order
				myModal.classList.remove('visible');
				myModal.classList.remove('unfade');
				modalMessage.innerHTML = "";
				document.querySelectorAll('.modal-button').forEach(el => {
					el.remove();
				});
			}, 300);
		}


		async function handleThumbnailClick(imagePath, libraryId) {
			try {
				const response = await fetch(imagePath);
				const blob = await response.blob();

				const base64 = await readFileAsBase64(blob);

				applyLibraryImage(libraryId, base64);

			} catch (err) {
				console.error("Error converting image:", err);
				showModal('circle-mark-svg.svg', true, 'Failed to load image.',
					[{ label: 'Ok', runfunction: cancelUpdate, high: true }]);
			}
		}

		function generatePics(libraryId, text) {
			let thumbNames = ["Manga", "Comics", "Girls", "Shojo", "Fantasy", "Puppet", "Robots", "Space", "Western", "Horror", "Detective", "Humor"];
			let out = "";
			thumbNames.forEach(thumbName => {
				out = out + `
				<img class="mini-thumb press-button" src="library-thumbnails/${thumbName}.svg"
				onClick="handleThumbnailClick('library-thumbnails/${thumbName}.svg', '${libraryId}')">
				`
			})
			out = out + `<div>${text}</div>`
			return (out)
		}



		//MB Search Functions 

		function timeSplit(inTime) {
			let outTime = inTime ?? '1111';
			outTime = outTime.replace('TBD', '9999').split('-');
			if (outTime.length == 1) outTime.push(outTime[0]);
			return outTime
		}

		async function performSearch(searchString) {
			libraryHighlight('searchField', false);

			/*
			if (searchString.includes('d:')) {

				const unFilteredBooks = await callAPI('c_bookslistall',
					`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
					'POST', `{"condition": {"allOf": []}}`
				);
				unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

				const filteredBooks = unFilteredBooks.content.filter(item =>
					obIsBookDownloading(item.id) || obIsBookCompleted(item.id)
				);
				displayBooks(filteredBooks, homeStripBooksResults, 'compact', 'top');

				focusItem('top');
				setTimeout(updateSliderProperties, 10);
				sectionShow(searchStripsContainer);

				return
			}
			*/

			if (searchString.includes('y:')) {

				const unFilteredSeries = await callAPI('c_serieslistall',
					`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
					'POST', `{"condition": {"allOf": []}}`
				);
				const dataArray = unFilteredSeries.content;
				const searchYear = timeSplit(searchString.split('y:')[1].split(' ')[0]);

				let start = 0;
				let stop = 0;
				let filterArray = [];

				for (let i = 0; i < dataArray.length; i++) {
					if (dataArray[i].metadata.alternateTitles.length == 0) {
						filterArray.push(false);
						continue;
					}
					const dateArray = dataArray[i].metadata.alternateTitles.find(item => item.label === 'Time').title.replace('TBD', '5000').split('-');
					start = (Number(dateArray[0]));
					stop = (Number(dateArray[1] ?? dateArray[0]));

					filterArray.push(!((start > Number(searchYear[1])) || (stop < Number(searchYear[0]))));
				}

				const filteredSeries = dataArray.filter((item, index) =>
					filterArray[index]
				);
				displaySeries(filteredSeries, homeStripSeriesResults, null, false);

				// Reset book results strip
				//TODO Need to check also books for year?
				displayBooks([], homeStripBooksResults, 'full', 'top');

				focusItem('top');
				setTimeout(updateSliderProperties, 10);
				sectionShow(searchStripsContainer);

				return
			}

			const unFilteredSeries = await callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredSeries = unFilteredSeries.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.titleSort.toLowerCase().includes(searchString) ||
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title.toLowerCase().includes(searchString)
				)
			);
			displaySeries(filteredSeries, homeStripSeriesResults, null, false);
			focusItem('top');

			const unFilteredBooks = await callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.summary.toLowerCase().includes(searchString) ||
				item.metadata.tags.some(
					tagIn => tagIn.toLowerCase().includes(searchString)
				)
			);
			displayBooks(filteredBooks, homeStripBooksResults, 'full', 'top');

			setTimeout(updateSliderProperties, 10);
			sectionShow(searchStripsContainer);
		}

		//MB Library Filtering 
		function initFilterTable() {
			return ({
				sorting: {
					name: 'sorting',
					selected: 0,
					iconClass: 'fa-solid fa-heading glyph-dark',
					item: null,
					icon: null,
					caption: null,
					title: 'Sort items',
					switches: [
						{
							name: 'a_to_z',
							caption: 'by Title',
							iconClass: 'fa-solid fa-arrow-down-a-z glyph-dark',
							sortFunction: (a, b) => a.mbSeriesTitle.localeCompare(b.mbSeriesTitle)
						}, {
							name: 'z_to_a',
							caption: 'by Title',
							iconClass: 'fa-solid fa-arrow-down-z-a glyph-dark',
							sortFunction: (a, b) => b.mbSeriesTitle.localeCompare(a.mbSeriesTitle)
						}, {
							name: '9_to_1',
							caption: 'by Start',
							iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
							sortFunction: (a, b) => ((Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)) - (Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)))
						}, {
							name: '1_to_9',
							caption: 'by Start',
							iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
							sortFunction: (a, b) => ((Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)) - (Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)))
						}, {
							name: '9_to_1',
							caption: 'by End',
							iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
							sortFunction: (a, b) => ((Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)) - (Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)))
						}, {
							name: '1_to_9',
							caption: 'by End',
							iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
							sortFunction: (a, b) => ((Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)) - (Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)))
						}, {
							name: '1_to_9',
							caption: 'Books',
							iconClass: 'fa-solid fa-cubes-stacked fa-flip-vertical glyph-dark',
							sortFunction: (a, b) => (Number(b.mbBooksCount) - Number(a.mbBooksCount))
						}, {
							name: '9_to_1',
							caption: 'Books',
							iconClass: 'fa-solid fa-cubes-stacked glyph-dark',
							sortFunction: (a, b) => (Number(a.mbBooksCount) - Number(b.mbBooksCount))
						}
					],
				},
				filter_by_read: {
					name: 'filter_by_read',
					selected: 0,
					iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
					item: null,
					icon: null,
					caption: null,
					title: 'Filter by read status',
					switches: [
						{
							name: 'all',
							caption: 'All',
							iconClass: 'fa-solid fa-circle-half-stroke glyph-dark',
							filterFunction: (a) => true
						}, {
							name: 'unread',
							caption: 'Unread',
							iconClass: 'fa-regular fa-circle glyph-dark',
							filterFunction: (a) => (a.mbSeriesRead == false)
						}, {
							name: 'read',
							caption: 'Read',
							iconClass: 'fa-solid fa-circle glyph-dark',
							filterFunction: (a) => (a.mbSeriesRead == true)
						}
					],
				},
				filter_by_direction: {
					name: 'filter_by_direction',
					selected: 0,
					iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
					item: null,
					icon: null,
					caption: null,
					title: 'Filter by reading direction',
					switches: [
						{
							name: 'all',
							caption: 'All',
							iconClass: 'fa-solid fa-arrow-right-arrow-left glyph-dark',
							filterFunction: (a) => true

						}, {
							name: 'l_to_r',
							caption: 'L to R',
							iconClass: 'fa-solid fa-arrow-right glyph-dark',
							filterFunction: (a) => (a.mbSeriesDirection == 'LEFT_TO_RIGHT')

						}, {
							name: 'r_to_l',
							caption: 'R to L',
							iconClass: 'fa-solid fa-arrow-left glyph-dark',
							filterFunction: (a) => (a.mbSeriesDirection == 'RIGHT_TO_LEFT')
						}, {
							name: 'webtoon',
							caption: 'WToon',
							iconClass: 'fa-solid fa-arrow-down glyph-dark',
							filterFunction: (a) => (a.mbSeriesDirection == 'WEBTOON')
						}
					],
				},
				filter_by_language: {
					name: 'filter_by_language',
					selected: 0,
					iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
					item: null,
					icon: null,
					caption: null,
					title: 'Filter by language',
					switches: [
						{
							name: 'all',
							caption: 'All',
							iconClass: 'fa-solid fa-earth-europe glyph-dark',
							filterFunction: (a) => true
						}
					],
				},
			});
		}
		mb.filterTable = initFilterTable();

		async function buildLanguageList() {
			const languageList = await callAPI('c_languages', `/api/v1/languages`);
			languageList.forEach(item => {
				mb.filterTable.filter_by_language.switches.push({
					name: item,
					caption: item.toUpperCase(),
					iconClass: 'fa-solid fa-square glyph-dark glyph-flag-button',
					iconStyle: `background-image:url('flags/${item}.svg')`,
					filterFunction: (a) => a.mbSeriesLanguage == item
				})
			});
		};

		mb.filterButtons = [
			mb.filterTable.sorting,
			mb.filterTable.filter_by_read,
			mb.filterTable.filter_by_direction,
			mb.filterTable.filter_by_language
		];

		function saveLibraryFilters() {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');
			let filterOut = {};
			mb.filterButtons.forEach(button => {
				filterOut[button.name] = button.selected;
			});
			mb.libraryFilters[libraryId] = filterOut;
			setUserSettings('mangabox.ui.libraryfilters', JSON.stringify(mb.libraryFilters));
		}

		function fetchLibraryFilters(libraryId) {
			filterValues = mb.libraryFilters[libraryId];
			if (filterValues) {
				mb.filterButtons.forEach(button => {
					mb.filterTable[button.name].selected = filterValues[button.name];
				});
			}
			applyLibraryFilters()
		}


		async function applyLibraryFilters(boot = false) {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');

			const divs = seriesContainerProxy;//Array.from(seriesGrid.children);
			divs.forEach(div => {
				div.infilter = true;
			});

			const isFiltered = Object.values(mb.filterButtons).reduce((sum, item) => sum + (item.selected || 0), 0);

			mb.libraryMenuButtons[libraryId].classList.remove('filtered');
			if (isFiltered != 0) mb.libraryMenuButtons[libraryId].classList.add('filtered');

			mb.filterButtons.forEach(button => {
				button.icon.innerHTML = `<span style="${button.switches[button.selected].iconStyle}" class="${button.switches[button.selected].iconClass}${button.selected != 0 ? ' mb-accent' : ''}"></span>`;
				button.caption.innerHTML = `${button.switches[button.selected].caption}`;

				//For each button check if the button is a sort button or one of the filters buttons
				if (button.switches[button.selected].sortFunction) {
					// We are processing the sort
					divs.sort((a, b) => {
						return button.switches[button.selected].sortFunction(a, b);
					});
					/*
					divs.forEach((item, index) => {
						item.style.order = index;
					});
					*/
					/*
					if (!boot){
						seriesGrid.innerHTML = "";
						divs.forEach(div => seriesGrid.appendChild(div));
					}
					*/
				} else {
					// We are processing the filters, infilter is "and"ed with all the button filters.
					divs.forEach((div) => {
						div.infilter = div.infilter && button.switches[button.selected].filterFunction(div);
					});
				}
			});
			seriesGrid.innerHTML = "";
			if (!boot) {
				divs.forEach(div => {
					if (div.infilter) seriesGrid.appendChild(div)
				});
			}
			/*
			divs.forEach((div) => {
				div.style.display = div.infilter ? '' : 'none';
			});
			*/
		}

		// Build filter buttons items
		function buildFilters() {
			mb.filterButtons.forEach(button => {
				button.item = addItem('li', {
					className: `filter-item press-button`,
					title: button.title,
				});
				button.icon = addItem('div', {
					className: `smallbutton-wrapper`,
					innerHTML: `<span style="${button.switches[0].iconStyle}" class="${button.switches[0].iconClass}"></span>`
				});
				button.caption = addItem('div', {
					className: `library-name`,
					innerHTML: `${button.switches[0].caption}`
				});
				button.item.append(
					button.icon,
					button.caption
				);
				extraButtons.append(button.item);
				button.item.addEventListener('click', async () => {
					button.selected = ((button.selected + 1) % button.switches.length);
					await executeFade(1);
					applyLibraryFilters();
					await executeFade(0);
					saveLibraryFilters();
				})
			});

			extraButtons.append(addItem('li', {
				title: 'Reset filters and sorting',
				className: `filter-item press-button`,
				innerHTML: `<div class="smallbutton-wrapper">
								<span class="fa-solid fa-arrows-rotate fa-flip-horizontal glyph-dark"></span>
							</div>`,
				onclick: async () => {
					await executeFade(1);
					mb.filterButtons.forEach(button => {
						button.selected = 0;
					});
					applyLibraryFilters();
					await executeFade(0);
					saveLibraryFilters();
				}
			}));
		}
		buildFilters();

		//TODO Check what happens for webtoons since readerScale should be 100 for them?
		function isReaderHorizontal(screenAR) {
			return (screenAR / (mb.readerMaxRatio * mb.readerScale / 100) > rd.orientationThresholdRatio);
		}

		function updateReaderOrientation() {
			let newScreenAR = getScreenAR();

			if (isSectionHidden(readerContainer)) {
				mb.screenAR = newScreenAR;
				mb.readerHorizontal = isReaderHorizontal(newScreenAR);
			} else {
				//TODO THIS FORCES HORIZONTAL FIT
				/*
				mb.screenAR = newScreenAR;
				mb.readerScale = Math.min(mb.screenAR / mb.readerMaxRatio * 100, 100);
				document.documentElement.style.setProperty('--mb-reader-scale', mb.readerScale);

				return;
*/
				let newReaderHorizontal = isReaderHorizontal(newScreenAR);
				if (newReaderHorizontal != mb.readerHorizontal) {
					mb.screenAR = newScreenAR;
					mb.readerHorizontal = newReaderHorizontal;
					spreadSetFocusSmooth(getSpreadFocus(rd.currentSpreadIndex));
				}
			}
		}

		// Set the slider max value and grpahics properties based on the scroll width
		function updateSliderProperties() {
			if (isSectionHidden(homeStripsContainer)) return;

			Object.entries(dashboardElements).forEach(([name, item]) => {

				item.scrollInput.max = item.homeStrip.scrollWidth - item.homeStrip.clientWidth;
				const isOverflowing = item.homeStrip.scrollWidth > item.homeStrip.clientWidth;

				item.scrollInput.style.display = isOverflowing ? 'block' : 'none';

				const visibleRatio = item.homeStrip.clientWidth / item.homeStrip.scrollWidth;
				const sliderThumbWidth = (100 * visibleRatio);

				item.scrollInput.style.setProperty('--thumb-width', `${sliderThumbWidth}%`);
			});
		};

		function stepPageChange(increment) {
			const { path, params } = getHashAndParams();
			navigateTo('#dashboard?all=' + params.get('all') + '&page=' + (parseInt(params.get('page')) + increment));
		}

		addClickPointerEvents(stripPrevPage, () => stepPageChange(-1));
		addClickPointerEvents(stripNextPage, () => stepPageChange(1));

		addPressEvents(stripPrevPage, scaleDown, scaleUp);
		addPressEvents(stripNextPage, scaleDown, scaleUp);

		function updateStickyMenu() {
			const containerWidth = mainUI.getBoundingClientRect().width;

			document.body.classList.remove('sticky-medium', 'sticky-small', 'sticky-hybrid', 'sticky-tworows');

			if (containerWidth - mb.libSizer.rightmin - mb.libSizer.large >= 60) {
				//nothing happens
			} else if (containerWidth - mb.libSizer.rightmin - mb.libSizer.medium >= 60) {
				document.body.classList.add('sticky-medium');
			} else if (containerWidth - mb.libSizer.rightmin - mb.libSizer.small >= 60) {
				document.body.classList.add('sticky-small');
			} else {
				document.body.classList.add('sticky-tworows');
				if (containerWidth - mb.libSizer.large >= 10) {
					//nothing happens
				} else if (containerWidth - mb.libSizer.medium >= 10) {
					document.body.classList.add('sticky-medium');
				} else if (containerWidth - mb.libSizer.small >= 10) {
					document.body.classList.add('sticky-small');
				} else {
					document.body.classList.add('sticky-small')
				}
			};

			if (containerWidth - mb.filterSizer >= 0) {
				extraButtons.classList.remove('filter-small')
			} else {
				extraButtons.classList.add('filter-small')
			}

		}

		window.addEventListener('resize', () => {
			clearTimeout(mb.resizeTimeout);
			mb.resizeTimeout = setTimeout(() => {
				updateStickyMenu();
				updateSliderProperties();
				updateReaderOrientation();
			}, 250);
		});

		function fixZoomOnPWA() {
			let metaViewport = document.querySelector('meta[name="viewport"]');
			if (!metaViewport) return;

			// Disable zoom temporarily
			metaViewport.content = `width=device-width, ${isSharpCornerIphone ? '' : 'viewport-fit=cover, '}initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no`;

			// Wait for two animation frames to ensure the change takes effect
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					// Now restore zoom capability
					metaViewport.content = `width=device-width, ${isSharpCornerIphone ? '' : 'viewport-fit=cover, '}initial-scale=1.0, user-scalable=no`;
				});
			});
		}

		fixZoomOnPWA()

		window.addEventListener('orientationchange', async () => {
			/*
			if (isCapacitor && (capacitorPlatform == 'android')) {
				setTimeout(() => {
					if (isOrientationLandscape()) {
						Capacitor.Plugins.StatusBar.hide();
					} else {
						Capacitor.Plugins.StatusBar.hide();
					}
				}, 100)
			}
			*/
			fixZoomOnPWA();
			await setAndroidInsets();
		});

		document.addEventListener('visibilitychange', (event) => {
			fixZoomOnPWA()
		});

		window.addEventListener('pageshow', (event) => {
			if (event.persisted) fixZoomOnPWA();
		});

		// Fade in and Fade out routines
		function wait(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		async function executeFade(val) {
			blanker.style.opacity = val;
			await wait(100);
		}

		async function executeFaderGradient(val) {
			fader.style.opacity = val;
			await wait(300);
		}

		//MB Offline Download Functions
		function arrayBufferToBase64(buffer) {
			let binary = '';
			const bytes = new Uint8Array(buffer);
			const chunkSize = 0x8000; // 32 KB chunks
			for (let i = 0; i < bytes.length; i += chunkSize) {
				const chunk = bytes.subarray(i, i + chunkSize);
				binary += String.fromCharCode.apply(null, chunk);
			}
			return btoa(binary);
		}

		async function capacitorGetOfflineBookData(bookId) {
			const baseFolder = `offline-books/${bookId}`;
			try {
				console.log(`Reading offline book data for ${bookId}`);
				// Read and parse each metadata file
				const bookFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-book.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const pagesFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-pages.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const seriesFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-series.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const bookMetadata = JSON.parse(bookFile.data);
				const pagesMetadata = JSON.parse(pagesFile.data);
				const seriesMetadata = JSON.parse(seriesFile.data);


				// Convert base folder to a WebView-friendly URL
				const uriResult = await Capacitor.Plugins.Filesystem.getUri({
					path: baseFolder,
					directory: filesFolder
				});
				const baseUrl = Capacitor.convertFileSrc(uriResult.uri);
				const bookPath = baseUrl;

				debugPrint(`Successfully loaded offline book data for ${bookId}`)
				console.log(`Successfully loaded offline book data for ${bookId}`);
				return { bookMetadata, pagesMetadata, seriesMetadata, bookPath };

			} catch (err) {
				debugPrint('Failed to read offline book data:', err);
				console.error('Failed to read offline book data:', err);
				throw err;
			}
		}

		async function capacitorDeleteBookData(bookId) {
			try {
				const baseFolder = `offline-books/${bookId}`;

				debugPrint(`Deleting offline book data for ${bookId}...`);
				console.log(`Deleting offline book data for ${bookId}...`);

				await Capacitor.Plugins.Filesystem.rmdir({
					path: baseFolder,
					directory: filesFolder,
					recursive: true
				});

				debugPrint(`Deleted offline book ${bookId} successfully.`);
				console.log(`Deleted offline book ${bookId} successfully.`);
				return { success: true };
			} catch (err) {
				debugPrint(`Failed to delete offline book ${bookId}:`, err);
				console.error(`Failed to delete offline book ${bookId}:`, err);
				return { success: false, message: err.message };
			}
		}


		async function capacitorDownloadBook({ bookId, bookTitle, baseUrl, requestData }) {
			const mimeToExt = {
				'image/jpeg': '.jpg',
				'image/png': '.png',
				'image/webp': '.webp',
				'image/gif': '.gif',
			};

			const baseDir = 'offline-books';
			const bookFolder = `${baseDir}/${bookId}`;
			const pagesFolder = `${bookFolder}/pages`;
			const thumbsFolder = `${bookFolder}/thumbs`;

			// Helper to make directories recursively
			async function ensureDir(path) {
				try {
					await Capacitor.Plugins.Filesystem.mkdir({
						path,
						directory: filesFolder,
						recursive: true
					});
				} catch (err) {
					debugPrint("Error creating " + path);
					//if (!String(err.message).includes('exists')) throw err;
				}
			}


			await ensureDir(baseDir);
			await ensureDir(bookFolder);
			await ensureDir(pagesFolder);
			await ensureDir(thumbsFolder);

			let completed = 0;

			try {
				debugPrint(`Downloading metadata for ${bookId}`);

				debugPrint("Get Book Data")
				// Book metadata
				let res = await fetch(`${baseUrl}/api/v1/books/${bookId}`, requestData);
				if (!res.ok) debugPrint(res.status)
				if (!res.ok) throw new Error(`Book metadata failed: ${res.status}`);
				const bookMeta = await res.json();

				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-book.json`,
					data: JSON.stringify(bookMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});


				debugPrint("Get Series Data")
				// Series metadata
				res = await fetch(`${baseUrl}/api/v1/series/${bookMeta.seriesId}`, requestData);
				if (!res.ok) throw new Error(`Series metadata failed: ${res.status}`);
				const seriesMeta = await res.json();
				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-series.json`,
					data: JSON.stringify(seriesMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});

				debugPrint("Get Pages Data")
				// Pages metadata
				res = await fetch(`${baseUrl}/api/v1/books/${bookId}/pages`, requestData);
				if (!res.ok) throw new Error(`Pages metadata failed: ${res.status}`);
				const pagesMeta = await res.json();
				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-pages.json`,
					data: JSON.stringify(pagesMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});

				// Book thumbnail
				const thumbUrl = `${baseUrl}/api/v1/books/${bookId}/thumbnail`;
				res = await fetch(thumbUrl, requestData);
				if (!res.ok) throw new Error(`Failed to fetch thumbnail: ${res.status}`);

				const thumbBuffer = await res.arrayBuffer();
				const base64Thumb = arrayBufferToBase64(thumbBuffer);

				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/thumbnail.jpg`,
					data: base64Thumb,
					directory: filesFolder
				});

				// Download all pages
				for (const page of pagesMeta) {
					const pageFile = `${pagesFolder}/${page.number}${mimeToExt[page.mediaType]}`;
					const thumbFile = `${thumbsFolder}/t_${page.number}.jpg`;

					let pageExists = false;
					try {
						await Capacitor.Plugins.Filesystem.stat({
							path: pageFile,
							directory: filesFolder,
						});
						pageExists = true;
					} catch { }

					if (!pageExists) {
						const pageUrl = `${baseUrl}/api/v1/books/${bookId}/pages/${page.number}`;
						const pageRes = await fetch(pageUrl, requestData);
						if (!pageRes.ok) throw new Error(`Page ${page.number} failed: ${pageRes.status}`);
						const pageBuffer = await pageRes.arrayBuffer();
						await Capacitor.Plugins.Filesystem.writeFile({
							path: pageFile,
							data: arrayBufferToBase64(pageBuffer),
							directory: filesFolder
						});
					} else {
						console.log(`Page ${page.number} already exists, skipping.`);
					}

					let thumbExists = false;
					try {
						await Capacitor.Plugins.Filesystem.stat({
							path: thumbFile,
							directory: filesFolder,
						});
						thumbExists = true;
					} catch { }

					if (!thumbExists) {
						const thumbPageUrl = `${baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`;
						const thumbRes = await fetch(thumbPageUrl, requestData);
						if (!thumbRes.ok) throw new Error(`Thumb ${page.number} failed: ${thumbRes.status}`);
						const thumbPageBuffer = await thumbRes.arrayBuffer();
						await Capacitor.Plugins.Filesystem.writeFile({
							path: thumbFile,
							data: arrayBufferToBase64(thumbPageBuffer),
							directory: filesFolder
						});
					} else {
						console.log(`Thumb ${page.number} already exists, skipping.`);
					}
					completed++;
					// You can dispatch a custom event to your UI
					window.dispatchEvent(new CustomEvent('download-progress', {
						detail: { bookId, completed, total: bookMeta.media.pagesCount }
					}));
				}

				debugPrint(`Downloaded book "${bookTitle}" (${bookId})`);
				window.dispatchEvent(new CustomEvent('download-complete', {
					detail: { bookId, completed, total: bookMeta.media.pagesCount }
				}));

				return { ok: true, path: bookFolder };
			} catch (err) {
				debugPrint('Error in safeWriteFile:');
				debugPrint(err);
				console.error('Download failed:', err);
				return { ok: false, error: err.message };
			}
		}

		function obSaveTable() {
			localStorage.setItem('mbOfflineBooks', JSON.stringify(mb.offlineBooks));
		}

		function obSetSpinner(status) {
			let oldStatus = downloadSpinner.classList.contains('spin');
			if (oldStatus == status) return;
			downloadSpinner.classList.remove('spin');
			if (status) downloadSpinner.classList.add('spin')
		}

		function obAddBookToTable(book) {
			let page = 1;
			if (book.readProgress) {
				page = (book.readProgress.page == book.media.pagesCount)
					? page = book.media.pagesCount
					: page = book.readProgress.page
			}

			mb.offlineBooks[book.id] = {
				status: 'downloading',
				percent: 0,

				updated: false,
				page: page,
				pages: book.media.pagesCount,
			};
			obSaveTable();
		}

		function obRemoveBookFromTable(bookId) {
			delete mb.offlineBooks[bookId];
			obSaveTable();
		}

		function obSetBookCompleted(bookId) {
			mb.offlineBooks[bookId].status = 'completed';
			mb.offlineBooks[bookId].percent = 100;
			obSaveTable();
		}

		function obSetBookProgress(bookId, progress) {
			mb.offlineBooks[bookId].percent = progress;
			obSaveTable();
		}

		function obRedrawDownloadButton(bookId) {
			if (obIsBookCompleted(bookId)) {
				return ('<span class="fa-regular fa-trash-can"></span>')
			} else if (obIsBookDownloading(bookId)) {
				return ('<span class="fa-solid fa-xmark"></span>')
			}
			else {
				return ('<span class="fa-solid fa-download"></span>')
			}
		}

		function obIsBookCompleted(bookId) {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'completed';
		}

		function obIsBookDownloading(bookId) {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'downloading';
		}

		function obIsAnyBookDownloading() {
			if (!mb.offlineBooks) return false;
			return Object.values(mb.offlineBooks).some(book => book.status === 'downloading');
		}

		function obDownloadsInProgress() {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'downloading';
		}

		async function obDownloadBook(bookId) {
			let request = buildRequest(mb.authToken, 'GET', null)

			let bookData = {
				bookId: bookId,
				baseUrl: `${mb.baseUrl}`,
				requestData: request
			};

			if (isElectron) await window.offlineAPI.downloadBook(bookData);
			if (isCapacitor) await capacitorDownloadBook(bookData);

		}

		async function obDeleteBookData(bookId) {
			let result = null
			if (isElectron) result = await window.offlineAPI.deleteOfflineBookData(bookId)
			if (isCapacitor) result = await capacitorDeleteBookData(bookId)

			if (result.success) {
				console.log(`Deleted offline book ${bookId} successfully.`);
			} else {
				console.warn(`Failed to delete offline book ${bookId}: ${result.message}`);
			}
			delete mb.offlineBooks[bookId];
			obSaveTable();
			return result;
		}

		async function obLoadOfflineBook(bookId) {
			let bookData = null;
			if (isElectron) bookData = await window.offlineAPI.getOfflineBookData(bookId)
			if (isCapacitor) bookData = await capacitorGetOfflineBookData(bookId)

			if (!bookData.bookMetadata.readProgress) {
				bookData.bookMetadata.readProgress = {};
			}

			bookData.bookMetadata.readProgress.page = mb.offlineBooks[bookId].page;

			return bookData;
		}

		function obRestoreDownloadOnBoot() {
			Object.entries(mb.offlineBooks).forEach(([bookId, item]) => {
				if (item.status == 'downloading') {
					obSetSpinner(true);
					obDownloadBook(bookId);
				}
			});
		}

		async function obRefreshReadStatus() {
			Object.entries(mb.offlineBooks).forEach(([bookId, item]) => {
				if (item.updated) {
					callAPI(null, `/api/v1/books/${bookId}/read-progress`, 'PATCH', JSON.stringify({ page: item.page }), false)
					item.updated = false;
				}
			});
		}

		//MB Media Cache 

		function openIndexedDB() {
			return new Promise((resolve, reject) => {
				const request = indexedDB.open('MangaBoxCache', 1);
				request.onupgradeneeded = (event) => {
					const db = event.target.result;
					if (!db.objectStoreNames.contains('media')) {
						db.createObjectStore('media');
					}
					if (!db.objectStoreNames.contains('data')) {
						db.createObjectStore('data');
					}
				};
				request.onsuccess = () => resolve(request.result);
				request.onerror = () => reject(request.error);
			});
		}

		function cacheMedia(db, url, blob) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('media', 'readwrite');
				tx.objectStore('media').put(blob, url);
				tx.oncomplete = () => resolve();
				tx.onerror = () => reject(tx.error);
			});
		}

		function getCachedMedia(db, url) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('media', 'readonly');
				const req = tx.objectStore('media').get(url);
				req.onsuccess = () => resolve(req.result || null);
				req.onerror = () => reject(req.error);
			});
		}

		function cacheData(db, key, content) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('data', 'readwrite');
				tx.objectStore('data').put(content, key);
				tx.oncomplete = () => resolve();
				tx.onerror = () => reject(tx.error);
			});
		}

		function getCachedData(db, key) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('data', 'readonly');
				const req = tx.objectStore('data').get(key);
				req.onsuccess = () => resolve(req.result || null);
				req.onerror = () => reject(req.error);
			});
		}

		async function clearIndexedDB() {
			try {
				const db = await openIndexedDB();

				const tx = db.transaction(['media', 'data'], 'readwrite');
				const mediaStore = tx.objectStore('media');
				const dataStore = tx.objectStore('data');

				mediaStore.clear();
				dataStore.clear();

				return new Promise((resolve, reject) => {
					tx.oncomplete = () => {
						console.log('Media and data caches cleared.');
						resolve();
					};
					tx.onerror = () => {
						console.error('Error clearing IndexedDB caches:', tx.error);
						reject(tx.error);
					};
				});
			} catch (err) {
				console.error('Failed to open IndexedDB for clearing:', err);
			}
		}


		async function fetchMedia(url, offlineCache = true) {

			const db = await openIndexedDB();

			// Check RAM cache first
			if (mb.mediaCacheRAM.has(url)) {
				// Move the accessed item to the end to mark it as recently used
				const value = mb.mediaCacheRAM.get(url);
				mb.mediaCacheRAM.delete(url);
				mb.mediaCacheRAM.set(url, value);
				return value;
			}

			// Check in IndexedDB only if in offline session and cache it in RAM too
			if (offlineSession) {
				const cachedBlob = await getCachedMedia(db, url);
				if (cachedBlob) {
					const objectURL = URL.createObjectURL(cachedBlob);
					mb.mediaCacheRAM.set(url, objectURL);
					return objectURL;
				}
			}

			try {
				const response = await fetch(url, buildRequestMedia(mb.authToken, 'GET', null));

				if (response.ok) {
					const blob = await response.blob();
					const objectURL = URL.createObjectURL(blob);

					// Add to cache and enforce size limit
					mb.mediaCacheRAM.set(url, objectURL);
					if (mb.mediaCacheRAM.size > mb.cacheLimitRAM) {
						// Remove the oldest entry
						const oldestKey = mb.mediaCacheRAM.keys().next().value;
						URL.revokeObjectURL(mb.mediaCacheRAM.get(oldestKey)); // Revoke object URL
						mb.mediaCacheRAM.delete(oldestKey);
					}

					if (offlineCache) {
						await cacheMedia(db, url, blob);
					}

					return objectURL;
				} else {
					console.error(`Failed to load media from ${url}`, response.status);
					return 'fallback-image.png';
				}
			} catch (error) {
				console.warn(`Offline? Loading cached media for ${url}`);
				const fallbackBlob = await getCachedMedia(db, url);
				if (fallbackBlob) {
					return URL.createObjectURL(fallbackBlob);
				}
				return 'fallback-image.png';

			}
		}


		// Function to clear the cache entirely
		function clearmediaCacheRAM() {
			for (const objectURL of mb.mediaCacheRAM.values()) {
				URL.revokeObjectURL(objectURL);
			}
			mb.mediaCacheRAM.clear();
		}

		async function setReadStatus(seriesId, bookId, read, item, format) {
			if (bookId == null) {
				await callAPI(null, `/api/v1/series/${seriesId}/read-progress`, read ? 'POST' : 'DELETE', null, false);
				const seriesData = await callAPI(`c_seriesdata${seriesId}`, `/api/v1/series/${seriesId}`);
				if (item.dat_dynamic) {
					seriesItemProxy[seriesId] = await buildSeriesItem(item, seriesData, null, true);
					item.appendChild(seriesItemProxy[seriesId]);
				} else {
					buildSeriesItem(item, seriesData, null); //TODO Perché è NULL? check vecchie versioni
				}
				mb.currentlyScaled = item;
			} else {
				await callAPI(null, `/api/v1/books/${bookId}/read-progress`, read ? 'PATCH' : 'DELETE', read ? JSON.stringify({ completed: true }) : null, false);

				if (obIsBookCompleted(rd.bookId)) {
					mb.offlineBooks[bookId].page = mb.offlineBooks[bookId].pages;
					obSaveTable();
				}

				mb.currentlyScaled = item;

				const { path, params } = getHashAndParams();
				if (path == 'dashboard' || path == '') {
					mb.currentlyScaled = null;
					mb.clickingTile = null;
					const oldTop = mainContainer.scrollTop;
					await Promise.all(
						Object.entries(dashboardElements).map(async ([name, item]) => {
							const resultsObject = await item.getItems(0, 20);
							//TODO consolidate this with other places?
							item.element.style.display = resultsObject.empty ? 'none' : 'block';
							item.showItems(resultsObject.content, item.homeStrip);
						})
					);
					setTimeout(updateSliderProperties, 100);
					mainContainer.scrollTop = oldTop;
				} else {
					const bookData = await callAPI(null, `/api/v1/books/${bookId}`);
					buildBookItem(item, bookData, format, null);
				}
			}
		}

		async function setSeriesReadStatus(seriesId, read, item) {
			setReadStatus(seriesId, null, read, item, null);
		}

		async function setBookReadStatus(bookId, read, item, format) {
			setReadStatus(null, bookId, read, item, format);
		}

		async function updateSizer(libraries) {
			const gapSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-gap'));
			const libSmallSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-button-size'));
			const libLargeSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-large'));
			const filterButtonSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-filter-button-size'));
			const searchFieldSize = libLargeSize;
			const libMenuSize = 40;
			const margin = 10;

			const rightBlockButtons = librariesRightBlock.childElementCount - 1;
			document.documentElement.style.setProperty('--mb-num-buttons', rightBlockButtons - 1);

			const libNum = 3 + libraries.length;
			const mainLibAndMenu = margin + libLargeSize + libMenuSize;
			mb.libSizer.large = mainLibAndMenu + (libNum - 1) * (libLargeSize + gapSize);
			mb.libSizer.medium = mainLibAndMenu + (libNum - 3) * (libLargeSize + gapSize) + 2 * (libSmallSize + gapSize) - libMenuSize;
			mb.libSizer.small = mainLibAndMenu + (libNum - 1) * (libSmallSize + gapSize);
			mb.libSizer.rightmin = margin + rightBlockButtons * (libSmallSize + gapSize) + searchFieldSize + gapSize;

			mb.filterSizer = mb.filterButtons.length * (100 + gapSize) + filterButtonSize + 2 * margin;

		}

		// Function that fetches the libraries list, sort it by name, then calls displayLibraries to show the fetched libraries
		async function fetchLibraries() {

			const libraries = await callAPI('c_libraries', '/api/v1/libraries');
			libraries.sort((a, b) => a.name.localeCompare(b.name));

			await displayLibraries(libraries);

			await updateSizer(libraries)

			updateStickyMenu();
		}


		// This function is called when a library is selected, it manages the library menu and library naming in the URL
		function libraryHighlight(libraryId, withMenu) {
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('highlighted'));
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('with-menu'));
			document.getElementById(libraryId).classList.add('highlighted');
			if (withMenu) document.getElementById(libraryId).classList.add('with-menu');
		}

		async function getFilteredSeries(filterTitle, serieId) {
			//TODO Launch this fetch at session load to pre-cache all series
			const unFilteredSeries = await callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredItems = unFilteredSeries.content.filter(item =>
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title === filterTitle
				)
			);

			displaySeries(filteredItems, seriesGrid, null, false);
			focusItem('top');

		}

		//MB Touch And Hover Scaler 

		function addClickPointerEvents(item, execute) {
			item.addEventListener('pointerdown', () => {
				if (getComputedStyle(item).opacity == 0) return;
				mb.pointerItem = item
			});
			item.addEventListener('pointerup', (event) => {
				event.stopPropagation();

				if (mb.pointerItem != item) {
					mb.pointerItem = null;
					return;
				};

				execute();
			})
		}

		function addTouchScaler(item, execute) {
			item.addEventListener('pointerdown', async (event) => {
				mb.clickingTile = item;
			});

			item.addEventListener('pointerup', async (event) => {
				if (mb.clickingTile != item) {
					mb.clickingTile = null;
					return
				}

				if (event.pointerType === 'touch') {
					// TOUCH DEVICE
					if (mb.currentlyScaled !== item) {
						if (mb.currentlyScaled) {
							mb.currentlyScaled.classList.remove('scaled');
							mb.currentlyScaled.parentElement.classList.remove('top-pop');
						}
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');

						mb.currentlyScaled = item;

						event.preventDefault();
					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');
	
						mb.currentlyScaled = null;
						*/
						execute();
					}
				} else if (event.button == 0) {
					// MOUSE DEVICE
					if (!item.classList.contains('scaled')) {
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');
						mb.currentlyScaled = item;

					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');
						mb.currentlyScaled = null;
						*/
						execute();
					}
				}
			});

			item.addEventListener('mouseenter', () => {
				// Added this to unselect pre-scaled book
				if (mb.currentlyScaled != null) {
					mb.currentlyScaled.classList.remove('scaled');

					mb.currentlyScaled.parentElement.classList.remove('top-pop');

					// mb.currentlyScaled = null; //TODO RIMESSO IN 0.2.6 check, This was removed but maybe it was needed?
				}
				item.classList.add('scaled');
				item.parentElement.classList.add('top-pop');
			});

			item.addEventListener('mouseleave', () => {
				item.classList.remove('scaled');
				item.parentElement.classList.remove('top-pop');
				mb.clickingTile = null;
			});
		}

		function preventHyphenBreaks(str) {
			return str.replace(/-/g, '\u2011')
		}

		//MB Series Items Creation

		const attachedObserver = new IntersectionObserver(async (entries) => {
			for (const entry of entries) {

				if (entry.isIntersecting) {
					if (!seriesItemProxy[entry.target.id]) {
						seriesItemProxy[entry.target.id] = await buildSeriesItem(entry.target, entry.target.dat_serie, entry.target.dat_target, true)
					}

					entry.target.append(seriesItemProxy[entry.target.id])
					entry.target.classList.remove('unattached');
					let frameRect = seriesItemProxy[entry.target.id].getBoundingClientRect()
					entry.target.style.aspectRatio = frameRect.width / frameRect.height
				} else {
					if (mb.currentlyScaled?.parentElement?.id == entry.target.id) {
						mb.currentlyScaled.classList.remove('scaled');
						mb.currentlyScaled.parentElement.classList.remove('top-pop');
						mb.currentlyScaled = null;
					}
					const child = seriesItemProxy[entry.target.id];

					if (child && entry.target.contains(child)) {
						entry.target.removeChild(child);
					}
					entry.target.classList.add('unattached');
				}
			};
		}, {
			root: mainContainer,
			rootMargin: '500px 0px 500px 0px',
			threshold: 0
		});

		function buildSeriesData(item, serie) {
			const unreadCount = serie.booksUnreadCount;
			const altTitle = getAltTitles(serie);
			const bookCount = serie.booksCount;
			item.mbSeriesTitle = serie.metadata.title ?? '';
			item.mbSeriesStart = timeSplit(altTitle.time)[0];
			item.mbBooksCount = serie.booksCount;
			item.mbSeriesRead = (unreadCount == 0);
			item.mbSeriesDirection = (serie.metadata.readingDirection);
			item.mbSeriesLanguage = serie.metadata.language;
		}

		async function buildSeriesItem(item, serie, target, dynamic = false) {
			const LTRvals = {
				RIGHT_TO_LEFT: '',
				LEFT_TO_RIGHT: '<span class="fa-solid fa-clapperboard fa-rotate-270 glyph-dark" style="margin-left:2px;"></span>',
				WEBTOON: '<span class="fa-solid fa-mobile glyph-dark" style="margin-left:2px;"></span>',
				VERTICAL: '<span class="fa-solid fa-mobile glyph-dark" style="margin-left:2px;"></span>',
			}

			item.childNodes[0]?.remove();

			item.title = 'Open series';

			const seriesItem = addItem('div', {
				className: 'series-item'
			});
			const LNG = serie.metadata?.language ? ((serie.metadata.language != 'en') ? `<span style="background-image:url('flags/${serie.metadata.language}.svg')" class="fa-solid fa-square-full glyph-dark glyph-flag"></span>` : '') : '';
			const LTR = serie.metadata?.readingDirection ? LTRvals[serie.metadata.readingDirection] : '';
			const spacer = ((LNG != '') && (LTR != '')) ? '&nbsp;' : '';

			const seriesTitle = addItem('div', {
				innerHTML: `
								<div class="title-row data-row top-row">
									<div style="flex-grow:1" class="series-title">${preventHyphenBreaks(serie.metadata.title)}</div>
									<div class="glyph-dark" style="text-align:right">${LTR}</div>
										${spacer}
									<div class="glyph-div" style="text-align:right">${LNG}</div>
								</div>`
			});

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper'
			});

			const seriesThumbnail = addItem('img', {
				className: 'series-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail`,
				alt: serie.metadata.title
			});

			addLazyLoading(seriesThumbnail);

			const seriesFader = addItem('div', {
				className: 'series-fader'
			});

			const seriesOverlay = addItem('div', {
				className: 'series-overlay'
			});

			const seriesStatus = addItem('div', {
				className: 'series-status'
			});

			const unreadCount = serie.booksUnreadCount;

			if (unreadCount > 0) {
				const unreadCountBadge = addItem('div', {
					className: 'unread-count',
					innerHTML: `<span>${unreadCount}</span>`
				});
				seriesStatus.append(unreadCountBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark series as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			addClickPointerEvents(markAsRead, async () => {
				await setSeriesReadStatus(serie.id, true, item);
			})
			addPressEvents(markAsRead, scaleDown, scaleUp)

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark series as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			addClickPointerEvents(markAsUnread, async () => {
				await setSeriesReadStatus(serie.id, false, item);
			})
			addPressEvents(markAsUnread, scaleDown, scaleUp)

			// Find alternate title with label 'Time'
			const altTitle = getAltTitles(serie);

			// Fetch and display the number of books and alternate title
			const bookCount = serie.booksCount;

			const infoRow = addItem('div', {
				className: 'data-row info-row'
			});

			const timeLabel = addItem('span', {
				innerHTML: altTitle.time == "N/A" ? '' : `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-calendar glyph-dark'></span>&nbsp;${altTitle.time}`,
				className: 'red search-trigger',
				title: `Filter time: ${altTitle.time}`
			});

			addClickPointerEvents(timeLabel, async () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#search?search_string=y:${altTitle.time}`);
			})

			const booksLabel = addItem('span', {
				innerHTML: `<span class='fa-solid fa-book glyph-dark'></span>&nbsp;${bookCount}`
			});

			const artistRow = addItem('div', {
				className: 'data-row artist-row'
			});

			if (altTitle.story != altTitle.art) {
				if (altTitle.story != 'N/A') {
					const storyLabel = addItem('div', {
						innerHTML: `<span class='fa-solid fa-pen-to-square glyph-dark'></span>&nbsp;${altTitle.story}`,
						className: 'red data-label search-trigger',
						title: `Filter artist: ${altTitle.story}`
					});

					artistRow.append(storyLabel);

					addClickPointerEvents(storyLabel, async () => {
						if (target?.binName) mb.dashboardBin = target.binName;
						navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
					});
				}

				if (altTitle.art != 'N/A') {
					const artLabel = altTitle.art == 'N/A' ? '' : addItem('div', {
						innerHTML: `<span class='fa-solid fa-palette glyph-dark'></span>&nbsp;${altTitle.art}`,
						className: 'red data-label search-trigger',
						title: `Filter artist: ${altTitle.art}`
					});

					artistRow.append(artLabel);

					addClickPointerEvents(artLabel, async () => {
						if (target?.binName) mb.dashboardBin = target.binName;
						navigateTo(`#search?search_string=${altTitle.art.toLowerCase()}`);
					});
				}



			} else {
				if (altTitle.story != 'N/A') {
					const artistLabel = addItem('div', {
						innerHTML: `<span class='fa-solid fa-user glyph-dark'></span>&nbsp;${altTitle.story}`,
						title: `Filter artist: ${altTitle.story}`,
						className: 'red data-label search-trigger'
					});
					artistRow.append(artistLabel);

					addClickPointerEvents(artistLabel, async () => {
						if (target?.binName) mb.dashboardBin = target.binName;
						navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
					});
				}
			}

			item.mbSeriesTitle = serie.metadata.title ?? '';

			item.mbSeriesStart = timeSplit(altTitle.time)[0];
			item.mbSeriesStop = timeSplit(altTitle.time)[1];

			item.mbBooksCount = serie.booksCount;

			item.mbSeriesRead = (unreadCount == 0);
			//TODO This is for filtering purposes, to fix
			item.mbSeriesDirection = (serie.metadata.readingDirection);
			item.mbSeriesLanguage = serie.metadata.language;

			seriesItem.append(
				thumbnailWrapper,
				seriesTitle,
				infoRow,
				artistRow
			);
			thumbnailWrapper.append(
				seriesThumbnail,
				seriesFader,
				seriesOverlay,
				seriesStatus
			);
			seriesOverlay.append(
				markAsRead,
				markAsUnread
			);
			infoRow.append(
				timeLabel,
				booksLabel
			);

			seriesItem.classList.add('touch-scaler')

			addTouchScaler(seriesItem, () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#series?library_id=${serie.libraryId}&series_id=${serie.id}`)
			});

			if (dynamic) {
				return (seriesItem)
			} else {
				item.append(seriesItem)
			}
		}

		async function buildCollectionsItem(item, serie, target) {
			buildContainerItem(item, serie, target, 'collections', 'seriesIds', 'fa-layer-group')
		}

		async function buildReadlistsItem(item, serie, target) {
			buildContainerItem(item, serie, target, 'readlists', 'bookIds', 'fa-book')
		}

		async function buildContainerItem(item, serie, target, container, items, icon) {

			const dateString = serie.lastModifiedDate ?
				new Intl.DateTimeFormat('en-GB', {
					day: '2-digit',
					month: 'short',
					year: '2-digit'
				}).format(new Date(serie.lastModifiedDate))
				: '';

			item.childNodes[0]?.remove();

			item.title = 'Open Container';

			const seriesItem = addItem('div', {
				className: 'series-item'
			});

			const seriesTitle = addItem('div', {
				innerHTML: `
								<div class="title-row data-row top-row">
									<div style="flex-grow:1" class="series-title">${preventHyphenBreaks(serie.name)}</div>
								</div>`
			});

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper'
			});

			const seriesThumbnail = addItem('img', {
				className: 'series-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mb.baseUrl}/api/v1/${container}/${serie.id}/thumbnail`,
				alt: serie.name
			});

			addLazyLoading(seriesThumbnail);

			const seriesFader = addItem('div', {
				className: 'series-fader'
			});

			const seriesOverlay = addItem('div', {
				className: 'series-overlay'
			});


			const timeLabel = addItem('span', {
				innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-clock glyph-dark'></span>&nbsp;${dateString}`
			});

			// Fetch and display the number of books and alternate title
			const bookCount = serie[items].length;

			const infoRow = addItem('div', {
				className: 'data-row info-row'
			});

			const booksLabel = addItem('span', {
				innerHTML: `<span class='fa-solid ${icon} glyph-dark'></span>&nbsp;${bookCount}`
			});

			item.mbSeriesTitle = serie.name ?? '';

			item.mbBooksCount = serie[items].length;

			seriesItem.append(
				thumbnailWrapper,
				seriesTitle,
				infoRow,
			);
			thumbnailWrapper.append(
				seriesThumbnail,
				seriesFader,
				seriesOverlay,
			);

			infoRow.append(
				timeLabel,
				booksLabel
			);

			seriesItem.classList.add('touch-scaler')

			addTouchScaler(seriesItem, () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#${container}item?item_id=${serie.id}`)
			});

			item.append(seriesItem)

		}

		// Creates and populates the series grid with the data from the series array.
		async function displaySeriesOLD(series, target) {

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {

				const seriesContainer = addItem('div', {
					className: 'series-container collector', //XXX was ending with , 'fade-in');
					id: serie.id,
				});

				buildSeriesItem(seriesContainer, serie, target);

				target.append(seriesContainer);
			});

			sectionShow(target); //XXX serve un fade qui???
		}


		let chunkIndex = 0;
		let seriesOld = null;
		let seriesContainerProxy = [];
		let seriesItemProxy = {};
		const BATCH = 100;


		function renderSeriesChunk(series, target, focusId) {
			if (series != seriesOld) {
				return;
			}

			const slice = seriesContainerProxy.slice(chunkIndex, chunkIndex + BATCH);
			chunkIndex += BATCH;

			const frag = document.createDocumentFragment();


			for (const serieContainer of slice) {
				attachedObserver.observe(serieContainer)
				if (serieContainer.infilter) frag.appendChild(serieContainer);
			}

			target.appendChild(frag);

			if (chunkIndex < seriesContainerProxy.length) {
				requestAnimationFrame(() => { renderSeriesChunk(series, target, focusId) });
				//renderSeriesChunk(series, target, focusId);
			} else {
				sectionShow(target);
				//TODO Da qualche parte andava il jump to top?
				focusItem(focusId ? focusId : 'top')
				//if (focusId) focusItem(focusId);
			}
		}

		// Creates and populates the series grid with the data from the series array.
		async function displaySeries(series, target, focusId, dynamic) {

			if (dynamic) {
				seriesContainerProxy = []
				seriesItemProxy = {};

				for (const serie of series) {
					const seriesContainer = addItem('div', {
						className: 'series-container collector unattached',
						id: serie.id,
					});
					seriesContainer.dat_serie = serie;
					seriesContainer.dat_target = target;
					seriesContainer.dat_dynamic = dynamic;
					buildSeriesData(seriesContainer, serie);

					//seriesItemProxy[serie.id] = await (buildSeriesItem(seriesContainer, serie, target, dynamic));
					seriesContainerProxy.push(seriesContainer);

				}

				chunkIndex = 0;

				while (target.firstChild) {
					target.removeChild(target.firstChild);
				}

				// If dynamic is not null we are loading a series in series grid, which means we can
				// apply the filters for that library. "dynamic" is either null or the libraryId
				if (dynamic) {
					fetchLibraryFilters(dynamic)
				}

				seriesOld = series;

				renderSeriesChunk(series, target, focusId);

			} else {
				// TODO Ripulire questa parte che in parte viene da sopra
				while (target.firstChild) {
					target.removeChild(target.firstChild);
				}

				series.forEach(async (serie) => {
					const seriesContainer = addItem('div', {
						className: 'series-container collector', //XXX was ending with , 'fade-in');
						id: serie.id,
					});

					buildSeriesItem(seriesContainer, serie, target);

					target.append(seriesContainer);

				});

				sectionShow(target);
			}
		}

		async function displayReadlists(series, target) {

			// TODO Ripulire questa parte che in parte viene da sopra
			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {
				const seriesContainer = addItem('div', {
					className: 'series-container collector', //XXX was ending with , 'fade-in');
					id: serie.id,
				});

				buildReadlistsItem(seriesContainer, serie, target);

				target.append(seriesContainer);

			});
			sectionShow(target);
		}

		async function displayCollections(series, target) {

			// TODO Ripulire questa parte che in parte viene da sopra
			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {
				const seriesContainer = addItem('div', {
					className: 'series-container collector', //XXX was ending with , 'fade-in');
					id: serie.id,
				});

				buildCollectionsItem(seriesContainer, serie, target);

				target.append(seriesContainer);

			});
			sectionShow(target);
		}

		// Function that fetches all the series list within a library, sorted by name, then calls displaySeries to show the fetched series
		async function fetchAllSeries(libraryId) {
			let allSeries = [];
			const allSeriesPage = await callAPI(`c_serieslist${libraryId}`,
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"libraryId": {"operator": "is","value": "${libraryId}"}}}`
			);
			allSeries = allSeriesPage?.content || [];
			// now it gets the series sorted by name so no need to elaborate the sorting, but for custom sorting based for example on title time?
			// allSeries.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
			return (allSeries);
		}

		function focusItem(focus) {
			if (focus == 'top') {
				mainContainer.scrollTo({ top: 0 });
			} else if (focus) {
				var item = document.getElementById(focus);

				if (item == null) {
					mainContainer.scrollTo({ top: 0 });
					return;
				}

				const yOffset = -150;
				const y = item.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop + yOffset;

				mainContainer.scrollTo({ top: y });

				mb.currentlyScaled = item.firstChild;

				if (item.firstChild != null) {
					item.firstChild.classList.add('scaled');
				}
				item.classList.add('top-pop');
			}
		}

		// Compose function that opens a specific library based on it ID
		async function openLibrary(libraryId, seriesId) {
			await libraryHighlight(libraryId, true);		// Triggers and manages the library menu
			const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library
			//fetchLibraryFilters(libraryId);
			await displaySeries(allSeries, seriesGrid, seriesId, libraryId);
			//focusItem(seriesId || 'top');
			//TODO Move here the logic that enables the library options buttons?
		}

		async function openReadlists() {
			libraryHighlight('readlistsButton', false);		// Triggers and manages the library menu
			//libraryHighlight('readlistsButton2', false);		// Triggers and manages the library menu
			//const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library

			//await displaySeries(allSeries, seriesGrid, seriesId, libraryId);
			const readlistsPage = await callAPI(`c_readlists`,
				`/api/v1/readlists?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'GET'
			);
			readlists = readlistsPage?.content || [];
			displayReadlists(readlists, seriesGrid);
		}

		async function openCollections() {
			libraryHighlight('collectionsButton', false);		// Triggers and manages the library menu
			//libraryHighlight('collectionsButton2', false);		// Triggers and manages the library menu
			//const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library

			//await displaySeries(allSeries, seriesGrid, seriesId, libraryId);
			const collectionsPage = await callAPI(`c_collections`,
				`/api/v1/collections?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'GET'
			);
			collections = collectionsPage?.content || [];
			displayCollections(collections, seriesGrid);
		}

		const menuClassUp = 'fa-caret-up';
		const menuClassDown = 'fa-caret-down'

		function libMenuClear(item) {
			item.classList.remove(menuClassUp);
			item.classList.remove(menuClassDown);
		}

		function libMenuDown(item) {
			libMenuClear(item);
			item.classList.add(menuClassDown);
		}

		function libMenuUp(item) {
			libMenuClear(item);
			item.classList.add(menuClassUp);
		}

		function clearLibrariesMenus() {
			Object.entries(mb.libraryMenuButtons).forEach(([name, item]) => {
				libMenuClear(item);
				libMenuDown(item);
			});
		}

		function pressDown(item) {
			const anim = item.animate(
				{
					transform: 'scale(0.975) translateY(1px)',
					filter: 'brightness(0.98)',
					boxShadow: 'var(--mb-button-press)'
				},
				{ duration: 150, fill: 'forwards', easing: 'ease-out' }
			);
			item._pressAnim = anim; // save reference
			return anim.finished;
		}

		function pressUp(item) {
			const finish = item._pressAnim?.finished || Promise.resolve();
			finish.then(() => {
				item.animate(
					{
						transform: 'scale(1) translateY(0px)',
						filter: 'brightness(1)',
						boxShadow: 'var(--mb-button-unpress)'
					},
					{ duration: 50, fill: 'forwards', easing: 'ease-in' }
				);
			});
		}
		function scaleDownShallow(item) {
			const anim = item.animate({ transform: 'scale(0.95)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleDown(item) {
			const anim = item.animate({ transform: 'scale(0.9)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleDownDeep(item) {
			const anim = item.animate({ transform: 'scale(0.8)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleUp(item) {
			const finish = item._pressAnim?.finished || Promise.resolve();
			finish.then(() => {
				item.animate({ transform: 'scale(1.0)' }, { duration: 50, fill: 'forwards', easing: 'ease-in' }
				);
			});
		}

		function addPressEvents(item, downFunction, upFunction) {
			item.addEventListener('pointerdown', (event) => {
				event.stopPropagation();
				downFunction(item);
			});
			item.addEventListener('pointerup', () => {
				upFunction(item);
			});
			item.addEventListener('pointerleave', () => {
				upFunction(item);
			});
			item.addEventListener('pointercancel', () => {
				upFunction(item);
			});
		};


		function buildLibraryItem(itemId, libraryName, imagePath = null) {
			const isLib = (imagePath == null);
			const isFA = imagePath?.startsWith("fa-");

			const listItem = addItem('li', {
				id: itemId,
				className: 'library-item press-button',
				title: libraryName,
			});

			addPressEvents(listItem, pressDown, pressUp);

			const thumbnailWrapper = addItem('div', {
				className: 'button-wrapper',
			})

			const base64Image = mb.libraryIcons[itemId];
			const imageSrc = base64Image || (isLib
				? `library-thumbnails/${libraryName}.svg`
				: imagePath);


			const libraryThumbnail = isFA ?
				addItem('i', {
					className: `fa-solid ${imagePath} glyph-dark libglyph`,
				}) :
				addItem('img', {
					className: 'library-thumbnail',
					src: imageSrc,
					alt: isLib ? `${libraryName} Cover` : libraryName,
				})

			if (isLib && !isFA) {
				libraryThumbnail.onerror = () => {
					libraryThumbnail.onerror = null;
					libraryThumbnail.src = `library-letters/${transliterate(libraryName.charAt(0)).charAt(0).toUpperCase()}.png`
					libraryThumbnail.onerror = () => {
						libraryThumbnail.onerror = null;
						libraryThumbnail.src = 'library-letters/blank.png'; // your fallback image
					};
				};
			}

			const libraryNameDiv = addItem('div', {
				className: 'library-name',
				textContent: libraryName
			});

			thumbnailWrapper.append(libraryThumbnail);
			listItem.append(thumbnailWrapper, libraryNameDiv);

			if (isLib) {
				mb.libraryMenuButtons[itemId] = addItem('span', {
					className: 'fa-solid ' + menuClassDown + ' is-lib-menu'
				})

				const thumbnailWrapperMenu = addItem('div', {
					className: 'button-wrapper library-menu-button press-flat-button',
				})

				thumbnailWrapperMenu.append(mb.libraryMenuButtons[itemId]);
				listItem.append(thumbnailWrapperMenu);

				addPressEvents(thumbnailWrapperMenu, scaleDownDeep, scaleUp)

				thumbnailWrapperMenu.addEventListener('click', (event) => {
					libMenuClear(mb.libraryMenuButtons[itemId]);

					const unrollTimeout = isSectionHidden(colorSwatchBar) ? 0 : 200

					if (isSectionHidden(filtersBar)) {
						libMenuUp(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = itemId;
						mb.swatchMenuVisible = false;
						sectionHide(colorSwatchBar);
					} else {
						libMenuDown(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = null;
					}

					event.stopPropagation();
					event.preventDefault();
					setTimeout(() => {
						sectionToggle(filtersBar);
					}, unrollTimeout);
				});

			}

			return listItem;
		}

		function readFileAsBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file); // This gives you "data:image/png;base64,..." format
			});
		}

		function addLongPressListener(element, callback, duration = 1200) {
			let pressTimer;
			let wasLongPress = false;

			const start = (e) => {
				if (e.target.classList.contains('is-lib-menu')) return;
				wasLongPress = false;
				pressTimer = setTimeout(() => {
					wasLongPress = true;
					callback(e);
				}, duration);
			};

			const cancel = () => {
				clearTimeout(pressTimer);
			};

			element.addEventListener('mousedown', start);
			element.addEventListener('mouseup', cancel);
			element.addEventListener('mouseleave', cancel);
			element.addEventListener('dragstart', cancel);

			element.addEventListener('touchstart', start);
			element.addEventListener('touchend', cancel);
			element.addEventListener('touchcancel', cancel);

			// Prevent click after long press
			element.addEventListener('click', (e) => {
				if (wasLongPress) {
					e.preventDefault();
					e.stopImmediatePropagation();
					// Optionally log or debug here
				}
			}, true); // Capture phase to stop early
		}

		function cancelUpdate() {
			closeModal();
			bootSequence(offlineSession ? 'offline' : 'online');
		}

		async function applyLibraryImage(libraryId, fileOrBase64) {
			let base64 = null;

			// Case 1: It's a File
			if (fileOrBase64 instanceof File) {
				debugPrint("----Input is a file")
				if (!fileOrBase64.type.startsWith('image/')) {
					debugPrint("----But it's not a valid image file")
					showModal('circle-mark-svg.svg', true, 'Please provide a valid image.',
						[{ label: 'Ok', runfunction: cancelUpdate, high: true }]);
					return;
				}
				base64 = await readFileAsBase64(fileOrBase64);
			}

			// Case 2: It's already a base64 string
			else if (typeof fileOrBase64 === 'string' && fileOrBase64.startsWith('data:image/')) {
				debugPrint("----Input is a string")
				base64 = fileOrBase64;
			}

			// Case 3: Not valid
			else {
				debugPrint("----Input is not valid")
				debugPrint(fileOrBase64);
				showModal('circle-mark-svg.svg', true, 'Please provide a valid image.',
					[{ label: 'Ok', runfunction: cancelUpdate, high: true }]);
				return;
			}

			// Show confirmation modal
			showModal(base64, false, 'Set this image as library thumbnail?',
				[{
					label: 'Ok',
					runfunction: async () => {
						mb.libraryIcons[libraryId] = base64;
						await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons));
						closeModal();
						bootSequence(offlineSession ? 'offline' : 'online');
					},
					high: true,
				}, {
					label: 'Cancel', runfunction: cancelUpdate, high: false
				}
				]);
		}


		async function pickImage(libraryId) {
			debugPrint("PickImage");
			try {
				const image = await Capacitor.Plugins.Camera.getPhoto({
					quality: 90,
					allowEditing: false,
					resultType: 'base64',  // get base64 directly
					source: 'PHOTOS',
				});

				const base64 = `data:image/${image.format};base64,${image.base64String}`;
				applyLibraryImage(libraryId, base64);

			} catch (err) {
				debugPrint("Image picking failed:\n" + err);
			}
		}

		async function pickFile(libraryId) {
			debugPrint("PickFile");
			try {
				const result = await Capacitor.Plugins.FilePicker.pickFiles({
					extensions: ['png', 'jpg', 'jpeg', 'heic'], // common formats on iOS
					multiple: false,
					readData: true,
				});
				if (result.files.length > 0) {
					const file = result.files[0];

					if (file.data) {
						// Pass as base64 string (Case 2 of your function)
						const base64 = `data:${file.mimeType};base64,${file.data}`;
						applyLibraryImage(libraryId, base64);
					} else if (file.path) {
						// As a fallback: fetch from file system and build a File
						const response = await fetch(file.path);
						const blob = await response.blob();
						const pseudoFile = new File([blob], file.name, { type: file.mimeType });
						applyLibraryImage(libraryId, pseudoFile);
					}
				}

			} catch (err) {
				debugPrint("Image picking failed:\n" + err);
			}
		}

		function displayLibraries(libraries) {
			librariesList.innerHTML = '';

			let dashboard = buildLibraryItem('homeButton', 'Dashboard', 'logo/mangabox-logo-new.svg')
			dashboard.classList.add('shrink-first');
			librariesList.append(dashboard);
			homeButton.addEventListener('click', () => {
				navigateTo('#dashboard');
			});

			let readlists = buildLibraryItem('readlistsButton', 'Read Lists', 'library-symbols/readlists3d.png')
			readlists.classList.add('shrink-first');
			librariesList.append(readlists);
			readlistsButton.addEventListener('click', () => {
				navigateTo('#readlists');
			});

			let readlistsAPI = callAPI(`c_readlists`,
				`/api/v1/readlists?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'GET'
			).then((res) => {
				if (res.content.length == 0) readlistsButton.style.display = 'none';
			});

			let collections = buildLibraryItem('collectionsButton', 'Collections', 'library-symbols/collections3d.png')
			collections.classList.add('shrink-first');
			librariesList.append(collections);
			collectionsButton.addEventListener('click', () => {
				navigateTo('#collections');
			});

			let collectionsAPI = callAPI(`c_collections`,
				`/api/v1/collections?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'GET'
			).then((res) => {
				if (res.content.length == 0) collectionsButton.style.display = 'none';
			});

			Array.from(libraries).forEach((library, index) => {
				const listItem = buildLibraryItem(library.id, library.name);

				addLongPressListener(listItem, async () => {

					const libraryId = listItem.id
					if (mb.libraryIcons[libraryId] == null) {
						if (isCapacitor) {
							showModal('', true, generatePics(libraryId, "Select a thumbnail or open an image"),
								[{
									label: 'Gallery',
									runfunction: async () => { await pickImage(libraryId); },
									high: true
								}, {
									label: 'Files',
									runfunction: async () => { await pickFile(libraryId); },
									high: true
								}, {
									label: 'Cancel',
									runfunction: closeModal,
									high: false
								}]);

						} else {
							showModal('', false, generatePics(libraryId, "Select a thumbnail or drag an image over the library button"), [{ label: 'Ok', runfunction: () => closeModal(), high: true }]);
						}
					} else {
						showModal(mb.libraryIcons[libraryId], false, 'Remove custom library thumbnail?', [
							{
								label: 'Ok',
								runfunction: async () => {
									await delete mb.libraryIcons[libraryId];
									await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons))

									closeModal();
									bootSequence(offlineSession ? 'offline' : 'online');
								},
								high: true
							},
							{ label: 'Cancel', runfunction: cancelUpdate, high: false }
						]);

					}
				});

				listItem.addEventListener('dragover', (event) => {
					event.preventDefault(); // This is required to allow drop
					listItem.style.backgroundColor = 'hsl(200, 60%, 70%)';
				});

				listItem.addEventListener('dragleave', () => {
					listItem.style.backgroundColor = ''; // Reset visual feedback
				});

				listItem.addEventListener('drop', async (event) => {
					event.preventDefault();

					const libraryId = listItem.id
					const file = event.dataTransfer.files[0];

					applyLibraryImage(libraryId, file);

				})

				listItem.addEventListener('click', () => {
					const { path, params } = getHashAndParams();
					if ((path == 'series') && (params.get('library_id') == library.id)) {
						navigateTo(`#library?library_id=${library.id}&series_id=${params.get('series_id')}`);
					}
					else {
						navigateTo(`#library?library_id=${library.id}`);
					}
				});

				librariesList.append(listItem);
			});


		}

		function getAltTitles(serie) {

			const labels = ['Time', 'Story', 'Art'];
			const altTitle = labels.reduce((out, label) => {
				const altTitle = serie.metadata.alternateTitles.find(
					(alt) => alt.label === label
				);
				out[label.toLowerCase()] = altTitle ? altTitle.title : 'N/A';
				return out;
			}, {});

			if ((altTitle.time == 'N/A') && (serie.booksMetadata.releaseDate != null)) {
				altTitle.time = serie.booksMetadata.releaseDate.split('-')[0];
			};

			if (altTitle.story == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'writer'
				);
				altTitle.story = bookWriter ? bookWriter.name : 'N/A';
			}
			if (altTitle.art == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'penciller'
				);
				altTitle.art = bookWriter ? bookWriter.name : 'N/A';
			}
			return altTitle;

		}


		async function displayHeader(serie, isReadlist) {
			const altTitle = isReadlist ? null : getAltTitles(serie);

			const title = isReadlist ? serie.name : serie.metadata.title;
			const books = isReadlist ? serie.bookIds.length : serie.booksCount;
			const summaryData = isReadlist ? serie.summary : serie.metadata.summary;

			const summary = (isReadlist ?
				summaryData :
				(serie.metadata.summary != "")
					? serie.metadata.summary.replace(/\n/g, '<br>')
					: (serie.booksMetadata.summary != ""
						? "<u>Summary from book " + serie.booksMetadata.summaryNumber + "</u><br>" + serie.booksMetadata.summary.replace(/\n/g, '<br>')
						: ""
					)
			)

			let creditString;

			if (isReadlist || ((altTitle.story == 'N/A') && (altTitle.art == 'N/A')) || altTitle == null) {
				creditString = ''
			} else if (altTitle.story == 'N/A') {
				creditString = ` - Art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.art.toLowerCase()}');">${altTitle.art}</a>`
			} else if (altTitle.art == 'N/A') {
				creditString = ` - Story by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>`
			} else if (altTitle.story == altTitle.art) {
				creditString = ` - Story and art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>`
			} else {
				creditString = ` - Story by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>, art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.art.toLowerCase()}');">${altTitle.art}</a>`
			}

			const timeString =
				altTitle?.time && altTitle.time !== 'N/A'
					? altTitle.time
					: '';

			const thumbURL = isReadlist ? `${mb.baseUrl}/api/v1/readlists/${serie.id}/thumbnail` : `${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail`
			seriesHeader.innerHTML = `
			<div class="header-pic-container">
				<div class="thumbnail-wrapper">
					<img id="seriesHeaderThumbnail" src="${thumbURL}" class="header-pic">
				</div>
			</div>
			<div class="header-title">
				<span class="title">
				${title}
				${serie.metadata?.language ? `<img width="20px" height="20px" style="margin-left:15px; margin-top:2px; vertical-align: top;" src="flags/${serie.metadata.language}.svg">` : ''}
				</span>
				<span class="notes">
				${timeString != '' ? `<a class="red search-trigger" href="javascript:navigateTo('#search?search_string=y:${timeString}');">${timeString}</a>` : ''} (${books} ${books == 1 ? "book" : "books"}) ${isReadlist ? '' : creditString}</span>
			</div>
			<div id="bookScrollBox" class="header-summary scrollbox" data-scroll-direction="vertical">
				<div class="scrollbox-content">${summary}</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			`;

			seriesHeaderThumbnail.src = await fetchMedia(seriesHeaderThumbnail.src);
			createCustomScrollbar(bookScrollBox);
			seriesMiniHeader.innerHTML = `
				<span class="mini-title">${title}</span>
			`
		}

		//MB Book Details Panel 

		function closeBookDetails() {
			sectionHide(bookDetailsContainer);
			//TODO PUT THIS BACK?
			/*
			setTimeout(() => {
				bookDetailsContainer.innerHTML = ''
			}, 300);
			*/
		}

		function jumpBookDetailsPrev() {
			if (mb.prevBook != null) {
				showBookDetails(mb.prevBook);
			}
		}
		function jumpBookDetailsNext() {
			if (mb.nextBook != null) {
				showBookDetails(mb.nextBook);
			}
		}
		function jumpBookLibrary() {
			navigateTo(`#series?library_id=${mb.currentBook.libraryId}&series_id=${mb.currentBook.seriesId}&book_id=${mb.currentBook.id}`)
		}

		async function showBookDetails(book) {
			bookDetailCover.className = "book-thumbnail hidden";
			bookDetailsTitle.style.opacity = 0;
			bookDetailsSummary.style.opacity = 0;

			removeLazyLoading(bookDetailCover);
			sectionShow(bookDetailsContainer);

			bookDetailCover.lazySrc = `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`;
			addLazyLoading(bookDetailCover);

			bookDetailsTitle.innerText = book.metadata.title;
			bookDetailsTitle.style.opacity = 1;

			let summaryArray = book.metadata.summary.split(/\r?\n/);
			bookDetailsSummary.innerHTML = summaryArray.map(element => `<li>${element}</li>`).join('');
			bookDetailsSummary.style.opacity = 1;

			const seriesData = await callAPI(`c_seriesdata${book.seriesId}`, `/api/v1/series/${book.seriesId}`);

			mb.seriesData = seriesData;
			mb.currentBook = book;
			mb.prevBook = await callAPI(`c_books${book.id}prev`, `/api/v1/books/${book.id}/previous`) || null;
			mb.nextBook = await callAPI(`c_books${book.id}next`, `/api/v1/books/${book.id}/next`) || null;

		}

		//MB Book Item Creation

		async function buildBookItem(item, book, format, target) {

			// Check local proxy list if book is available and completed offline
			// and tell the system to use this offline copy if we are offline

			const bookIsOffline = obIsBookCompleted(book.id);
			const bookIsDownloading = obIsBookDownloading(book.id);

			const useOfflineCopy = (offlineSession && bookIsOffline);
			let offline = {};

			if (useOfflineCopy) {
				//TODO Alternative way: when read status change, and the book 
				// is offline, update the saved metadata so it will always be in sync
				// but will this sync with the reading offline? No

				// Load saved metadata, the function also apply the new page position
				offline = await obLoadOfflineBook(book.id);
				// Apply saved metadata to book
				book = offline.bookMetadata;
				// Pipe read progress into saved metadata
				//book.readProgress.page = mb.offlineBooks[book.id].page;
			}

			item.childNodes[0]?.remove();

			item.title = 'Read book';

			const booksItem = addItem('div', {
				className: 'book-item'
			});

			const bookDownloadUI = addItem('div', {
				className: 'book-downloader',
				//innerText: '100%'
			});

			if (bookIsOffline) {
				bookDownloadUI.innerText = '100%';
				bookDownloadUI.classList.add('done');
			}

			if (bookIsDownloading) {
				bookDownloadUI.style.bottom = mb.offlineBooks[book.id].percent + "%";
				bookDownloadUI.innerText = mb.offlineBooks[book.id].percent + "%";
			}

			const mainRow = addItem('div', {
				className: 'data-row top-row'
			});

			if (format == 'longname') {
				mainRow.classList.add('book-row');
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Book ${book.metadata.number}`,
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				mainRow.append(volumeNumberLabel, pagesLabel);
			} else {
				mainRow.classList.add('book-series-row', 'red');
				mainRow.title = `Open series: ${book.seriesTitle}`;
				mainRow.textContent = book.seriesTitle;
				addClickPointerEvents(mainRow, () => {
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}`);
				})
			}

			const secondRow = addItem('div', {
				className: 'data-row',
			});

			if (format == 'longname') {
				secondRow.classList.add('info-row');
				secondRow.textContent = book.metadata.title;
			} else if ((format == 'compact') || (format == 'full')) {
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Book ${book.metadata.number}`
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				secondRow.append(volumeNumberLabel, pagesLabel);
			} else if (format == 'timeline') {
				const dateString = book.readProgress ?
					new Intl.DateTimeFormat('en-GB', {
						day: '2-digit',
						month: 'short',
						year: '2-digit'
					}).format(new Date(book.readProgress.readDate))
					: '';

				const volumeNumberLabelShort = addItem('span', {
					innerHTML: `Bk.${book.metadata.number}`
				});
				const timeLabel = addItem('span', {
					innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-clock glyph-dark'></span>&nbsp;${dateString}`
				});

				secondRow.append(volumeNumberLabelShort, timeLabel);
			}

			let thirdRow = null
			if (format == 'full') {
				thirdRow = addItem('div', {
					className: 'data-row',
				});
				thirdRow.classList.add('info-row');
				thirdRow.textContent = book.metadata.title;
			}

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper',
			});

			if (useOfflineCopy) debugPrint(`${offline.bookPath}/thumbnail.jpg`)

			const bookThumbnail = addItem('img', {
				className: 'book-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: useOfflineCopy ? `${offline.bookPath}/thumbnail.jpg` : `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`,
				alt: book.metadata.title
			});

			addLazyLoading(bookThumbnail);

			const bookFader = addItem('div', { className: 'book-fader' });
			const bookOverlay = addItem('div', { className: 'book-overlay' });
			const bookStatus = addItem('div', { className: 'book-status' });

			const unread = (book.readProgress == null);

			if (unread) {
				const unreadBookBadge = addItem('div', {
					className: 'unread-book'
				});
				bookStatus.append(unreadBookBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark book as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			addClickPointerEvents(markAsRead, () => {
				setBookReadStatus(book.id, true, item, format);
			})

			addPressEvents(markAsRead, scaleDown, scaleUp)

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark book as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			addClickPointerEvents(markAsUnread, () => {
				setBookReadStatus(book.id, false, item, format);
			})
			addPressEvents(markAsUnread, scaleDown, scaleUp)



			//TODO Verificare cosa succede se il titolo di book details è troppo lungo e sposta l'immagine thumb

			//if (book.metadata.summary != '') {
			const bookDetails = addItem('div', {
				className: 'mini-buttons book-details',
				title: 'Book Details',
				innerHTML: `<span class="fa-solid fa-align-justify"></span>`
			});

			addClickPointerEvents(bookDetails, () => {
				showBookDetails(book);
			})
			addPressEvents(bookDetails, scaleDown, scaleUp)
			//	bookOverlay.append(bookDetails);
			//}

			if (book.metadata.summary == '') {
				bookDetails.classList.add('half-bright')
			};

			if (isElectron || isCapacitor || fullDebugMode) {
				const downloadButton = addItem('div', {
					className: 'mini-buttons download-book',
					title: 'Download book',
					innerHTML: obRedrawDownloadButton(book.id),
				});

				addClickPointerEvents(downloadButton, () => {
					if (obIsBookCompleted(book.id)) {
						// Book is finished, you can delete the book!
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '100%';
						bookDownloadUI.innerText = '0%';
						obRemoveBookFromTable(book.id);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDeleteBookData(book.id);
					} else if (obIsBookDownloading(book.id)) {
						// Book is downloading, you can cancel the process
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '100%';
						bookDownloadUI.innerText = '0%';
						obRemoveBookFromTable(book.id);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDeleteBookData(book.id);
						obSetSpinner(false);
					} else {
						// Download the book!
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '0%';
						bookDownloadUI.innerText = '0%';
						obAddBookToTable(book);
						obSetSpinner(true);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDownloadBook(book.id)
					}

				})
				addPressEvents(downloadButton, scaleDown, scaleUp)

				bookOverlay.append(markAsRead, downloadButton, bookDetails, markAsUnread);
			} else {
				bookOverlay.append(markAsRead, bookDetails, markAsUnread);
			}

			let progress = (book.readProgress ? ((book.readProgress.page == book.media.pagesCount) ? 0 : book.readProgress.page) : 0)
			const progressBar = addItem('div', { className: 'progress-bar' });
			const progressGauge = addItem('div', { className: 'progress-gauge' });

			/*
			if (useOfflineCopy){
				progress = book.readProgress.page;
			}
			*/

			if ((progress == 0)) {
				progressBar.classList.add('no-show');
			} else {
				progressGauge.style.width = `${Math.round(100 * progress / book.media.pagesCount)}%`;
			}

			booksItem.append(
				thumbnailWrapper,
				progressBar,
				mainRow,
				secondRow
			);

			if (format == 'full') {
				booksItem.append(thirdRow)
			}

			thumbnailWrapper.append(
				bookThumbnail,
				bookDownloadUI,
				bookFader,
				bookOverlay,
				bookStatus,
			);

			progressBar.append(progressGauge);

			booksItem.classList.add('touch-scaler')

			addTouchScaler(booksItem, async () => {
				if (offlineSession && !bookIsOffline) return;

				const seriesData = useOfflineCopy ? offline.seriesMetadata : await callAPI(`c_seriesdata${book.seriesId}`, `/api/v1/series/${book.seriesId}`);
				const readingDirection = seriesData.metadata.readingDirection;

				if (target == booksGrid) {
					rd.historyPath = window.location.hash.split('&book_id=')[0] + '&book_id=' + book.id;
				} else if (target == offlineGrid) {
					rd.historyPath = window.location.hash.split('?book_id=')[0] + '?book_id=' + book.id;
				} else {
					rd.historyPath = window.location.hash.split('&book_id=')[0];
				}

				setIncognito(false);
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${readingDirection}
						&pg=${(book.readProgress ? book.readProgress.page : 1)}`);
			});

			item.append(booksItem);
		}

		function displayBooks(books, target, format, focus = null) {
			/*
				"format" can be one of the follows
				- longname: will not show the series name, but the book file name
				- compact: will show series name and pages 
				- timeline: will show latest read date
				- full: will show series name and pages plus the book title 
			*/
			// focus is the book id to focus on

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			if (books.length === 0) {
				const noBooksMsg = document.createElement('p');
				noBooksMsg.textContent = 'No books available';
				booksGrid.append(noBooksMsg);
				return;
			}

			books.forEach(book => {

				const bookContainer = addItem('div', {
					className: 'book-container collector',
					id: book.id
				});

				buildBookItem(bookContainer, book, format, target);

				target.append(bookContainer);
			});

			if (target == booksGrid) {
				sectionShow(booksGrid);
				sectionShow(seriesHeader);
				sectionShow(seriesMiniHeader);
				seriesMiniHeader.classList.add('collapse');
				focusItem(focus);
			}

		}

		//MB Dashboard Management

		// Function to trigger the home page layout
		async function selectHome() {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = '';
			booksGrid.innerHTML = '';
			offlineGrid.innerHTML = '';
			stripGrid.innerHTML = '';

			sectionShow(homeStripsContainer);

			await Promise.all(
				Object.entries(dashboardElements).map(async ([name, item]) => {
					const resultsObject = await item.getItems(0, 20);
					item.element.style.display = resultsObject.empty ? 'none' : 'block';
					item.showItems(resultsObject.content, item.homeStrip);
				})
			);
			setTimeout(updateSliderProperties, 10);

		}

		dashboardElements = {
			keepReading: {
				headerCode: '<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading',
				getItems: async (page, size) => {
					const out = await callAPI(`c_keepreading`,
						`/api/v1/books/list?page=0&unpaged=true&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"IN_PROGRESS"}}}`
					);
					return (out);
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
				element: null,
				scrollBar: null,
				gridButton: null,
				homeStrip: null,
			},


			onDeck: {
				headerCode: '<span class="fa-solid fa-inbox glyph-dark"></span>&nbsp;On Deck',
				getItems: async (page, size) => {
					return (await callAPI(`c_ondeck`, `/api/v1/books/ondeck`));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
			},

			recentBooks: {
				headerCode: '<span class="fa-solid fa-book glyph-dark"></span>&nbsp;Last Added Books',
				getItems: async (page, size) => {
					return (await callAPI(`c_recentbooks`,
						`/api/v1/books/list?page=${page}&size=${size}&sort=created,desc`,
						'POST', `{"condition":{"allOf":[]}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				}
			},

			recentSeries: {
				headerCode: '<span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Last Added Series',
				getItems: async (page, size) => {
					return (await callAPI(`c_recentseries`, `/api/v1/series/new?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target, null, false);
				}
			},

			updatedSeries: {
				headerCode: '<span class="fa-solid fa-bullhorn glyph-dark"></span>&nbsp;Last Updated Series',
				getItems: async (page, size) => {
					return (await callAPI(`c_updatedseries`, `/api/v1/series/updated?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target, null, false);
				}
			},

			readBooks: {
				headerCode: '<span class="fa-solid fa-square-check glyph-dark"></span>&nbsp;Last Read Books',
				getItems: async (page, size) => {
					return (await callAPI(`c_readbooks`,
						`/api/v1/books/list?page=${page}&size=${size}&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"READ"}}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'timeline');
				},
			},
		}

		async function dashboardAll(element, page) {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = ''; // Clear the series grid
			booksGrid.innerHTML = ''; // Clear the series grid
			offlineGrid.innerHTML = ''; // Clear the series grid
			stripGrid.innerHTML = '';

			sectionShow(stripGridContainer);

			stripGridHeader.innerHTML = dashboardElements[element].headerCode;
			const data = await dashboardElements[element].getItems(page, 50);

			const array = data.content;

			stripPrevPage.classList.remove('disabled');
			stripNextPage.classList.remove('disabled');
			if (data.first) stripPrevPage.classList.add('disabled');
			if (data.last) stripNextPage.classList.add('disabled');

			dashboardElements[element].showItems(array, stripGrid);
		}

		const dashEntries = Object.entries(dashboardElements);

		dashEntries.forEach(([name, item], index) => {
			const isLast = dashEntries.length - 1 === index;

			item.element = addItem('div', { className: 'home-strip-parent hidestrip' });
			const headerContainer = addItem('div', { className: 'strip-header-container hidestrip' });
			const stripHeader = addItem('div', {
				className: 'strip-header hidestrip',
				innerHTML: item.headerCode,
			});
			item.scrollBar = addItem('div', {
				className: 'custom-scrollbar',
			});
			item.scrollInput = addItem('input', {
				type: 'range',
				className: 'range-bar',
				min: '0',
				max: '100',
				value: '0'
			});
			item.gridButton = addItem('div', {
				className: 'strip-all press-flat-button strip-button',
				innerHTML: '<span title="View All" class="fa-solid fa-grip glyph-dark"></span>',
			});
			item.homeStrip = addItem('div', {
				className: 'home-strip' + (isLast ? ' last-strip' : ''),
				binName: name,
			})

			addClickPointerEvents(item.gridButton, async () => {
				mb.dashboardBin = name;
				navigateTo('#dashboard?all=' + name + '&page=0')
			});

			addPressEvents(item.gridButton, scaleDown, scaleUp);

			item.scrollInput.addEventListener('input', () => {
				item.homeStrip.scrollLeft = item.scrollInput.value;
			});
			item.homeStrip.addEventListener('scroll', () => {
				item.scrollInput.value = item.homeStrip.scrollLeft;
			});

			item.scrollBar.append(item.scrollInput);
			headerContainer.append(stripHeader, item.scrollBar, item.gridButton);
			item.element.append(item.homeStrip, headerContainer);
			homeStripsContainer.append(item.element);

		});

		// Open a whole series fetching all its books and showing them with the correct header
		// if seriesdata is not available at the moment of the call, it fetches it from the server
		async function openSeries(libraryId, seriesId, bookId) {

			let books = [];
			const seriesData = await callAPI(`c_seriesdata${seriesId}`, `/api/v1/series/${seriesId}`);

			const booksData = (await callAPI(`c_bookslist${seriesId}`,
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${seriesId}"}}}`
			));

			books = booksData?.content || [];

			await libraryHighlight(libraryId, false);
			if (seriesData != null) displayHeader(seriesData);
			displayBooks(books, booksGrid, 'longname', bookId);
		}

		async function openReadlist(itemId) {
			let books = [];
			const seriesData = await callAPI(`c_readlists${itemId}`, `/api/v1/readlists/${itemId}`);
			const booksData = (await callAPI(`c_bookslist${itemId}`,
				`/api/v1/readlists/${itemId}/books?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'GET'
			));

			books = booksData?.content || [];

			await libraryHighlight('readlistsButton', false);
			//await libraryHighlight('readlistsButton2', false);
			if (seriesData != null) displayHeader(seriesData, true);
			displayBooks(books, booksGrid, 'full');
		}

		async function openCollection(itemId) {
			let contents = [];
			const itemData = await callAPI(`c_collections${itemId}`, `/api/v1/collections/${itemId}`);
			const contentsData = (await callAPI(`c_serieslist${itemId}`,
				`/api/v1/collections/${itemId}/series?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'GET'
			));

			contents = contentsData?.content || [];

			await libraryHighlight('collectionsButton', false);
			//await libraryHighlight('collectionsButton2', false);
			if (itemData != null) displayHeader(itemData, true);
			displaySeries(contents, seriesGrid, null, false);
		}

		async function openOfflineBooks(bookId) {
			libraryHighlight('offlineLibrary', false);

			const unFilteredBooks = await callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				obIsBookDownloading(item.id) || obIsBookCompleted(item.id)
			);

			//books = booksData?.content || [];

			//TODO await libraryHighlight(libraryId, false);

			displayBooks(filteredBooks, offlineGrid, 'compact', bookId);
			focusItem(bookId);//TODO ERA 'top'
			setTimeout(updateSliderProperties, 10);
			sectionShow(offlineGrid);
		}

		function setNetworkStatus(netStatus) {
			offlineLed.style.opacity = (netStatus == 'offline') ? 1 : 0;
			offlineSession = (netStatus == 'offline');
		}

		async function bootSequence(netStatus = 'online') {
			setNetworkStatus(netStatus)

			userSettings = await getUserSettings();

			applyUserSettings();

			applyAccent();
			// Apply first theme change
			changeTheme();
			//changeReaderTheme();
			setIncognito(false);

			document.querySelectorAll('.blankstart').forEach(el => {
				el.classList.remove('blankstart');
			});

			buildLanguageList();

			sectionShow(stickyContainer);

			await executeFaderGradient(0);

			let series_data = null;
			await fetchLibraries();
			await loadContent();

			document.querySelectorAll('.hidestrip').forEach(el => {
				el.classList.remove('hidestrip');
			});

			if (enableDownload) await obRefreshReadStatus();

			// Asynchronous loading of series and books, there's no await, because it's not used unless in offline mode
			const fakerSeries = callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);
			const fakerBooks = callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			if (enableDownload) obRestoreDownloadOnBoot();

		}

		//MB Reader Functions and Data

		// General reader data structure
		let rd = {
			dragbarTimer: null,

			orientationThresholdRatio: 1.0,		//Orientation threshold

			preloadCount: isCapacitor ? 1 : 5,			// TODO SET BACK TO 15 Image preload count

			preloadPicDelay: 300,	// Delay before adding new spreads to the preload stack
			loadDelay: 100,			// Delay used when jumping to a spread before really updating
			jumpTimeout: null,		// Timeout counter for jumping to spreads

			preloadStack: {}, 		// Contains all the preload timers, one for each spread that's going to be loaded
			picLoadStack: [], 		// Contains all load image objects, both direct load and preload

			direction: null,
			webtoon: null,
			webtoonScroll: false,
			webtoonScrollRatio: 0,
			webtoonResizeTimeout: null,

			rtl: null,
			currentPage: 0,
			pagesDataArray: [],		// this is the array of pages data in the form url, iscover etc
			spreadsArray: [],			// Array of spreads objects, containing:

			currentPageIndex: 0,
			currentSpreadIndex: 0,
			oldSpreadIndex: 0,
			isDraggingProgressBar: false,

			thumbZoom: false,
			thumbPosRatio: 0,

			libraryId: 0,
			seriesId: 0,
			bookId: 0,

			historyPath: '',
			bookPath: '',

			incognito: false,

			foreEdgeL: null,
			foreEdgeR: null,
			dropShadowL: null,
			dropShadowR: null,

			turnTimeout: null,
			pageTurning: null,

			turnTime: 500,				// Duration of turning page animation
			scrollSpeed: 500,			// Duration of spread page scrolling
			turnScrollDelay: 300,	// Delay of spread page scrolling during page turn
			turnScrollTime: 500,		// Duration of spread page scrolling during page turn

			turnTime0: 500,				// Duration of turning page animation
			scrollSpeed0: 500,			// Duration of spread page scrolling
			turnScrollDelay0: 300,		// Delay of spread page scrolling during page turn
			turnScrollTime0: 500,		// Duration of spread page scrolling during page turn

			pageShadowOpacityFWD: '0.4',
			pageShadowOpacityBWD: '0.3',
			pageShadowWidthFWD: '10%',
			pageShadowWidthBWD: '15%',

			spreadFocus: 'focus-center',

			focusTransition: {
				'focus-right-page': 'translate(-75%, -50%)',
				'focus-left-page': 'translate(-25%, -50%)',
				'focus-center': 'translate(-50%, -50%)',
				'none': 'translate(-50%, -50%)',
			},

			realFirstPage: 0,
			realLastPage: 0,

			nextBook: null,
			prevBook: null,

			titleBarColor: 'black',

			scale: 1,
			startDist: 0,
			originX: 0,
			originY: 0,
			offsetX: 0,
			offsetY: 0,
			touchLock: 0
		};

		// Function that prepares the page for reading a book, once the url is setup, navigateTo triggers openBookReader function
		function navigateToReadBook(book, readingDirection, force = false) {
			setIncognito(false);
			navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${readingDirection}
						&pg=${force ? 1 : (book.readProgress ? book.readProgress.page : 1)}`);
		}

		// Function that setups the reader for a specific book, this is not run directly
		function openBookReader(libraryId, seriesId, bookId, dir, pg) {
			//TODO aggiungere funzione per pulire l'array del preload e quello delle pic
			Object.entries(dashboardElements).forEach(([name, item]) => {
				item.homeStrip.innerHTML = '';
			});
			clearReader(); //TODO forse eccessivo?
			clearAllTimeouts();
			rd.picLoadStack = [];
			rd.jumpTimeout = null;

			rd.direction = dir;
			rd.webtoon = (dir == 'WEBTOON');
			rd.webtoonScroll = false;
			rd.webtoonScrollRatio = 0;
			rd.rtl = (dir == 'RIGHT_TO_LEFT');

			rd.currentPage = pg;

			rd.spreadsArray = [];

			rd.currentPageIndex = 0;
			rd.currentSpreadIndex = 0;
			rd.oldSpreadIndex = 0;
			rd.isDraggingProgressBar = false;

			rd.libraryId = libraryId;
			rd.seriesId = seriesId;
			rd.bookId = bookId;

			rd.spreadFocus = 'focus-center';

			rd.scale = 1;
			rd.startDist = 0;
			rd.originX = 0;
			rd.originY = 0;
			rd.touchLock = 0;
			rd.offsetX = 0;
			rd.offsetY = 0;

			if (rd.webtoon) scaleWebtoon(0); else scaleReader(0);

			gesture = {
				startDist: 0,
				startScale: 1,
				startMid: { x: 0, y: 0 },
				startContent: { x: 0, y: 0 }
			};

			//readerViewer.innerHTML = '';
			thumbStripShowHide();

			dragbarOnReader();

			setThumbZoom(false, true);

			changeReaderTheme();
			changeReaderAnimation();

			sectionShow(readerContainer);
			sectionShow(readerOverlay);
			sectionShow(touchPanel);

			if (isStatusBar) {
				Capacitor.Plugins.StatusBar.hide();
			}
			if (isNavBar) {
				Capacitor.Plugins.NavigationBar.hide();
			}
			initViewer();

		}

		// Reader cleanup functions to remove all dangling spreads and pages
		function clearReader() {

			// Cleanup ForeEdge and drop shadows
			['foreEdgeL', 'foreEdgeR', 'dropShadowL', 'dropShadowR'].forEach(key => {
				if (rd[key]) {
					rd[key].remove();
					rd[key] = null;
				}
			});

			// Cleanup all the spreads: remove each uiItem (and their descendants) from dom, then null all the graphics item
			// like uiShadowL and uiShadowR, then cleanup the array
			rd.spreadsArray.forEach(item => {
				item.uiItem.remove();
				item.uiThumb.remove();
				item.uiItem = null;
				item.uiThumb = null;
				item.uiShadowL = null;
				item.uiShadowR = null;
				item.uiLightL = null;
				item.uiLightR = null;
				['pageObjL', 'pageObjR'].forEach(key => {
					if (item[key] != null) {
						if (rd.webtoon) webtoonPageNumberObserver.unobserve(item[key].uiPage)
						item[key].uiPage.remove();
						item[key].uiContainer.remove();
						item[key].uiThumb.remove();
						item[key].uiPage = null;
						item[key].uiContainer = null;
						item[key].uiThumb = null;
					}
					item[key] = null;
				});
			});
			rd.spreadsArray = [];

			webtoonContainer.removeAttribute('style');
			sectionHide(readerContainer);
			sectionHide(readerOverlay);
			sectionHide(touchPanel);
		}

		function spreadSetFocus(focusString, smoothMove = false, delayMove = false) {
			if (rd.webtoon) return

			let [duration, delay] = !smoothMove ? [0, 0] : (delayMove ? [rd.turnScrollTime, rd.turnScrollDelay] : [rd.scrollSpeed, 0]);

			readerViewer.animate(
				[{ transform: rd.focusTransition[focusString] }],
				{ duration: duration, easing: 'ease', fill: 'forwards', delay: delay }
			);
			rd.spreadFocus = focusString;
		}

		function spreadSetFocusSmooth(focusString) {
			spreadSetFocus(focusString, true, false)
		};

		function spreadSetFocusSmoothDelay(focusString) {
			spreadSetFocus(focusString, true, true)
		}

		// Setup close button
		function handleCloseReader() {
			hideMenu();
			setIncognito(false);
			//XXX WAS incognitoMark.classList.remove('incognito'); but why didn't I just sue setIncognito(false)?

			clearTimeout(rd.jumpTimeout);
			setTimeout(() => {
				spreadSetFocus('none');
				clearReader();
			}, 400); //300ms timeout so the reader can slide out

			purgeLoading();
			clearAllTimeouts();

			navigateTo(rd.historyPath == '' ? '#dashboard' : rd.historyPath);

			if (isStatusBar && !isSharpCornerIphone) {
				Capacitor.Plugins.StatusBar.show();
			}
			if (isNavBar) {
				Capacitor.Plugins.NavigationBar.show();
			}
		}

		readerClose.addEventListener('click', () => {
			handleCloseReader();
		});

		function changeReaderAnimation() {
			mb.readerAnimationControl.forEach(item => {
				readerAnimation.classList.remove(item.icon);
			});
			readerAnimation.classList.add(mb.readerAnimationControl[mb.readerAnimation].icon);
			readerAnimation.title = mb.readerAnimationControl[mb.readerAnimation].label;

			rd.turnTime = rd.turnTime0 * mb.readerAnimation;
			rd.scrollSpeed = rd.scrollSpeed0 * mb.readerAnimation;
			rd.turnScrollDelay = rd.turnScrollDelay0 * mb.readerAnimation;
			rd.turnScrollTime = rd.turnScrollTime0 * mb.readerAnimation;

			localStorage.setItem('c_readerAnimation', JSON.stringify(mb.readerAnimation))
		}

		function changeReaderTheme() {
			mb.readerThemeControl.forEach(item => {
				readerTheme.classList.remove(item.icon);
			});
			readerTheme.classList.add(mb.readerThemeControl[mb.readerThemePrefs].icon);
			readerTheme.title = mb.readerThemeControl[mb.readerThemePrefs].label;

			document.documentElement.setAttribute('data-theme-reader', mb.readerThemeControl[mb.readerThemePrefs].style);

			//TODO Is this used???
			rd.titleBarColor = rd.webtoon ? 'black' : getComputedStyle(document.documentElement).getPropertyValue('--mb-gr-color-1');

			//rd.titleBarColor = "black";

			setUserSettings('mangabox.ui.readerthemeprefs', mb.readerThemePrefs);

		}

		readerTheme.addEventListener('click', () => {
			mb.readerThemePrefs = (mb.readerThemePrefs + 1) % mb.readerThemeControl.length;
			changeReaderTheme();
		});

		readerAnimation.addEventListener('click', () => {
			mb.readerAnimation = (mb.readerAnimation + 1) % mb.readerAnimationControl.length;
			changeReaderAnimation();
		});

		// Setup incognito button
		function setIncognito(status) {
			readerIncognito.classList.toggle('incognito', status);
			incognitoMark.classList.toggle('incognito', status);
			rd.incognito = status;
		}

		readerIncognito.addEventListener('click', () => {
			setIncognito(!rd.incognito);
		})

		window.addEventListener('resize', () => {
			if (rd.webtoon) webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
		});

		function setThumbZoom(status, init = false) {

			if ((!init) && (rd.thumbZoom == status)) return;

			clientSize = rd.webtoon ? 'clientHeight' : 'clientWidth';
			scrollRef = rd.webtoon ? 'scrollTop' : 'scrollLeft';
			scrollContent = rd.webtoon ? thumbStripScrollContentWT : thumbStripScrollContent;
			inner = rd.webtoon ? thumbStripInnerWT : thumbStripInner


			rd.thumbZoom = status;
			rd.thumbPosRatio = scrollContent[scrollRef] / inner[clientSize]


			scrollContent.style.overflowX = 'hidden';
			scrollContent.style.overflowY = 'hidden';

			const oldSize = inner[clientSize];

			let thumbSize = rd.webtoon ? (status ? 120 : 80) : (status ? 300 : 150);

			if (!rd.webtoon) {
				if (window.innerHeight - thumbSize - 60 - 60 - 30 < 0) {
					thumbSize = window.innerHeight - 60 - 60 - 30;
				}
			}
			document.documentElement.style.setProperty('--mb-thumb-size-px', thumbSize + 'px');



			setTimeout(() => {
				scrollContent.style.overflowX = rd.webtoon ? 'hidden' : 'auto';
				scrollContent.style.overflowY = rd.webtoon ? 'auto' : 'hidden';
			}, 500);

		}

		thumbStripButton.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});
		addPressEvents(thumbStripButton, scaleDown, scaleUp);

		thumbStripButtonWT.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});
		addPressEvents(thumbStripButtonWT, scaleDown, scaleUp);

		//TODO This code is flexible and usable for both, an alternative is splitting all the code for the two WT and !WT

		const resizeObserver = new ResizeObserver(entries => {
			clientSize = rd.webtoon ? 'clientHeight' : 'clientWidth';
			scrollRef = rd.webtoon ? 'scrollTop' : 'scrollLeft';
			scrollContent = rd.webtoon ? thumbStripScrollContentWT : thumbStripScrollContent;
			inner = rd.webtoon ? thumbStripInnerWT : thumbStripInner

			for (let entry of entries) {
				scrollContent[scrollRef] = rd.thumbPosRatio * (inner[clientSize])
			}
		});

		resizeObserver.observe(thumbStripInner);
		resizeObserver.observe(thumbStripInnerWT);

		function updateProgressBar(currentSpreadIndex = rd.currentSpreadIndex) {
			const progressPercent = (currentSpreadIndex / (spreadsTotal() - 1)) * 100;
			readerProgress.style.width = `${progressPercent}%`;
			readerProgress.style.float = rd.rtl ? 'right' : 'left';

			[rd.currentPage, readerPage.innerHTML] = getPageFromSpread(currentSpreadIndex);

			readerPage.style.left = rd.rtl
				? `min(max(0px, calc(${100 - progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
				: `min(max(0px, calc(${progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
		}

		function preloadPage(index) {
			if (picLoadStackSize() < 20000000) populateSpreadPreload(index);
		}

		function calcDelay(i, delay, scale, power) {
			return ((delay * (1 - scale) + (i ** power) * delay * scale))
		}

		// This function triggers multiple preloads starting from the current spread
		function preloadPages(startSpreadIndex, count) {
			if (isSectionHidden(readerContainer)) return;

			for (let i = 1; i <= count; i++) {
				const forwardIndex = startSpreadIndex + i;
				const backwardIndex = startSpreadIndex - i;

				if (forwardIndex < spreadsTotal() && !(forwardIndex in rd.preloadStack)) {
					startTimeout(forwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(forwardIndex));
				}
				if (backwardIndex >= 0 && !(backwardIndex in rd.preloadStack)) {
					startTimeout(backwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(backwardIndex));
				}
			}
		}

		function dragbarOffReader() {
			rd.dragbarTimer = setTimeout(() => {
				dragbar.classList.remove('onReader');
			}, 500);
			//dragbar.classList.remove('offReader');
		}

		function dragbarOnReader() {
			clearTimeout(rd.dragbarTimer);
			dragbar.classList.remove('onReader');
			dragbar.classList.add('onReader');
		}

		function initReaderUI(pagesData, bookData) {
			leftLimit.innerText = rd.rtl ? rd.realLastPage : rd.realFirstPage;
			rightLimit.innerText = rd.rtl ? rd.realFirstPage : rd.realLastPage;
			bookName.innerText = `${bookData.seriesTitle} Vol.${bookData.metadata.number} (${bookData.metadata.title})`
		}

		function webtoonRatio() {
			return (webtoonContainer.scrollTop + webtoonContainer.clientHeight * 0.5) / webtoonContainer.scrollHeight
		}

		function thumbStripShowHide() {
			thumbStrip.style.display = thumbStripButton.style.display = rd.webtoon ? 'none' : '';
			thumbStripWT.style.display = thumbStripButtonWT.style.display = rd.webtoon ? '' : 'none';
		}

		// Initialize viewer with page data
		async function initViewer() {
			//TODO questa si può estrarre come quella di buildbookitem
			let offline = null;

			let useOfflineCopy = offlineSession && obIsBookCompleted(rd.bookId);
			if (useOfflineCopy) {
				offline = await obLoadOfflineBook(rd.bookId);
			}

			const bookData = useOfflineCopy ? offline.bookMetadata : await callAPI(`c_bookdata${rd.bookId}`, `/api/v1/books/${rd.bookId}`);

			rd.prevBook = await callAPI(`c_books${rd.bookId}prev`, `/api/v1/books/${rd.bookId}/previous`) || null;
			rd.nextBook = await callAPI(`c_books${rd.bookId}next`, `/api/v1/books/${rd.bookId}/next`) || null;

			if (!prevBookPanel.classList.contains('hidden')) prevBookPanel.classList.add("hidden");
			if (!nextBookPanel.classList.contains('hidden')) nextBookPanel.classList.add("hidden");

			const noCover = bookData.metadata.tags.includes('no-cover');
			const noWhitePage = bookData.metadata.tags.includes('no-blank-page');
			const coverIsPageOne = bookData.metadata.tags.includes('cover-is-page-one');

			const pagesData = !rd.webtoon ?
				await fetchPages(rd.bookId, noCover, noWhitePage, coverIsPageOne, offline) :
				await fetchPagesWebtoon(rd.bookId, noCover, noWhitePage, coverIsPageOne, offline);

			if (!rd.incognito && bookData.readProgress && (bookData.readProgress.page == bookData.media.pagesCount)) {
				rd.currentSpreadIndex = 0; //TODO Maybe change this with a check with the top page?
			}

			touchPanel.style.display = rd.webtoon ? 'none' : '';
			//zoomControls.style.display = rd.webtoon ? '' : 'none';
			zoomControls.style.bottom = rd.webtoon ? 'calc(80px + var(--mb-bottom-spacer))' : 'calc(110px + var(--mb-bottom-spacer) + var(--mb-thumb-size-px))';

			initReaderUI(pagesData, bookData)

			jumpToSpreadSkipHistory(rd.currentSpreadIndex);

			if (rd.webtoon) {
				rd.webtoonScrollRatio = webtoonRatio()
			}

			readerContainer.style.transform = `scale(100%)`;
			readerContainer.style.transformOrigin = `50% 50%`;

			setTimeout(() => {
				webtoonContainer.style.overflow = 'auto';
				//thumbStripScrollContent.style.overflowX = 'auto';
				//thumbStripScrollContent.style.overflowY = 'hidden';
				//thumbStripScrollContentWT.style.overflowX = 'hidden';
				//thumbStripScrollContentWT.style.overflowY = 'auto';

			}, 500);

		}

		function buildSize(item, ratio) {
			item.style.width = `calc(min(100vw, var(--mb-reader-scale) / 100 * ${ratio} * 100vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, var(--mb-reader-scale) / 100 * 100vh) )`;
		}

		function buildSizeCV(item, ratio) {
			//item.style.objectFit = 'fill';
			item.style.objectPosition = 'center center';
			item.style.width = `calc(min(100vw, var(--mb-reader-scale) / 100 * ${ratio} * 100vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, var(--mb-reader-scale) / 100 * 100vh) )`;
		}

		// Size the spread for a two pages spread with fit on page
		function buildSize2P(item, ratio) {
			//item.style.width = `calc(2 * min(100vw, ${100 * ratio * 0.5}vh))`;
			//item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, 100vh))`;

			item.style.width = `calc(2 * min(100vw, var(--mb-reader-scale) / 100 * ${ratio} * 50vh))`;
			item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, var(--mb-reader-scale) / 100 * 100vh) )`;
		}

		// Add this once when initializing the viewer
		//readerViewer.style.transition = "left 0.3s ease, border-width 0.3s ease, border-image-slice 0.3s ease";

		function buildForeEdge(index, total) {
			// book size is a parabola based on number of spreads capped at 400 spreads
			const fullBook = (total / 400 > 1 ? 1 : ((1 - (total / 400 - 1) * (total / 400 - 1))));
			const pageRate = rd.rtl ? 1.0 - index / total : index / total;

			[clipLeft, clipRight] = [
				`inset(0 0 0 ${100 * ((1.0 - fullBook) + fullBook * (1 - pageRate))}%)`,
				`inset(0 ${100 * (1.0 - fullBook + fullBook * pageRate)}% 0 0)`]

			return ({ left: clipLeft, right: clipRight, dropL: fullBook * pageRate, dropR: fullBook * (1 - pageRate) })
		}

		//MB Reader Fetch Page Function

		function buildSpreadObject(spreadKind, spreadPages, spreadRefPage, spreadPageNums) {
			// I put the image item and container item in the array so I can target them for changes
			// and I put all the metadata like "hasSrc" in the object metadata instead of in a separate item.
			if (!rd.webtoon) {
				return ({
					// dom object, spread div and its content
					// dom object, shadow for page effect, children of uiItem in the dom
					//  "
					// dom object, thumbnail of the spread for the strip view
					uiItem: addItem('div', { className: 'spread-layout' }),
					uiShadowL: addItem('div', { className: 'page-shadow-left' }),
					uiShadowR: addItem('div', { className: 'page-shadow-right' }),
					uiLightL: addItem('div', { className: 'page-light-left' }),
					uiLightR: addItem('div', { className: 'page-light-right' }),
					uiThumb: addItem('div', { className: 'spread-thumb' }),
					pageObjL: spreadPages['left'] ?? null,
					pageObjR: spreadPages['right'] ?? null,

					pageNumL: spreadPageNums['left'] ?? null,
					pageNumR: spreadPageNums['right'] ?? null,

					spreadKind: spreadKind,	// what kind of page is this (cover, double spread, two pages etc)
					spreadRefPage: spreadRefPage
				})
			} else {
				return ({
					// dom object, spread div and its content
					// dom object, shadow for page effect, children of uiItem in the dom
					//  "
					// dom object, thumbnail of the spread for the strip view
					uiItem: addItem('div', { className: 'webtoon-layout' }),
					//uiShadowL: addItem('div', { className: 'page-shadow-left' }),
					//uiShadowR: addItem('div', { className: 'page-shadow-right' }),
					//uiLightL: addItem('div', { className: 'page-light-left' }),
					//uiLightR: addItem('div', { className: 'page-light-right' }),
					uiThumb: addItem('div', { className: 'webtoon spread-thumb' }),
					pageObjL: spreadPages ?? null,
					//pageObjR: spreadPages['right'] ?? null,

					pageNumL: spreadPageNums ?? null,
					//pageNumR: spreadPageNums['right'] ?? null,

					spreadKind: spreadKind,	// what kind of page is this (cover, double spread, two pages etc)
					spreadRefPage: spreadRefPage
				})
			}
		}

		function spreadsTotal() {
			return rd.spreadsArray.length
		}

		function buildPageObject(pageData) {
			const isBlank = (pageData == 'blank');
			const isHidden = (pageData == 'hidden');

			const pageItem = {
				uiPage: addItem('img', {
					alt: isBlank ? '' : pageData.pageNum,
					className: 'page multiply hidden',
					src: 'transparent.png',
				}),
				uiContainer: addItem('div', {
					className: isHidden ? 'page-container hidden-page' : 'page-container'
				}),
				uiThumb: addItem('img', {
					className: isHidden ? 'page-thumb multiply hidden hidden-page' : 'page-thumb multiply hidden',
					alt: (isBlank || isHidden) ? '' : pageData.pageNum,
					src: 'transparent.png',
					lazySrc: (isBlank || isHidden) ? '' : pageData.thumb,
					style: rd.webtoon ?
						{
							width: 'var(--mb-thumb-size-px)',
							aspectRatio: isHidden ? '0.001' : pageData.AR,
						} : {
							height: 'var(--mb-thumb-size-px)',
							aspectRatio: isHidden ? '0.001' : pageData.AR,
						}
				}),
				hasSrc: (isBlank || isHidden) ? true : false,
				lazySrc: (isBlank || isHidden) ? '' : pageData.url,
				size: (isBlank || isHidden) ? 0 : pageData.size,
				pageNum: (isBlank || isHidden) ? '' : pageData.pageNum,
				isCurrent: (isBlank || isHidden) ? false : pageData.isCurrent,
				AR: isBlank ? null : pageData.AR,
			}

			if ((pageData != 'blank') && (pageData != 'hidden')) addLazyLoading(pageItem.uiThumb);
			pageItem.uiContainer.append(pageItem.uiPage);

			return pageItem;
		};

		function pageTable(page1, page2) {
			return (
				rd.rtl ?
					{ left: page2, right: page1 } :
					{ left: page1, right: page2 }
			)
		}

		function animateWebtoonScale(from, to, duration = 300, easing = t => t) {
			let start;
			function frame(ts) {
				if (!start) start = ts;
				const t = Math.min(1, (ts - start) / duration);
				const v = from + (to - from) * easing(t);
				document.documentElement.style.setProperty('--mb-webtoon-scale', v);
				webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
				if (t < 1) requestAnimationFrame(frame);
			}
			requestAnimationFrame(frame);
		}

		function animateReaderScale(from, to, duration = 300, easing = t => t) {
			let start;
			function frame(ts) {
				if (!start) start = ts;
				const t = Math.min(1, (ts - start) / duration);
				const v = from + (to - from) * easing(t);
				document.documentElement.style.setProperty('--mb-reader-scale', v);
				updateReaderOrientation()
				//webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
				if (t < 1) requestAnimationFrame(frame);
			}
			requestAnimationFrame(frame);
		}


		function scaleWebtoon(inc) {
			const oldScale = mb.webtoonScale;
			const newScale = Math.min(100, Math.max(20, mb.webtoonScale + inc));
			mb.webtoonScale = newScale;

			localStorage.setItem('c_webtoonScale', JSON.stringify(newScale))
			scaleVal.innerText = newScale + "%";

			animateWebtoonScale(oldScale, newScale, 200, t => t * (2 - t));
		}

		function scaleReader(inc) {
			const oldScale = mb.readerScale;
			const newScale = Math.min(110, Math.max(50, mb.readerScale + inc));
			mb.readerScale = newScale;

			localStorage.setItem('c_readerScale', JSON.stringify(newScale))
			scaleVal.innerText = newScale + "%";

			animateReaderScale(oldScale, newScale, 200, t => t * (2 - t));
		}


		function readerScaleDown() {
			if (rd.webtoon) {
				scaleWebtoon(-20);
			} else {
				scaleReader(-5);
			}
		}

		function readerScaleUp() {
			if (rd.webtoon) {
				scaleWebtoon(20);
			} else {
				scaleReader(5);
			}
		}

		function addCoverSpine(pageObjectL, pageObjectR) {
			const coverlayR = addItem('div', {
				id: 'coverlayer',
				className: 'LTR',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectR.uiContainer.append(coverlayR);
			const coverlayL = addItem('div', {
				id: 'coverlayer',
				className: 'RTL',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectL.uiContainer.append(coverlayL);
		}

		const mimeToExt = {
			'image/jpeg': '.jpg',
			'image/png': '.png',
			'image/webp': '.webp',
			'image/gif': '.gif',
		};

		async function fetchPagesWebtoon(bookId, noCover, noWhitePage, coverIsPageOne, offline) {

			let useOfflineCopy = !(offline == null);

			// Get the pages data structure from server for the current book
			const serverPageData = useOfflineCopy ? offline.pagesMetadata : await callAPI(`c_bookpages${bookId}`, `/api/v1/books/${bookId}/pages`);

			/*
			readerViewer.style.width = webtoonScale * (serverPageData.map(item => ((item.width)))
				.reduce((sum, width) => sum + width, 0) / serverPageData.length) + 'px';
	
			readerViewer.style.height = webtoonScale * (serverPageData.map(item => ((item.height)))
				.reduce((sum, width) => sum + width, 0)) + 'px';
			*/
			mb.readerHorizontal = isReaderHorizontal(mb.screenAR);
			thumbStripInnerWT.style.flexDirection = 'column';

			const pageData = serverPageData.map(page => ({
				url: useOfflineCopy ? `${offline.bookPath}/pages/${page.number}${mimeToExt[page.mediaType]}` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: useOfflineCopy ? `${offline.bookPath}/thumbs/t_${page.number}.jpg` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: noCover ? false : page.number == 1,
				isCurrent: page.number == rd.currentPage,
				size: page.sizeBytes
			}));

			//let imageWidth = pageData[0].width;
			let imageWidth = Math.max(...pageData.map(p => p.width));

			let screenWidth = readerContainer.clientWidth;

			//let webtoonScale = 1.0;
			//if (screenWidth < imageWidth) webtoonScale = screenWidth / imageWidth;

			let i_page = 0; 		// Index of server page data
			let realPage = 1;		// Index of real page

			// double spread with single page are treated as this:
			// one div for the spread contains TWO pages sharing the same image, but with different alignment properties
			// therefore the pageNums are like [5, 5] and the imageRefs are like (5,6)

			rd.realFirstPage = '1';

			while (i_page < pageData.length) {
				let spreadObject = null;

				pageNum1 = realPage

				// these are two normal pages
				const page1 = buildPageObject(pageData[i_page]);

				page1.uiPage.style.width = `calc(var(--mb-webtoon-scale) * 1vw)`
				page1.uiPage.style.height = `calc(var(--mb-webtoon-scale) * 1vw / ${pageData[i_page].AR})`

				if (rd.webtoon) webtoonPageNumberObserver.observe(page1.uiPage);

				spreadObject = buildSpreadObject('webtoon-page', page1, pageData[i_page].pageNum, pageNum1);
				rd.realLastPage = pageNum1;

				rd.spreadsArray.push(spreadObject);
				i_page++;
				realPage++;

			}

			rd.spreadsArray.forEach((spreadObject, index) => {

				let pageObjectL = spreadObject.pageObjL;

				spreadObject.uiThumb.append(
					pageObjectL.uiThumb,
				);

				spreadObject.uiItem.append(
					pageObjectL.uiContainer,
				);

				spreadObject.uiItem.style.width = pageObjectL.uiPage.style.width
				spreadObject.uiItem.style.height = pageObjectL.uiPage.style.height

				//TODO Ma questo serve???? Farlo uguale a readerViewer?

				pageObjectL.uiPage.style.float = 'right';
				pageObjectL.uiPage.style.objectFit = 'cover';
				pageObjectL.uiPage.style.objectPosition = 'left';

				if ((pageObjectL.isCurrent)) rd.currentSpreadIndex = index;

				webtoonContainer.append(spreadObject.uiItem);
				//spreadHide(index);

				const localSpread = index;

				spreadObject.uiThumb.addEventListener('pointerup', () => {
					jumpToSpread(localSpread);
				});
				thumbStripInnerWT.append(spreadObject.uiThumb);

			});
		}

		function computeReaderMaxRatio(serverPageData, spreadThreshold = 1.5) {
			if (!serverPageData || serverPageData.length === 0) return 1;

			// compute aspect ratios
			const ratios = serverPageData.map(item => item.width / item.height);

			// decide orientation by majority
			const landscapeCount = ratios.filter(r => r > 1).length;
			//	const isLandscape = landscapeCount > ratios.length / 2;

			// if there is at least one portrait page, then
			// a majority of >1 ratios does NOT mean true landscape — it means "double-spread portrait".
			const hasPortrait = ratios.some(r => r < 1);
			let isLandscape;
			if (!hasPortrait) {
				// ALL pages are landscape → trust landscape mode
				isLandscape = true;
			} else {
				// We have portrait pages somewhere.
				// If >80% are wide, but portrait pages exist → assume portrait book with double spreads.
				const widePercentage = landscapeCount / ratios.length;
				if (widePercentage > 0.5) {
					isLandscape = false; // portrait book, spreads

				} else {
					// Normal book → orientation by majority
					isLandscape = landscapeCount > ratios.length / 2;

				}
			}

			// estimate typical single page ratio:
			// - for landscape: median of ratios > 1
			// - for portrait: median of ratios < 1
			let candidate;
			if (isLandscape) {
				const landscapeSingles = ratios.filter(r => r > 1);
				candidate = median(landscapeSingles.length ? landscapeSingles : ratios);
			} else {
				const portraitSingles = ratios.filter(r => r < 1);
				candidate = median(portraitSingles.length ? portraitSingles : ratios);
			}

			// fallback guard
			if (!isFinite(candidate) || candidate <= 0) candidate = median(ratios);

			// now for each page: if page looks like a single (ratio close to typical_single),
			// treat it as half of a spread => use 2 * ratio. Otherwise use ratio as-is.
			const adjusted = ratios.map(r => {
				const normalized = r / candidate;
				return (normalized < spreadThreshold) ? (2 * r) : r;
			});

			// average
			const sum = adjusted.reduce((s, v) => s + v, 0);
			return sum / adjusted.length;
		}

		function median(arr) {
			if (!arr || arr.length === 0) return NaN;
			const a = Array.from(arr).sort((x, y) => x - y);
			const m = Math.floor(a.length / 2);
			return (a.length % 2 === 1) ? a[m] : (a[m - 1] + a[m]) / 2;
		}

		// Master function that builds all the pages slots for the book spreads
		async function fetchPages(bookId, noCover, noWhitePage, coverIsPageOne, offline) {

			let useOfflineCopy = !(offline == null);

			// Get the pages data structure from server for the current book
			const serverPageData = useOfflineCopy ? offline.pagesMetadata : await callAPI(`c_bookpages${bookId}`, `/api/v1/books/${bookId}/pages`);


			// mb.readerMaxRatioOLD = Math.max(...dataOut.map(item => (item.isCover || item.isDoubleSpread) ? 0 : ((item.width / item.height) < 1 ? 2 * item.width / item.height : 2 * item.width / item.height)));
			/*
			mb.readerMaxRatio = serverPageData.map(item => ((item.width / item.height) < 1 ? 2 * item.width / item.height : item.width / item.height))
				.reduce((sum, ratio) => sum + ratio, 0) / serverPageData.length;
			*/

			mb.readerMaxRatio = computeReaderMaxRatio(serverPageData, 1.5);

			// readerViewer.style.height='100vh';
			readerViewer.style.height = `calc(min(${100 / (0.5 * mb.readerMaxRatio)}vw, var(--mb-reader-scale) / 100 * 100vh))`;
			//readerViewer.style.width=`calc(${mb.readerMaxRatio} * 100vh)`;
			readerViewer.style.width = `calc(min(200vw, var(--mb-reader-scale) / 100 * ${mb.readerMaxRatio} * 100vh))`;

			mb.readerHorizontal = isReaderHorizontal(mb.screenAR);
			thumbStripInner.style.flexDirection = rd.rtl ? 'row-reverse' : 'row';

			// Create pageData structure with the fields from fetched data
			const pageData = serverPageData.map(page => ({
				url: useOfflineCopy ? `${offline.bookPath}/pages/${page.number}${mimeToExt[page.mediaType]}` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: useOfflineCopy ? `${offline.bookPath}/thumbs/t_${page.number}.jpg` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: noCover ? false : page.number == 1,
				isOrphan: noWhitePage && (page.number == 2),
				isCurrent: page.number == rd.currentPage,
				isDoubleSpread: ((page.width / page.height) > 1.5 * (mb.readerMaxRatio * 0.5)),
				size: page.sizeBytes
			}));

			rd.foreEdgeL = addItem('div', {
				id: 'foreEdgeL',
				src: 'pages-left.png',
				style: {
					clipPath: 'inset(0 0 0 100%)'
				},
			});

			rd.foreEdgeR = addItem('div', {
				id: 'foreEdgeR',
				src: 'pages-right.png',
				style: {
					clipPath: 'inset(0 100% 0 0)'
				}
			});

			//Default shadow opacity is 0, it is overriden at the time of creation so it transitions in 0.5s
			rd.dropShadowL = addItem('div', { id: 'dropShadowL' });
			rd.dropShadowR = addItem('div', { id: 'dropShadowR' });

			readerViewer.append(rd.foreEdgeL, rd.foreEdgeR, rd.dropShadowL, rd.dropShadowR);

			// Create html structure for every page and related page thumbnails
			// and organize data structur for spread formation

			let i_page = 0; 		// Index of server page data
			let realPage = 1;		// Index of real page

			// double spread with single page are treated as this:
			// one div for the spread contains TWO pages sharing the same image, but with different alignment properties
			// therefore the pageNums are like [5, 5] and the imageRefs are like (5,6)

			const firstNonCover = coverIsPageOne ? 2 : 1;

			rd.realFirstPage = coverIsPageOne ? '1' : 'C';

			// Create spreads objects and pages objects
			while (i_page < pageData.length) {
				let spreadObject = null;

				pageNum1 = realPage == firstNonCover ? (coverIsPageOne ? 2 : '') : realPage;
				pageNum2 = realPage == firstNonCover ? (coverIsPageOne ? 3 : realPage) : realPage + 1
				pageCover = pageData[i_page].isCover;

				if (pageData[i_page].isCover) {
					// Element is a cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('cover-page', pageTable(hidden, cover), pageData[i_page].pageNum, pageTable(coverIsPageOne ? '' : '', coverIsPageOne ? 1 : ''));
				}
				else if (pageData[i_page].isDoubleSpread) {
					// Element is a double spread, generate second set of images
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('double-spread', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);
				}
				else if (i_page == pageData.length - 1) {
					// Element is last single page, so back cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('back-cover', pageTable(cover, hidden), pageData[i_page].pageNum, pageTable(realPage, ''));
					rd.realLastPage = realPage;
				}
				else if (((i_page + 1 < pageData.length) && (pageData[i_page + 1].isDoubleSpread)) || (pageData[i_page].isOrphan)) {
					// This is an orphan page!
					const page1 = buildPageObject('blank');
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);
				}
				else {
					// these are two normal pages
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page + 1]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);

					i_page++;
				}

				rd.spreadsArray.push(spreadObject);
				i_page++;

				if (pageCover) {
					if (coverIsPageOne) {
						realPage = 2;
					}
				} else {
					if (coverIsPageOne && (realPage == firstNonCover)) {
						realPage = 4
					} else {
						realPage = realPage + (realPage == firstNonCover ? 1 : 2);
					}
				}
			}

			// Style and structure the spread objects and pages
			rd.spreadsArray.forEach((spreadObject, index) => {

				let pageObjectL = spreadObject.pageObjL;
				let pageObjectR = spreadObject.pageObjR;

				spreadObject.uiThumb.append(
					pageObjectL.uiThumb,
					pageObjectR.uiThumb,
				);

				spreadObject.uiItem.append(
					pageObjectL.uiContainer,
					pageObjectR.uiContainer,
				);

				//TODO MA questo non è sovrascritto dal successivo?
				buildSize2P(spreadObject.uiItem, mb.readerMaxRatio);
				//TODO Ma questo serve???? Farlo uguale a readerViewer?
				spreadObject.uiItem.style.width = `calc(min(200vw, var(--mb-reader-scale) / 100 * ${mb.readerMaxRatio} * 100vh))`;

				buildSize(pageObjectL.uiContainer, mb.readerMaxRatio * 0.5);
				buildSize(pageObjectR.uiContainer, mb.readerMaxRatio * 0.5);

				pageObjectL.uiPage.style.float = 'right';
				pageObjectR.uiPage.style.float = 'left';
				pageObjectL.uiPage.style.objectFit = 'cover';
				pageObjectR.uiPage.style.objectFit = 'cover';
				pageObjectL.uiPage.style.objectPosition = 'left';
				pageObjectR.uiPage.style.objectPosition = 'right';
				pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
				pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				if ((pageObjectL.isCurrent) || (pageObjectR.isCurrent)) rd.currentSpreadIndex = index;

				if ((spreadObject.spreadKind == 'cover-page') || (spreadObject.spreadKind == 'back-cover')) {
					spreadObject.uiItem.classList.add('cover-page')

					pageObjectL.uiContainer.classList.add('cover-page-RTL');
					pageObjectR.uiContainer.classList.add('cover-page-LTR');
					pageObjectL.uiContainer.style['marginLeft'] = 'auto';
					pageObjectR.uiContainer.style['marginRight'] = 'auto';

					buildSizeCV(pageObjectL.uiPage, mb.readerMaxRatio * 0.5);
					buildSizeCV(pageObjectR.uiPage, mb.readerMaxRatio * 0.5);

					addCoverSpine(pageObjectL, pageObjectR);

				}
				else if (spreadObject.spreadKind == 'two-pages') {
					spreadObject.uiItem.classList.add('two-pages');

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR ?? pageObjectR.AR;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectR.AR ?? pageObjectL.AR;

					pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
					pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				}
				else if (spreadObject.spreadKind == 'double-spread') {
					spreadObject.uiItem.classList.add('two-pages');

					// Crop double spreads thumbnails
					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectL.uiThumb.style.objectFit = 'cover';
					pageObjectR.uiThumb.style.objectFit = 'cover';
					pageObjectL.uiThumb.style.objectPosition = 'left';
					pageObjectR.uiThumb.style.objectPosition = 'right';

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					buildSize(pageObjectL.uiPage, pageObjectL.AR * 0.5);
					buildSize(pageObjectR.uiPage, pageObjectR.AR * 0.5);

				}
				spreadObject.uiItem.append(spreadObject.uiShadowL, spreadObject.uiShadowR);
				spreadObject.uiItem.append(spreadObject.uiLightL, spreadObject.uiLightR);

				readerViewer.append(spreadObject.uiItem);
				spreadHide(index);

				const localSpread = index;

				spreadObject.uiThumb.addEventListener('pointerup', () => {
					jumpToSpread(localSpread);
				});
				thumbStripInner.append(spreadObject.uiThumb);

			});

			//TODO Qui non funziona bene, spostato dopo initviewer, si può togliere?
			//TODO Tolto, verificare
			//spreadSetFocus(getSpreadFocus(rd.currentSpreadIndex));

			return pageData;
		}

		// Starts timeout for element id of the preload stack
		function startTimeout(id, duration, callback) {
			const timeoutId = setTimeout(() => {
				// Execute the callback when the timeout finishes
				callback();
				delete rd.preloadStack[id];
			}, duration);

			// Add the timeoutId to the stack
			rd.preloadStack[id] = timeoutId;
		}

		// Function to clear all timeouts (optional, if you need this functionality)
		function clearAllTimeouts() {
			Object.values(rd.preloadStack).forEach(timer => {
				clearTimeout(timer);
			});
			rd.preloadStack = {};
		}

		// Calculate stack size for the image loading stack
		function picLoadStackSize() {
			let out = 0;
			rd.picLoadStack.forEach(element => {
				out += element.size;
			});
			return (out);
		}

		function printStack(str_in) {
			return; //DEBUG Disable debug of preload stack
			let out = str_in + ' *';
			rd.picLoadStack.forEach(element => {
				out = out + ' ' + element;
			})
			out = 'tot:' + rd.picLoadStack.length + ' ' + out + ' *';
			console.log(out);
		}

		// Actually load media in the selected index, isPreload is true if the population action is
		// triggered by a preload, so it doesn't trigger further preloads

		async function populateSpread(spreadIndex, isPreload = false) {
			if (isSectionHidden(readerContainer)) return; //XXX THIS IS PROBABLY THE BEST

			let uiPageArray = [
				rd.spreadsArray[spreadIndex].pageObjL,
				rd.spreadsArray[spreadIndex].pageObjR,
			].filter(el => el != null);

			const promises = uiPageArray.map(async (element, index) => {

				if (rd.picLoadStack.indexOf(element) == -1) {
					if (!element.hasSrc) {
						rd.picLoadStack.push(element); // Add to the stack
						printStack('S');
						element.uiPage.classList.add('loading');
						try {
							// Fetch the image
							const blobUrl = await fetchMedia(element.lazySrc, false);
							if (isSectionHidden(readerContainer)) return;
							// These lines reduce stuttering
							//TODO Verify if this creates some errors when going back from reader and pages are still loading
							//const img = new Image();
							//img.src = blobUrl;
							//await img.decode();

							element.uiPage.src = blobUrl;
							//element.uiPage.blobUrl = blobUrl;
							element.hasSrc = true;
							//rd.uiPages[element].src = rd.pagesDataArray[element].url;
							// Handle successful load
							element.uiPage.addEventListener('load', () => {
								element.uiPage.classList.add('loaded');
								element.uiPage.classList.remove('hidden');
								element.uiPage.classList.remove('loading');
								if (isSectionHidden(readerContainer)) {
									printStack('LX ');
									return;
								}
								const index = rd.picLoadStack.indexOf(element);
								printStack('L ' + index);
								if (index !== -1) {
									rd.picLoadStack.splice(index, 1); // Remove from stack
								};
								if (!isPreload) {
									preloadPages(spreadIndex, rd.preloadCount)
								}
							});
						} catch (error) {
							console.error(`Failed to load image for element ${element}:`, error);
							// Handle error (optional: remove from stack or show fallback)
						}
					}

					// Immediately handle cached images
					else if (element.uiPage.complete) {
						element.uiPage.classList.add('loaded');
						element.uiPage.classList.remove('hidden');
						element.uiPage.classList.remove('loading');
						const index = rd.picLoadStack.indexOf(element);
						if (index !== -1) {
							rd.picLoadStack.splice(index, 1);
						}
						//XXX REMOVED Force preload when landing on a cached image

						if (!isPreload) {
							preloadPages(spreadIndex, rd.preloadCount)
						}
					}
				}
			});

			// Wait for all fetches to complete
			await Promise.all(promises);
		}

		function populateSpreadPreload(spreadIndex) {
			populateSpread(spreadIndex, true)
		}

		function handleArrow(direction) {
			const isDirectionLeft = (direction === 'left');
			const delta = (rd.rtl === isDirectionLeft) ? 1 : -1;
			const newSpread = rd.currentSpreadIndex + delta;

			if (rd.webtoon) {
				jumpToSpread(newSpread);
				return
			}

			if (rd.pageTurning === direction) return;
			if (newSpread < 0 || newSpread > spreadsTotal()) return;
			if ((newSpread >= spreadsTotal()) && (rd.spreadsArray[rd.currentSpreadIndex].spreadKind == 'back-cover')) return;

			const edgeFocus = isDirectionLeft ? 'focus-right-page' : 'focus-left-page';
			const targetFocus = isDirectionLeft ? 'focus-left-page' : 'focus-right-page';

			if (!mb.readerHorizontal && newSpread === spreadsTotal() && rd.spreadFocus === edgeFocus) {
				return spreadSetFocusSmooth(targetFocus);
			}

			if ((newSpread === 0 || newSpread === spreadsTotal() - 1) && rd.pageTurning) return;

			const earlyTurnBlock = (isDirectionLeft !== rd.rtl) && rd.currentSpreadIndex === spreadsTotal() - 2;
			const lateTurnBlock = (isDirectionLeft === rd.rtl) && rd.currentSpreadIndex === 1;
			if ((earlyTurnBlock || lateTurnBlock) && rd.pageTurning) return;


			if (mb.readerHorizontal) {
				jumpToSpread(newSpread);
			} else if (rd.spreadFocus === edgeFocus) {
				spreadSetFocusSmooth(targetFocus);
			} else {
				jumpToSpread(newSpread, edgeFocus);
			}
		}

		function handleLeftArrow() {
			handleArrow('left');
		}

		function handleRightArrow() {
			handleArrow('right');
		}

		function handleLeftLimit() {
			jumpToSpread(!rd.rtl ? 0 : spreadsTotal() - 1);
		}

		function handleRightLimit() {
			jumpToSpread(!rd.rtl ? spreadsTotal() - 1 : 0);
		}

		function handleSmallThumbs() {
			setThumbZoom(false);
		};

		function handleLargeThumbs() {
			setThumbZoom(true);
		};


		function getPageFromSpread(index) {
			const spreadObject = rd.spreadsArray[index];

			const twoPages = (rd.spreadsArray[index].spreadKind == 'two-pages');
			const lastSpread = (twoPages && (index == (spreadsTotal() - 1)));

			const currentPage = lastSpread ? spreadObject.spreadRefPage + 1 : spreadObject.spreadRefPage;

			let pageNumText = rd.webtoon ? spreadObject.pageNumL + "" : spreadObject.pageNumL + ' ' + spreadObject.pageNumR;

			pageNumText = pageNumText.trim().replace(' ', '￨')

			//pageNumText = pageNumText.trim().replace(' ', '<span style="width: 10px; border-right:1px solid white">&nbsp;</span><span style="width:10px;">&nbsp;</span>')

			const out = [currentPage, pageNumText];

			return out;
		}

		//TODO con newpage calcoalto dalla funzione esterna e a ogni bar update, ripulire se serve questa cosa
		function jumpString() {

			const stringOut = `${mb.basePath}#bookread
			?library_id=${rd.libraryId}
			&series_id=${rd.seriesId}
			&book_id=${rd.bookId}
			&dir=${rd.direction}
			&pg=${rd.currentPage}`;

			if (!rd.incognito) {
				callAPI(null, `/api/v1/books/${rd.bookId}/read-progress`, 'PATCH', JSON.stringify({ page: rd.currentPage }), false)
					.catch(error => console.error('Error:', error));
			}

			if (obIsBookCompleted(rd.bookId)) {
				mb.offlineBooks[rd.bookId].page = rd.currentPage;
				if (offlineSession) mb.offlineBooks[rd.bookId].updated = true;
				obSaveTable();
			}

			return (stringOut);
		}

		function purgeLoading() {
			for (let i = rd.picLoadStack.length - 1; i >= 0; i--) {
				const item = rd.picLoadStack[i];
				item.hasSrc = false;
				item.uiPage.src = 'transparent.png';
				rd.picLoadStack.splice(i, 1); // Remove the element at index i
				printStack('P');
			}
			clearAllTimeouts();
		}

		// Thumbnail scrolling functions
		function thumbSmoothScrollWebtoon(container, targetScrollTop, duration = 500) {
			const start = container.scrollTop;
			const change = targetScrollTop - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollTop = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}
			requestAnimationFrame(animateScroll);
		}


		// Thumbnail scrolling functions
		function thumbSmoothScroll(container, targetScrollLeft, duration = 500) {
			const start = container.scrollLeft;
			const change = targetScrollLeft - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollLeft = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}
			requestAnimationFrame(animateScroll);
		}

		function centerThumbWebtoon(fast = false) {

			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInnerWT.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInnerWT.children[rd.currentSpreadIndex]; // n-th element (0-based index)

			if (targetElement) {
				const targetScrollTop = -thumbStripScrollContentWT.clientHeight / 2 + targetElement.offsetTop - thumbStripScrollContentWT.offsetTop + targetElement.clientHeight / 2;

				if (!fast) {
					thumbSmoothScrollWebtoon(thumbStripScrollContentWT, targetScrollTop, 300);
				} else {
					thumbStripScrollContentWT.scrollTop = targetScrollTop;
				};

				thumbStripInnerWT.children[rd.currentSpreadIndex].classList.add('current');
			}
		}

		function centerThumb(fast = false) {
			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInner.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInner.children[rd.currentSpreadIndex]; // n-th element (0-based index)

			if (targetElement) {
				const targetScrollLeft = -thumbStripScrollContent.clientWidth / 2 + targetElement.offsetLeft - thumbStripScrollContent.offsetLeft + targetElement.clientWidth / 2;

				if (!fast) {
					thumbSmoothScroll(thumbStripScrollContent, targetScrollLeft, 300);
				} else {
					thumbStripScrollContent.scrollLeft = targetScrollLeft;
				};

				thumbStripInner.children[rd.currentSpreadIndex].classList.add('current');
			}
		}

		function animShadowFWD(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0', opacity: '0.1' },
				{ [align]: '50%', width: rd.pageShadowWidthFWD, opacity: rd.pageShadowOpacityFWD },
				{ [align]: '100%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}
		//TODO Tutta quella stringa complicata col calc potrebbe essere sostituita conoscendo larghezza e altezza in pixel? boh
		function animShadowBWD(align, duration, ease) {
			return ([
				[{ [align]: '100%', width: '0', opacity: '0' },
				{ [align]: '75%', width: rd.pageShadowWidthBWD, opacity: rd.pageShadowOpacityBWD },
				{ [align]: '50%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function animLight(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0%', opacity: '0.5' },
				{ [align]: '25%', width: '20%', opacity: '1' },
				{ [align]: '50%', width: '30%', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function hideOldSpread(index, oldindex) {
			if (oldindex != index) spreadHide(oldindex);
		}

		function pageTurn(index, oldindex, turnDirection, force = false) {

			if (rd.webtoon) return;

			//Z-index control
			rd.spreadsArray[index].uiItem.style.zIndex = spreadsTotal() + 1;

			if (turnDirection == 'turn-right') {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.rtl ? oldindex : spreadsTotal() - oldindex;
			} else {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.rtl ? spreadsTotal() - oldindex : oldindex;
			}

			rd.dropShadowL.style.zIndex = rd.dropShadowR.style.zIndex = 0;

			const easeFull = 'cubic-bezier(0.42, 0, 0.58, 1)'
			const easeIn = 'cubic-bezier(0.42, 0, 0.71, 1)'
			const easeOut = 'cubic-bezier(0.29, 0.5, 0.58, 1)'

			// Animation preparation
			const turnTime = force ? 0 : rd.turnTime;
			const animData = { duration: turnTime, easing: easeFull, fill: 'forwards' };
			const animInstant = { duration: 0, easing: 'linear', fill: 'forwards' };

			const appearR2L_slideinL2R = [
				{ clipPath: 'inset(0 0 0 100%)', left: `-100%` },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearL2R = [
				{ clipPath: 'inset(0 100% 0 0)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const appearL2R_sildeinR2L = [
				{ clipPath: 'inset(0 100% 0 0)', left: `100%` },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearR2L = [
				{ clipPath: 'inset(0 0 0 100%)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const clipL2R = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 0 0 100%)' }
			];
			const clipR2L = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 100% 0 0)' }
			];
			const unFade = [
				{ filter: 'brightness(90%) sepia(10%)' },
				{ filter: 'brightness(100%) sepia(0%)' }
			];
			const fade = [
				{ filter: 'brightness(100%) sepia(0%)' },
				{ filter: 'brightness(90%) sepia(10%)' }
			];

			if (oldindex != index) rd.spreadsArray[oldindex].uiItem.animate(fade, { duration: rd.turnTime, easing: 'ease-in' });

			const startCover = ((rd.spreadsArray[oldindex].spreadKind == 'cover-page') || (rd.spreadsArray[oldindex].spreadKind == 'back-cover'));
			const stopCover = ((rd.spreadsArray[index].spreadKind == 'cover-page') || (rd.spreadsArray[index].spreadKind == 'back-cover'));

			//turnDirection can be 'turn-right' or 'turn-left'
			rd.foreEdgeL.style.transition = 'clip-path 0.3s';
			rd.foreEdgeR.style.transition = 'clip-path 0.3s';
			rd.dropShadowL.style.transition = 'margin 0.3s, opacity 0.5s';
			rd.dropShadowR.style.transition = 'margin 0.3s, opacity 0.5s';

			clipForeEdge = buildForeEdge(index, spreadsTotal())

			// Margins are defined as percentage of total width, so to have the correct size we divide
			// by mb.readerMaxRatio, then multiply by the drop aspect ratio (0.1) and apply the dropL and dropR proportion
			rd.dropShadowL.style.marginRight = (0.1 * clipForeEdge.dropL * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.marginLeft = (0.1 * clipForeEdge.dropR * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.opacity = 1;
			rd.dropShadowL.style.opacity = 1;

			rd.pageTurning = (turnDirection == 'turn-right' ? 'right' : 'left');

			if (!startCover && !stopCover) {
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer;
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					//TODO Why here uses rd.turntime instead of turntime? in this way it doesn't work when force = true? 
					leftPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));
				} else {
					rightPage.animate(appearR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R_sildeinR2L, animData);
					rightPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));
				}

				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;

			} else if (startCover && stopCover) {
				let startCoverPageL = rd.spreadsArray[oldindex].pageObjL.uiContainer
				let startCoverPageR = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let stopCoverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let stopCoverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.foreEdgeL.style.transition = 'clip-path 0s';
				rd.foreEdgeR.style.transition = 'clip-path 0s';
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;
				rd.dropShadowL.style.transition = 'margin 0s';
				rd.dropShadowR.style.transition = 'margin 0s';
				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;

				if (turnDirection == 'turn-right') {
					startCoverPageR.animate(clipL2R, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageR.animate(appearR2L, animInstant);
					rd.dropShadowR.animate([{ left: '100%' }], animInstant);
					rd.dropShadowL.animate([{ right: '50%' }], animInstant);
				} else {
					startCoverPageL.animate(clipR2L, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageL.animate(appearL2R, animInstant);
					rd.dropShadowL.animate([{ right: '100%' }], animInstant);
					rd.dropShadowR.animate([{ left: '50%' }], animInstant);
				}
			} else if (startCover) {
				// Start Page (cover or back cover)
				//let coverPage = rd.spreadsArray[oldindex].pageObj.uiContainer
				// Stop Page (mid spread)
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeR.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowR.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					rd.dropShadowR.animate(
						[{ left: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: 'forwards', delay: turnTime * 0.5 }
					);
				} else {
					rd.foreEdgeL.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowL.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					rightPage.animate(appearR2L, animData);
					leftPage.animate(appearL2R_sildeinR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					rd.dropShadowL.animate(
						[{ right: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: 'forwards', delay: turnTime * 0.5 }
					);
				}
				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;
			} else if (stopCover) {
				// Start Page (mid spread)
				let rightPage = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[oldindex].pageObjL.uiContainer
				// Stop Page (cover or back cover)
				let coverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let coverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeL.style.transition = 'clip-path 0s';
					leftPage.animate(clipL2R, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					coverPageR.animate(appearR2L_slideinL2R, animData);
					coverPageL.animate(appearL2R, animData);
					rd.dropShadowL.animate(
						[{ right: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: 'forwards' }
					);
				} else {
					rd.foreEdgeR.style.transition = 'clip-path 0s';
					rightPage.animate(clipR2L, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					coverPageL.animate(appearL2R_sildeinR2L, animData);
					coverPageR.animate(appearR2L, animData);
					rd.dropShadowR.animate(
						[{ left: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: 'forwards' }
					);
				}
			}

			clearTimeout(rd.turnTimeout);
			rd.turnTimeout = setTimeout(() => {
				rd.pageTurning = null;
			}, turnTime);
		}

		// Generic spread class definition, not valid for arrowleft and right in portrait mode!
		function getSpreadFocus(spreadIndex) {

			//TODO Check why when vertical mode and loading page from scratch it fails
			if (rd.spreadsArray[spreadIndex] == null) return;

			const spreadKind = rd.spreadsArray[spreadIndex].spreadKind;
			if (spreadKind === 'cover-page') {
				return rd.rtl ? 'focus-left-page' : 'focus-right-page';
			}
			if (spreadKind === 'back-cover') {
				return rd.rtl ? 'focus-right-page' : 'focus-left-page';
			}
			if (mb.readerHorizontal) {
				return 'focus-center';
			}
			return rd.rtl ? 'focus-right-page' : 'focus-left-page';
		}

		async function jumpToSpread(targetSpreadIndex, targetSpreadFocus = null, skipHistory = false, smoothWebtoon = false) {

			if (rd.isDraggingProgressBar) {
				updateProgressBar(targetSpreadIndex);
				return;
			}

			const localOldSpreadIndex = skipHistory ? 0 : rd.currentSpreadIndex;
			const localNewSpreadIndex = targetSpreadIndex;

			if (rd.nextBook != null) {
				if (targetSpreadIndex == spreadsTotal() - 1) {
					nextBookPanel.classList.remove('hidden')
				} else {
					if (!nextBookPanel.classList.contains('hidden')) nextBookPanel.classList.add('hidden')
				}
			}
			if (rd.prevBook != null) {
				if (targetSpreadIndex == 0) {
					prevBookPanel.classList.remove('hidden')
				} else {
					if (!prevBookPanel.classList.contains('hidden')) prevBookPanel.classList.add('hidden')
				}
			}

			if ((targetSpreadIndex < 0) || (targetSpreadIndex >= spreadsTotal()) || (!skipHistory && (localOldSpreadIndex == localNewSpreadIndex))) {
				return;
			}

			if (targetSpreadFocus == null) {
				targetSpreadFocus = getSpreadFocus(localNewSpreadIndex);
			}

			purgeLoading();

			rd.oldSpreadIndex = localOldSpreadIndex;
			rd.currentSpreadIndex = localNewSpreadIndex;

			if (isSectionHidden(readerContainer)) return;

			populateSpread(localNewSpreadIndex);
			/*
			console.log(rd.spreadsArray[localNewSpreadIndex].pageObjL);
			console.log(rd.spreadsArray[localNewSpreadIndex].pageObjR);
			
			rd.spreadsArray[localNewSpreadIndex].pageObjL.uiPage.src = rd.spreadsArray[localNewSpreadIndex].pageObjL.uiPage.blobUrl;
			rd.spreadsArray[localNewSpreadIndex].pageObjR.uiPage.src = rd.spreadsArray[localNewSpreadIndex].pageObjR.uiPage.blobUrl;
				*/
			// TODO
			// It always call spreadSetFocusSmoothDelay, because when in horiontal mode the target is 
			// center and there's no scrolling happening in that case, page turn is treated separately 
			// This adds a slight delay when jumping cover to cover
			spreadSetFocusSmoothDelay(targetSpreadFocus);

			spreadShow(localNewSpreadIndex);

			const turnDirectionCalc = (localNewSpreadIndex > localOldSpreadIndex) === rd.rtl ? 'turn-right' : 'turn-left';
			pageTurn(localNewSpreadIndex, localOldSpreadIndex, turnDirectionCalc, skipHistory)

			rd.webtoon ? centerThumbWebtoon() : centerThumb();

			if (rd.webtoon && !smoothWebtoon) {
				rd.webtoonScroll = true;

				const el = rd.spreadsArray[targetSpreadIndex].uiItem;
				const parent = el.parentElement;
				const offsetTop = el.offsetTop + 1; // 1px extra upwards

				parent.scrollTo({
					top: offsetTop,
					behavior: 'smooth'
				});

				setTimeout(() => {
					rd.webtoonScroll = false;
				}, 1000);
			}

			updateProgressBar();

			if (!skipHistory) history.replaceState(null, '', jumpString());
		}

		function jumpToSpreadSkipHistory(targetSpreadIndex) {
			jumpToSpread(targetSpreadIndex, null, true, false)
		}

		function jumpToSpreadSmoothWebtoon(targetSpreadIndex) {
			jumpToSpread(targetSpreadIndex, null, false, true)
		}

		// Reader UI Control Buttons
		function toggleMenu() {
			if (isSectionHidden(controlPanel)) {
				if (isStatusBar && !isSharpCornerIphone) {
					Capacitor.Plugins.StatusBar.show();
				}
				if (isNavBar) {
					Capacitor.Plugins.NavigationBar.show();
				}
			} else {
				if (isStatusBar) {
					Capacitor.Plugins.StatusBar.hide();
				}
				if (isNavBar) {
					Capacitor.Plugins.NavigationBar.hide();
				}
			}

			sectionToggle(controlPanel);
			touchPanel.classList.toggle('shrink');
		}

		function hideMenu() {
			sectionHide(controlPanel);
			touchPanel.classList.remove('shrink');
		}

		leftArrow.addEventListener('click', handleLeftArrow);
		rightArrow.addEventListener('click', handleRightArrow);
		leftLimit.addEventListener('click', handleLeftLimit);
		rightLimit.addEventListener('click', handleRightLimit);

		toLeftPage.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		toLeftPage.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			handleLeftArrow();
		});

		toRightPage.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		toRightPage.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			handleRightArrow();
		});

		openMenu.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		openMenu.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			toggleMenu();
		});

		// Seek function to move to specific spread based on click or drag
		function seek(event) {

			const progressBarWidth = readerProgressBar.offsetWidth;
			const clickX = event.clientX - readerProgressBar.getBoundingClientRect().left;
			const newProgressPercent = Math.min(1, Math.max(0, !rd.rtl ? clickX / progressBarWidth : (progressBarWidth - clickX) / progressBarWidth));

			jumpToSpread(Math.floor(newProgressPercent * (spreadsTotal() - 1)));
		}

		// Dragging the progress bar
		readerProgressBar.addEventListener('mousedown', (event) => {
			rd.isDraggingProgressBar = true;
			event.preventDefault();
			seek(event);
		});

		readerProgressBar.addEventListener('touchstart', (event) => {
			rd.isDraggingProgressBar = true;
			seek(event.touches[0]); // Use the first touch point
		});


		mainContainer.addEventListener('scroll', function () {

			if (!isSectionHidden(seriesMiniHeader)) {
				if ((mainContainer.scrollTop > 180) && (seriesMiniHeader.classList.contains('collapse'))) {
					seriesMiniHeader.classList.remove('collapse');
				} else if ((mainContainer.scrollTop < 200) && !seriesMiniHeader.classList.contains('collapse')) {
					seriesMiniHeader.classList.add('collapse');
				}
			}

			if (!isSectionHidden(stripGridContainer)) {
				if ((mainContainer.scrollTop < 5) && (stripGridHeaderContainer.classList.contains('collapse'))) {
					stripGridHeaderContainer.classList.remove('collapse');
				} else if ((mainContainer.scrollTop > 10) && !stripGridHeaderContainer.classList.contains('collapse')) {
					stripGridHeaderContainer.classList.add('collapse');
				}
			}
		});

		addClickPointerEvents(seriesMiniHeader, () => {
			mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
		});

		document.addEventListener('mousemove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event);
			}
		});
		document.addEventListener('touchmove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event.touches[0]);
			}
		});

		document.addEventListener('mouseup', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		document.addEventListener('touchend', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event.changedTouches[0]);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		//TODO: RIMUOVERE ASYNC DA QUI
		document.addEventListener('keydown', async (event) => {
			const readerVisible = !isSectionHidden(readerContainer);

			switch (event.key) {
				case 'ArrowLeft':
					if (readerVisible && !rd.webtoon) {
						event.preventDefault();
						handleLeftArrow();
					}
					break;
				case 'ArrowRight':
					if (readerVisible) {
						event.preventDefault();
						!rd.webtoon ? handleRightArrow() : handleCloseReader();
					}
					break;
				case 'ArrowDown':
					if (readerVisible) {
						event.preventDefault();
						!rd.webtoon ? handleCloseReader() : handleRightArrow();
					}
					break;
				case 'ArrowUp':
					if (readerVisible && rd.webtoon) {
						event.preventDefault();
						handleLeftArrow();
					}
					break;
				case 'Escape':
					if (readerVisible) {
						event.preventDefault();
						handleCloseReader();
					}
					break;
				/*
				case 'D':
					mb.screenAR = getScreenAR();
					mb.readerScale = mb.screenAR / mb.readerMaxRatio * 100 - 1;
					document.documentElement.style.setProperty('--mb-reader-scale', mb.readerScale);
					updateReaderOrientation()
					break;
				*/
				case ' ':
					if (readerVisible) {
						event.preventDefault();
						toggleMenu();
					}
					break;
				default:
					break;
			}
		});

		document.addEventListener('pointerup', (event) => {
			if (mb.currentlyScaled && !mb.currentlyScaled.contains(event.target)) {
				mb.currentlyScaled.classList.remove('scaled');
				mb.currentlyScaled.parentElement.classList.remove('top-pop');

				mb.currentlyScaled = null;
			}
		});

		document.addEventListener('pointerdown', (event) => {
			const scaler = event.target.closest('.touch-scaler');

			if ((mb.clickingTile != null) && (!scaler)) {
				mb.clickingTile = null;
			}

			if (mb.clickingTile != null) return;

			if ((mb.libMenuVisible != null) && (!filtersBar.contains(event.target))) {
				libMenuDown(mb.libraryMenuButtons[mb.libMenuVisible]);
				sectionToggle(filtersBar);
				mb.libMenuVisible = null;
			}

			if ((mb.swatchMenuVisible) && (!colorSwatchBar.contains(event.target)) && (!colorChanger.contains(event.target))) {
				mb.swatchMenuVisible = false;
				sectionHide(colorSwatchBar);
			}

		});

		//MB URL Parsing and LoadContent Function 
		function getHashAndParams() {
			const fullHash = window.location.hash.substring(1); // Remove leading '#'
			const [path, paramString] = fullHash.split('?'); // Separate path and parameters

			const params = paramString == undefined ? null : new URLSearchParams(paramString ?? '');
			return { path, params };
		}

		async function loadContent() {
			const { path, params } = getHashAndParams();

			await executeFade(1);
			dragbarOffReader();
			document.querySelectorAll('.section').forEach(section => sectionHide(section));
			document.querySelectorAll('.collector').forEach(item => item.remove());

			//In part useless because of the click outside events, but useful when loading an url
			sectionHide(filtersBar);
			sectionHide(colorSwatchBar);
			mb.libMenuVisible = null;
			mb.swatchMenuVisible = false

			clearLibrariesMenus();

			closeBookDetails();
			mb.screenAR = getScreenAR();

			mainLoader.classList.remove('hidden');

			switch (path) {
				case '':
				case 'dashboard':
					clearSearchField();

					setIncognito(false);
					if ((params == null) || (params.size == 0)) {
						await selectHome();
						if (mb.dashboardBin) {
							const y = dashboardElements[mb.dashboardBin].element.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop - 10;

							mainContainer.scrollTo({ top: y });
							mb.dashboardBin = '';
						}
					} else {
						dashboardAll(params.get('all'), params.get('page'));
					}
					break;
				case 'library':
					mb.dashboardBin = '';
					clearSearchField();

					setIncognito(false);
					await openLibrary(params.get('library_id'), params.get('series_id'));
					break;
				case 'series':
					clearSearchField();

					setIncognito(false);
					await openSeries(params.get('library_id'), params.get('series_id'), params.get('book_id'));
					break;
				case 'readlists':
					mb.dashboardBin = '';
					clearSearchField();

					setIncognito(false);
					await openReadlists();
					break;
				case 'readlistsitem':
					clearSearchField();

					setIncognito(false);
					await openReadlist(params.get('item_id'));
					break;
				case 'collections':
					mb.dashboardBin = '';
					clearSearchField();

					setIncognito(false);
					await openCollections();
					break;
				case 'collectionsitem':
					clearSearchField();

					setIncognito(false);
					await openCollection(params.get('item_id'));
					break;
				case 'search':
					setIncognito(false);
					searchInput.value = params.get('search_string');
					await performSearch(params.get('search_string'));
					break;
				case 'bookread':
					await openBookReader(params.get('library_id'), params.get('series_id'), params.get('book_id'), params.get('dir'), params.get('pg'));
					break;
				case 'offlinebooks':
					clearSearchField();

					setIncognito(false);
					await openOfflineBooks(params?.get('book_id'));
					break;
				default:
					console.log('no selection');
			}
			mainLoader.classList.add('hidden');

			await executeFade(0);
		}

		// This is the most important function, it updates the history and then passes the path to the loadContent function that does all the work
		// In MB the navigateTo function with a proper path form will open the different sections and activate various states.
		function navigateTo(path) {
			history.pushState(null, '', mb.basePath + path);
			loadContent();
		}

		const webtoonPageNumberObserver = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				if (rd.webtoonScroll) return;
				if (entry.isIntersecting) {
					jumpToSpreadSmoothWebtoon(entry.target.alt - 1)
				}
			});
		});

		// Lazy-loading setup with Intersection Observer
		const lazyLoadingObserver = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				if (entry.isIntersecting) {
					const img = entry.target;
					img.classList.add('loading');

					// TODO Set the actual src from lazySrc, check if needed
					const imageUrl = await fetchMedia(img.lazySrc);
					img.src = imageUrl;

					// Remove lazySrc to clean up
					delete img.lazySrc;

					img.addEventListener('load', () => {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
						setTimeout(() => {
							img.classList.remove('loaded');
							img.classList.add('finished');
						}, 1000);
					});
					if (img.complete) {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
					}
					// Stop observing this image
					observer.unobserve(img);
				}
			});
		});

		// Function to add lazy loading to an image
		function addLazyLoading(img) {
			lazyLoadingObserver.observe(img);
		}

		function removeLazyLoading(img) {
			lazyLoadingObserver.unobserve(img);
		}

		window.addEventListener('hashchange', loadContent);
		document.addEventListener('popstate', loadContent);

		document.querySelectorAll('.press-button').forEach(item => addPressEvents(item, pressDown, pressUp));
		document.querySelectorAll('.mini-buttons-2').forEach(item => addPressEvents(item, scaleDownDeep, scaleUp));

		searchInput.addEventListener('pointerdown', (event) => {
			event.stopPropagation();
		})

		let offlineSession = false;

		changeLoginTheme(mbPrefersDarkMode.matches ? true : false)

		sessionCheck()

		//MB Reader touch response fucntions
		function getTrueScale() {
			return window.innerWidth / window.visualViewport.width;
		}
		function getDerivedScale() {
			return rd.scale;
			return document.documentElement.clientWidth / window.visualViewport.width;
		}

		function enableTouchResponse(item, threshold, onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown) {
			item.SingleTouch = true;
			item.TouchStartX = 0;
			item.TouchStartY = 0;

			function handleTouchStart(event) {
				if (getDerivedScale() > 1.01) return;
				debugPrint("HandleTouchStart noscale")
				if (event.touches.length > 1) {
					item.SingleTouch = false; // Multiple touches: ignore for swipe
					return;
				}
				item.SingleTouch = true;
				item.TouchStartX = event.touches[0].clientX;
				item.TouchStartY = event.touches[0].clientY;
			}

			function handleTouchMove(event) {
				rd.touchLock = false;
				if (getDerivedScale() > 1.01 || !item.SingleTouch) return;
				const touchEndX = event.touches[0].clientX;
				const touchEndY = event.touches[0].clientY;

				const diffX = touchEndX - item.TouchStartX;
				const diffY = touchEndY - item.TouchStartY;

				if (Math.abs(diffX) > threshold && Math.abs(diffY) < threshold) {
					if (diffX > 0) {
						onSwipeRight?.();
					} else {
						onSwipeLeft?.();
					}
					item.SingleTouch = false; // Prevent repeat action on the same swipe
				} else if (Math.abs(diffY) > threshold && Math.abs(diffX) < threshold) {
					if (diffY > 0) {
						onSwipeDown?.();
					} else {
						onSwipeUp?.();
					}
					item.SingleTouch = false;
				}
			}

			item.addEventListener('touchstart', handleTouchStart);
			item.addEventListener('touchmove', handleTouchMove);
		}

		enableTouchResponse(touchPanel, 30, handleRightArrow, handleLeftArrow, null, handleCloseReader);
		enableTouchResponse(thumbStripWT, 20, handleLargeThumbs, handleSmallThumbs, null, null);
		enableTouchResponse(thumbStrip, 20, null, null, handleLargeThumbs, handleSmallThumbs);

		webtoonContainer.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});

		webtoonContainer.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			toggleMenu();
		});

		webtoonContainer.addEventListener('scroll', () => {
			rd.webtoonScrollRatio = webtoonRatio();
		})

		enableTouchResponse(webtoonContainer, 30, null, handleCloseReader, null, null);

	</script>
</body>

</html>