<!DOCTYPE html>
<html lang="en">

<head>
	<title>MangaBox</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="theme-color" content="black">

	<!--<link rel="icon" href="ab_16_alpha.png" type="image/png">-->
	<link rel="icon" href="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3C!-- Generator: Gravit.io --%3E%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' style='isolation:isolate' viewBox='0 0 160 160' width='160pt' height='160pt'%3E%3Cdefs%3E%3CclipPath id='_clipPath_YN17YSJ5FM1sjm2TADxOwkUODDUQiVcY'%3E%3Crect width='160' height='160'/%3E%3C/clipPath%3E%3C/defs%3E%3Cg clip-path='url(%23_clipPath_YN17YSJ5FM1sjm2TADxOwkUODDUQiVcY)'%3E%3Crect width='160' height='160' style='fill:rgb(0,0,0)' fill-opacity='0'/%3E%3Cpath d=' M 145 42 L 145 117 L 75 155 L 6 116 L 6 42 L 75 5 L 145 42 Z ' fill='rgb(255,255,255)'/%3E%3Cpath d='' fill-rule='evenodd' fill='rgb(235,235,235)'/%3E%3Cpath d=' M 38.542 24.55 L 61.749 56.429 L 20.291 34.337 L 10.67 39.496 L 10.236 40.31 L 64.368 69.155 L 60.578 71.175 L 65.281 80 L 70 77.485 L 70 79 L 80 79 L 80 77.485 L 84.719 80 L 89.422 71.175 L 85.632 69.155 L 139.764 40.31 L 138.964 38.81 L 130.104 34.127 L 88.251 56.429 L 111.605 24.349 L 102.673 19.627 L 80 50.772 L 80 7.643 L 75 5 L 70 7.681 L 70 50.772 L 47.438 19.78 L 38.542 24.55 Z ' fill-rule='evenodd' fill='rgb(188,8,43)'/%3E%3Ccircle vector-effect='non-scaling-stroke' cx='75.5' cy='77' r='50' fill='rgb(255,255,255)'/%3E%3Ccircle vector-effect='non-scaling-stroke' cx='75.5' cy='77' r='40' fill='rgb(188,8,43)'/%3E%3Cpath d=' M 145 42 L 145 117 L 75 155 L 6 116 L 6 42 L 75 79 L 145 42 Z ' fill='rgb(255,255,255)'/%3E%3Cpath d=' M 134.066 42.835 L 75 11.33 L 15.934 42.835 L 75 74.337 L 134.066 42.835 Z M 140 50.997 L 140 114 L 80 146.003 L 80 82.997 L 140 50.997 Z M 70 146.003 L 10 114 L 10 50.997 L 70 82.997 L 70 146.003 Z M 150 40 L 150 120 L 75 160 L 0 120 L 0 40 L 75 0 L 150 40 Z ' fill-rule='evenodd' fill='rgb(0,0,0)'/%3E%3Cpath d=' M 90 127.669 L 130 106.334 L 130 106.334 L 130 96.33 L 90 117.663 L 90 127.669 Z M 90 103.669 L 130 82.334 L 130 82.334 L 130 72.33 L 90 93.663 L 90 103.669 Z ' fill-rule='evenodd' fill='rgb(0,0,0)'/%3E%3Cpath d=' M 33 79.263 L 33 130.669 L 23 130.669 L 23 73.93 L 33 79.263 Z M 57 92.063 L 57 142.669 L 47 142.669 L 47 86.73 L 57 92.063 Z ' fill-rule='evenodd' fill='rgb(0,0,0)'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
	<link rel="apple-touch-icon" href="mangabox-logo-new-red.png">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="manifest" href="manifest.json">
	<link rel="stylesheet" type="text/css" href="auth.css">

	<link rel="stylesheet" href="afcss/all.min.css">

	<link rel="stylesheet" href="mangabox.css">
	<link rel="stylesheet" href="mangabox_reader.css">

</head>

<body>
	<div id="mainUI">
		<div id="menuBars">
			<div id="stickyContainer" class="hidden">
				<ul class="libraries-list buttons left-block">
					<li id="homeButton" title="MangaBox Home" class="library-item">
						<div class="thumbnail-wrapper">
							<img class="library-thumbnail" src="mangabox-logo-new.svg">
						</div>
						<div class="library-name">Home</div>
					</li>
				</ul>
				<ul id="librariesList" class="libraries-list"></ul>
				<ul class="libraries-list buttons options-block">
					<li id="libraryMenu" title="Library Menu" class="library-item disabled">
						<div class="thumbnail-wrapper">
							<span id="libraryMenuIcon" class="fa-solid fa-sliders glyph-dark"></span>
						</div>
					</li>
				</ul>
				<ul id="librariesRightBlock" class="libraries-list buttons right-block">
					<li id="themeChanger" title="Light/Dark Theme" class="library-item">
						<div class="thumbnail-wrapper">
							<span id="themeLabel" class="theme-label fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="colorChanger" title="Theme Color" class="library-item">
						<div class="thumbnail-wrapper">
							<span class="fa-solid fa-paint-roller glyph-dark mb-accent"></span>
						</div>
					</li>
					<li id="searchField" title="Search" class="library-item search-field">
						<div id="searchIcon" class="thumbnail-wrapper">
							<span class="fa-solid fa-magnifying-glass glyph-dark"></span>
						</div>
						<input id="searchInput" type="text" class="search-input" placeholder="Search...">
					</li>
					<li id="logOut" title="Logout" class="library-item">
						<div class="thumbnail-wrapper">
							<span class="fa-solid fa-arrow-right-from-bracket glyph-dark"></span>
						</div>
					</li>
				</ul>
			</div>
			<div id="extraMenuBar" class="hidden">
				<ul id="extraButtons" class="filters-list buttons"></ul>
			</div>
		</div>
		<div id="mainContainer">
			<div id="seriesHeader" class="section hidden"></div>

			<div id="seriesGrid" class="section hidden"></div>

			<div id="booksGrid" class="section hidden"></div>

			<div id="stripGridContainer" class="section hidden">
				<div id="stripGrid" class="strip-grid"></div>
				<div id="stripGridHeaderContainer" class="stripgrid-header-container">
					<div id="stripGridHeader" class="strip-header">
						<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading
					</div>
					<div id="stripGridRight" class="stripgrid-all">
						<span id="stripPrevPage" title="Previous Page" class="fa-solid fa-play fa-rotate-180 glyph-dark">
						</span><span id="stripNextPage" title="Next Page" class="fa-solid fa-play glyph-dark"></span>
					</div>
				</div>
			</div>

			<div id="seriesMiniHeader" class="section hidden collapse"></div>

			<div id="homeStripsContainer" class="section hidden"></div>

			<div id="searchStripsContainer" class="section hidden">
				<div class="strip-header-container">
					<div class="strip-header"><span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Series Results</div>
				</div>
				<div id="homeStripSeriesResults" class="series-results search-results"></div>

				<div class="strip-header-container">
					<div class="strip-header"><span class="fa-solid fa-book glyph-dark"></span>&nbsp;Books Results</div>
				</div>
				<div id="homeStripBooksResults" class="books-results search-results"></div>
			</div>

			<div id="bookDetailsContainer" class="section hidden"></div>

			<div id="blanker"></div>

		</div>

	</div>

	<div id="readerContainer" class="section hidden">
		<div id="readerBackground" class="hidden"></div>

		<div id="readerViewer"></div>

		<div id="readerOverlay">
			<div id="incognitoMark"></div>

			<div id="touchPanel">
				<div id="toLeftPage"></div>
				<div id="openMenu"></div>
				<div id="toRightPage"></div>
			</div>

			<div id="controlPanel" class="hidden">
				<div id="topControls">
					<span id="readerClose" title="Close Reader" class="reader-buttons fa-solid fa-xmark"></span>
					<span id="bookName"></span>
					<span id="readerIncognito" title="Incognito Reading" class="reader-buttons fa-solid fa-ghost"></span>
				</div>

				<div id="thumbStrip">
					<div id="thumbStripInner"></div>
				</div>
				<div id="thumbStripButton">
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				</div>

				<div id="bottomControls">
					<span id="leftArrow" class="reader-buttons fa-solid fa-caret-left"></span>
					<span id="leftLimit" class="bar-note"></span>
					<div id="readerProgressBar" onclick="seek(event)">
						<div id="readerProgress"></div>
						<div id="readerPage"></div>
					</div>
					<span id="rightLimit" class="bar-note"></span>
					<span id="rightArrow" class="reader-buttons fa-solid fa-caret-right"></span>
				</div>
			</div>
		</div>
	</div>

	<div id="loginScreen" class="auth-hidden">
		<div id="loginDialog" class="dialog">
			<img src="mangabox-logo-new.svg" width="80px" height="80px">
			<img src="mangabox-name.svg" width="280px" style="opacity:0.7; margin-bottom:5px;">

			<div class="input-wrapper" title="Server Address">
				<i class="fas fa-link"></i> <!-- Example icon for the base URL -->
				<input type="text" class="login-input" id="mbBaseUrl" placeholder="Komga Base URL (e.g., https://komga.example.com)">
			</div>

			<div class="input-wrapper" title="Username">
				<i class="fas fa-user"></i> <!-- Icon for username -->
				<input type="text" class="login-input" id="username" placeholder="Username">
			</div>

			<div class="input-wrapper" title="Password">
				<i class="fas fa-lock"></i> <!-- Icon for password -->
				<input type="password" class="login-input" id="password" placeholder="Password">
			</div>

			<div class="login-buttons">
				<div class="remember-me-container">
					<input type="checkbox" id="rememberMe" class="remember-me-checkbox">
					<label for="rememberMe" class="remember-me-label">Remember Me</label>
				</div>
				<button class="login-button" onclick="login()">Login</button>
			</div>

			<p id="loginError" class="error-message auth-hidden">Invalid credentials or server URL, please try again.</p>
		</div>
	</div>



	<div id="debuggerObj"></div>

	<script src="auth.js"></script>

	<script>

		//MB General Functions 
		function testpr(text) {
			debuggerObj.innerText = debuggerObj.innerText + text;
		}

		function addItem(itemkind, properties) {
			return Object.assign(document.createElement(itemkind), properties);
		}

		//MB Local Storage Loading 

		// Theme settings
		let mbAccentColor = Number(localStorage.getItem('mbAccentColor')) ?? 0;
		let mbDarkTheme = (Number(localStorage.getItem('mbDarkTheme')) ?? 0) == 1;

		// Library filters
		let mbLibraryFilters = JSON.parse(localStorage.getItem('mbLibraryFilters') || '{}');

		// Authentication data
		const mbAuthHeader = localStorage.getItem('mbAuthHeader');
		const mbBaseUrl = localStorage.getItem('mbBaseUrl');
		const mbRememberMe = localStorage.getItem('mbRememberMe');

		rememberMe.checked = (mbRememberMe == 'true');

		//Questa cosa qui spostarla quando uno chiude la finestra!
		if (mbRememberMe != 'true') {
			localStorage.removeItem('mbAuthHeader');
		};

		const basePath = ''; //'/mangabox/';

		function getScreenAR() {
			return (window.innerWidth / window.innerHeight);
		}

		let screenAR = getScreenAR();
		let readerMaxRatio = 1;
		let readerHorizontal = true;
		let fitSinglePage = true;
		let dashboardBin = "";
		/*
			When an item from a bin is opened, the dashboardBin is set, so when the dashboard is reloaded
			it reads this variable, if it is not "" the focus is shifted to the bin, and the variable is cleared.
			In this way subsequent clicks on dashboard button will load the top position.
			This variable is cleared whenever a new "Navigate To" is called that is not to dashboard
		*/

		//MB Theme Management 

		const swatches = getComputedStyle(document.documentElement)
			.getPropertyValue('--mb-swatches')
			.match(/hsl\([^)]*\)/g)
			.map(swatch => swatch.match(/(\d+%?)/g));

		function changeAccent(id) {
			['--mb-h', '--mb-s', '--mb-l'].forEach((varName, index) => {
				document.documentElement.style.setProperty(varName, swatches[id][index]);
			});
			document.documentElement.style.setProperty('--mb-h-deg', swatches[id][0] + "deg");
			/*
			// Custom colored top bar
			const metaThemeColor = document.querySelector('meta[name="theme-color"]');
			metaThemeColor.setAttribute('content', `hsl(${swatches[id][0]},100%,10%)`);
			*/
			localStorage.setItem('mbAccentColor', mbAccentColor)
		}

		function swapThemeClass(classSelector, lightClass, darkClass, toDark) {
			Array.from(document.getElementsByClassName(classSelector)).forEach((item) => {
				if (!item.classList.contains('no-theme-icon')) {
					item.classList.remove(toDark ? lightClass : darkClass);
					item.classList.add(toDark ? darkClass : lightClass);
				}
			});
		}

		function changeTheme(toDark) {
			// Set css theme to dark or light
			document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');

			// Change fa icons for light or dark theme
			swapThemeClass('theme-label', 'fa-sun', 'fa-moon', toDark);
			swapThemeClass('fa-file', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-calendar', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-clock', 'fa-regular', 'fa-solid', toDark);

			// Save theme setting in local storage
			localStorage.setItem('mbDarkTheme', toDark ? 1 : 0)
		}

		// Show/Hide section functions
		function sectionHide(item) {
			item.classList.add('hidden');
		}
		function sectionShow(item) {
			item.classList.remove('hidden');
		}
		function sectionToggle(item) {
			item.classList.toggle('hidden');
		}
		function isSectionHidden(item) {
			return (item.classList.contains('hidden'));
		}

		// Show/Hide reader pages/spreads
		function spreadHide(item) {
			item.classList.add('hidden-spread');
		}
		function spreadShow(item) {
			item.classList.remove('hidden-spread');
		}
		function isSpreadHidden(item) {
			return (item.classList.contains('hidden-spread'));
		}

		// Event listeners for main menu buttons
		libraryMenu.addEventListener('click', () => {
			sectionToggle(extraMenuBar);
		});

		colorChanger.addEventListener('click', () => {
			mbAccentColor = (mbAccentColor + 1) % swatches.length;
			changeAccent(mbAccentColor);
		});

		logOut.addEventListener('click', async () => {

			//await callAPI('/api/logout','POST');
			/*fetch(`${mbBaseUrl}/api/logout`, {
				method: 'POST',
				credentials: "include", // Required to send cookies!
				headers: {
					'Authorization': mbAuthHeader,
					'skip_zrok_interstitial': '1',
				}
			});
			*/
			sectionHide(stickyContainer);
			sectionShow(blanker);
			localStorage.removeItem('mbAuthHeader');
			history.pushState(null, '', basePath);
			location.reload(true);
		})

		themeChanger.addEventListener('click', () => {
			mbDarkTheme = !mbDarkTheme;
			changeTheme(mbDarkTheme);
		})

		searchInput.addEventListener('keydown', (event) => {
			if (event.key === 'Enter') {
				dashboardBin = '';
				if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
			}
		});

		searchIcon.addEventListener('click', () => {
			if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
		})

		//MB Search Functions 

		function timeSplit(inTime) {
			let outTime = inTime ?? "1111";
			outTime = outTime.replace('TBD', '9999').split('-');
			if (outTime.length == 1) outTime.push(outTime[0]);
			return outTime
		}

		async function performSearch(searchString) {
			libraryHighlight('searchField');

			if (searchString.includes('y:')) {

				//const unFilteredSeries = await callAPI(`/api/v1/series?page=0&unpaged=true&sort=metadata.titleSort,asc`);
				const unFilteredSeries = await callAPI(
					`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
					'POST', `{"condition": {"allOf": []}}`
				);
				const dataArray = unFilteredSeries.content;
				const searchYear = timeSplit(searchString.split('y:')[1].split(' ')[0]);

				let start = [];
				let stop = [];
				let filterArray = [];

				for (let i = 0; i < dataArray.length; i++) {
					if (dataArray[i].metadata.alternateTitles.length == 0) continue;
					const dateArray = dataArray[i].metadata.alternateTitles.find(item => item.label === 'Time').title.replace('TBD', '5000').split('-');
					start.push(Number(dateArray[0]));
					stop.push(Number(dateArray[1] ?? dateArray[0]));

					filterArray.push(!((start[i] > Number(searchYear[1])) || (stop[i] < Number(searchYear[0]))));
				}

				const filteredSeries = dataArray.filter((item, index) =>
					filterArray[index]
				);
				displaySeries(filteredSeries, homeStripSeriesResults);
				focusItem('top');
				setTimeout(updateSliderMax, 10);
				sectionShow(searchStripsContainer);

				return
			}

			//const unFilteredSeries = await callAPI(`/api/v1/series?page=0&unpaged=true&sort=metadata.titleSort,asc`);
			const unFilteredSeries = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredSeries = unFilteredSeries.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.titleSort.toLowerCase().includes(searchString) ||
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title.toLowerCase().includes(searchString)
				)
			);
			displaySeries(filteredSeries, homeStripSeriesResults);
			focusItem('top');

			//const unFilteredBooks = await callAPI(`/api/v1/books?page=0&unpaged=true&sort=metadata.titleSort,asc`);
			const unFilteredBooks = await callAPI(
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.summary.toLowerCase().includes(searchString) ||
				item.metadata.tags.some(
					tagIn => tagIn.toLowerCase().includes(searchString)
				)
			);
			displayBooks(filteredBooks, homeStripBooksResults, 'compact', 'top');

			setTimeout(updateSliderMax, 10);
			sectionShow(searchStripsContainer);
		}

		//MB Library Filtering 

		const filterTable = {
			sorting: {
				name: 'sorting',
				selected: 0,
				iconClass: 'fa-solid fa-heading glyph-dark',
				item: null,
				icon: null,
				caption: null,
				title: 'Sort items',
				switches: [
					{
						name: 'a_to_z',
						caption: 'By title',
						iconClass: 'fa-solid fa-arrow-down-a-z glyph-dark',
						sortFunction: (a, b) => a.mbSeriesTitle.localeCompare(b.mbSeriesTitle)
					}, {
						name: 'z_to_a',
						caption: 'By title',
						iconClass: 'fa-solid fa-arrow-down-z-a glyph-dark',
						sortFunction: (a, b) => b.mbSeriesTitle.localeCompare(a.mbSeriesTitle)
					}, {
						name: '9_to_1',
						caption: 'By start',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)) - (Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)))
					}, {
						name: '1_to_9',
						caption: 'By start',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)) - (Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)))
					}, {
						name: '9_to_1',
						caption: 'By end',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)) - (Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)))
					}, {
						name: '1_to_9',
						caption: 'By end',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)) - (Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)))
					}
				],
			},
			filter_by_read: {
				name: 'filter_by_read',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by read status',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-circle-half-stroke glyph-dark',
						filterFunction: (a) => true
					}, {
						name: 'unread',
						caption: 'Unread',
						iconClass: 'fa-regular fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == false)
					}, {
						name: 'read',
						caption: 'Read',
						iconClass: 'fa-solid fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == true)
					}
				],
			},
			filter_by_direction: {
				name: 'filter_by_direction',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by reading direction',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-arrow-right-arrow-left glyph-dark',
						filterFunction: (a) => true

					}, {
						name: 'l_to_r',
						caption: 'L to R',
						iconClass: 'fa-solid fa-arrow-right glyph-dark',
						filterFunction: (a) => (a.mbSeriesLTR == true)

					}, {
						name: 'r_to_l',
						caption: 'R to L',
						iconClass: 'fa-solid fa-arrow-left glyph-dark',
						filterFunction: (a) => (a.mbSeriesLTR == false)
					}
				],
			},
			filter_by_language: {
				name: 'filter_by_language',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by language',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-earth-europe glyph-dark',
						filterFunction: (a) => true
					}
				],
			},
		};

		async function buildLanguageList() {
			const languageList = await callAPI(`/api/v1/languages`);
			languageList.forEach(item => {
				filterTable.filter_by_language.switches.push({
					name: item,
					caption: item.toUpperCase(),
					iconClass: "fa-solid fa-square glyph-dark glyph-flag-button",
					iconStyle: `background-image:url('flags/${item}.svg`,
					filterFunction: (a) => a.mbSeriesLanguage == item
				})
			});
		};

		//buildLanguageList();

		const filterButtons = [
			filterTable.sorting,
			filterTable.filter_by_read,
			filterTable.filter_by_direction,
			filterTable.filter_by_language
		];

		function saveLibraryFilters() {
			const { path, params } = parseHashAndParams();
			const libraryId = params.get('library_id');
			let filterOut = {};
			filterButtons.forEach(button => {
				filterOut[button.name] = button.selected;
			});
			mbLibraryFilters[libraryId] = filterOut;
			localStorage.setItem('mbLibraryFilters', JSON.stringify(mbLibraryFilters));
		}

		function fetchLibraryFilters(libraryId) {
			filterValues = mbLibraryFilters[libraryId];
			if (filterValues) {
				filterButtons.forEach(button => {
					filterTable[button.name].selected = filterValues[button.name];
				});
				applyLibraryFilters()
			}
		}

		async function applyLibraryFilters() {
			const divs = Array.from(seriesGrid.children);

			divs.forEach(div => {
				div.infilter = true;
			});

			const isFiltered = Object.values(filterButtons).reduce((sum, item) => sum + (item.selected || 0), 0);
			libraryMenuIcon.className = isFiltered == 0 ? "fa-solid fa-sliders glyph-dark" : "fa-solid fa-sliders mb-accent glyph-dark"

			filterButtons.forEach(button => {
				button.icon.innerHTML = `<span style="${button.switches[button.selected].iconStyle}" class="${button.switches[button.selected].iconClass}${button.selected != 0 ? ' mb-accent' : ''}"></span>`;
				button.caption.innerHTML = `${button.switches[button.selected].caption}`;

				if (button.switches[button.selected].sortFunction) {
					divs.sort((a, b) => {
						return button.switches[button.selected].sortFunction(a, b);
					});
					divs.forEach((item, index) => {
						item.style.order = index;
					});
				} else {
					divs.forEach((div) => {
						div.infilter = div.infilter && button.switches[button.selected].filterFunction(div);
					});
				}
			});
			divs.forEach((div) => {
				div.style.display = div.infilter ? '' : 'none';
			});
		}

		// Build filter buttons items

		filterButtons.forEach(button => {
			button.item = addItem('li', {
				className: `filter-item`,
				title: button.title,
			});
			button.icon = addItem('div', {
				className: `thumbnail-wrapper`,
				innerHTML: `<span style="${button.switches[0].iconStyle}" class="${button.switches[0].iconClass}"></span>`
			});
			button.caption = addItem('div', {
				className: `library-name`,
				innerHTML: `${button.switches[0].caption}`
			});
			button.item.appendChild(button.icon);
			button.item.appendChild(button.caption);
			extraButtons.appendChild(button.item);
			button.item.addEventListener('click', async () => {
				button.selected = ((button.selected + 1) % button.switches.length);
				await executeFade(1);
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			})
		});

		extraButtons.appendChild(addItem('li', {
			title: 'Reset filters and sorting',
			className: `filter-item`,
			innerHTML: `<div class="thumbnail-wrapper">
								<span class="fa-solid fa-arrows-rotate fa-flip-horizontal glyph-dark"></span>
							</div>`,
			onclick: async () => {
				await executeFade(1);
				filterButtons.forEach(button => {
					button.selected = 0;
				});
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			}
		}));

		function updateReaderOrientation() {
			let newScreenAR = getScreenAR();

			if (isSectionHidden(readerContainer)) {
				screenAR = newScreenAR;
				readerHorizontal = newScreenAR / readerMaxRatio > rd.thresholdRatio;
			} else {
				let newReaderHorizontal = (newScreenAR / readerMaxRatio > rd.thresholdRatio);
				if (newReaderHorizontal != readerHorizontal) {

					screenAR = newScreenAR;
					if (newReaderHorizontal || rd.uiSpreads[rd.currentSpreadIndex].singlePage) {
						spreadSetFocus('focus-center', true);
					} else {
						spreadSetFocus(rd.ltr ? 'focus-left-page' : 'focus-right-page', true);
					}
					readerHorizontal = newReaderHorizontal;
				}
			}
		}

		// Set the slider max value based on the scroll width
		function updateSliderMax() {
			if (isSectionHidden(homeStripsContainer)) return;

			Object.entries(dashboardElements).forEach(([name, item]) => {

				item.scrollInput.max = item.homeStrip.scrollWidth - item.homeStrip.clientWidth;
				const isOverflowing = item.homeStrip.scrollWidth > item.homeStrip.clientWidth;

				item.scrollInput.style.display = isOverflowing ? 'block' : 'none';

				const visibleRatio = item.homeStrip.clientWidth / item.homeStrip.scrollWidth;
				const thumbWidth = (100 * visibleRatio);

				item.scrollInput.style.setProperty('--thumb-width', `${thumbWidth}%`);
			});
		};

		function stepPageChange(increment) {
			const { path, params } = parseHashAndParams();
			navigateTo('#dashboard?all=' + params.get('all') + '&page=' + (parseInt(params.get('page')) + increment));
		}

		stripPrevPage.addEventListener('click', () => stepPageChange(-1));
		stripNextPage.addEventListener('click', () => stepPageChange(1));

		let resizeTimeout;

		function updateStickyMenu() {
			const containerWidth = mainUI.getBoundingClientRect().width;
			if (containerWidth - libSizer.rightmin - libSizer.large >= 0) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-small');
			} else if (containerWidth - libSizer.rightmin - libSizer.medium >= 0) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-medium');
			} else {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-small');
			};
		}


		window.addEventListener('resize', () => {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				updateStickyMenu();
				updateSliderMax();
				updateReaderOrientation();
			}, 250);
		});

		function fixZoomOnPWA() {
			let metaViewport = document.querySelector('meta[name="viewport"]');
			if (!metaViewport) return;

			// Temporarily disable zoom
			metaViewport.content = "width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no";

			setTimeout(() => {
				// Restore zoom capability after layout stabilizes
				metaViewport.content = "width=device-width, initial-scale=1, maximum-scale=5, minimum-scale=1";
			}, 50); // Adjust timeout as needed
		}

		window.addEventListener("orientationchange", fixZoomOnPWA);
		document.addEventListener("visibilitychange", fixZoomOnPWA);
		window.addEventListener("pageshow", (event) => {
			if (event.persisted) fixZoomOnPWA();
		});
		// Fade in and Fade out routines
		function wait(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		async function executeFade(val) {
			blanker.style.opacity = val;
			await wait(100);
		}

		//MB API Call Function 
		async function callAPI(API_url, method = 'GET', body = null, returnval = true) {
			try {
				const response = await fetch(`${mbBaseUrl}${API_url}`, {
					method: method,
					headers: {
						'Authorization': mbAuthHeader,
						'Content-Type': 'application/json',
						'skip_zrok_interstitial': '1' // Add header to skip interstitial
					},
					body: body
				});

				if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);

				if (returnval) {
					const output = await response.json();
					return output;
				}
			} catch (error) {
				console.error('Fetch libraries error:', error);
			}
		}


		//MB Media Cache 
		const mediaCache = new Map();
		const CACHE_LIMIT = 250; // Maximum number of cached items

		async function fetchMedia(url) {
			if (mediaCache.has(url)) {
				// Move the accessed item to the end to mark it as recently used
				const value = mediaCache.get(url);
				mediaCache.delete(url);
				mediaCache.set(url, value);
				return value;
			}

			try {
				const response = await fetch(url, {
					method: 'GET',
					headers: {
						'Authorization': mbAuthHeader,
						'skip_zrok_interstitial': '1' // Add header to skip interstitial
					}
				});

				if (response.ok) {
					const blob = await response.blob();
					const objectURL = URL.createObjectURL(blob);

					// Add to cache and enforce size limit
					mediaCache.set(url, objectURL);
					if (mediaCache.size > CACHE_LIMIT) {
						// Remove the oldest entry
						const oldestKey = mediaCache.keys().next().value;
						URL.revokeObjectURL(mediaCache.get(oldestKey)); // Revoke object URL
						mediaCache.delete(oldestKey);
					}

					return objectURL;
				} else {
					console.error(`Failed to load media from ${url}`, response.status);
					return 'fallback-image.jpg';
				}
			} catch (error) {
				console.error(`Error fetching media: ${error.message}`);
				return 'fallback-image.jpg';
			}
		}


		// Function to clear the cache entirely
		function clearMediaCache() {
			for (const objectURL of mediaCache.values()) {
				URL.revokeObjectURL(objectURL);
			}
			mediaCache.clear();
		}

		async function setReadStatus(seriesId, bookId, read, item, format = null) {
			if (bookId == null) {
				await callAPI(`/api/v1/series/${seriesId}/read-progress`, read ? 'POST' : 'DELETE', null, false);
				const seriesData = await callAPI(`/api/v1/series/${seriesId}`);
				buildSeriesItem(item, seriesData, null);
			} else {
				await callAPI(`/api/v1/books/${bookId}/read-progress`, read ? 'PATCH' : 'DELETE', read ? JSON.stringify({ completed: true }) : null, false);
				const { path, params } = parseHashAndParams();
				if (path == 'dashboard' || path == '') {
					const oldTop = mainContainer.scrollTop;
					await Promise.all(
						Object.entries(dashboardElements).map(async ([name, item]) => {
							const resultsObject = await item.getItems(0, 20);
							//item.element.style.display = resultsObject.empty ? 'none' : 'block';
							item.showItems(resultsObject.content, item.homeStrip);
						})
					);
					setTimeout(updateSliderMax, 10);
					mainContainer.scrollTop = oldTop;
				} else {
					const bookData = await callAPI(`/api/v1/books/${bookId}`);
					buildBookItem(item, bookData, format, null);
				}
			}
		}

		let libSizer = {};

		// Function that fetches the libraries list, sort it by name, then calls displayLibraries to show the fetched libraries
		async function fetchLibraries() {
			const libGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-gap'));
			const libSmall = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-button-size'));
			let libLarge = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-large'));

			const libraries = await callAPI('/api/v1/libraries');
			libraries.sort((a, b) => a.name.localeCompare(b.name));
			await displayLibraries(libraries);

			const maxWidth = Array.from(librariesList.childNodes)
				.map(item => item.childNodes[1].getBoundingClientRect().width + libSmall)
				.reduce((max, width) => Math.max(max, width), 0);

			if (maxWidth > libLarge) {
				libLarge = Math.ceil(maxWidth)
				document.documentElement.style.setProperty('--mb-library-large', libLarge + "px");
			}

			const libNum = libraries.length;
			libSizer.large = libGap + libLarge + libGap + libSmall + libGap + libNum * (libLarge + libGap);
			libSizer.medium = libGap + libLarge + libGap + libSmall + libGap + libNum * (libSmall + libGap);
			libSizer.rightmin = libSmall * 3 + libGap * 3 + 150;
			updateStickyMenu();
		}


		// This function is called when a library is selected, it manages the library menu and library naming in the URL
		function libraryHighlight(libraryId) {
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('highlighted'));
			document.getElementById(libraryId).classList.add('highlighted');
		}

		async function getFilteredSeries(filterTitle, serieId) {
			//const unFilteredSeries = await callAPI(`/api/v1/series?page=0&unpaged=true&sort=metadata.titleSort,asc`);
			const unFilteredSeries = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredItems = unFilteredSeries.content.filter(item =>
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title === filterTitle
				)
			);

			displaySeries(filteredItems, seriesGrid);
			focusItem('top');

		}

		//MB Touch And Hover Scaler 
		let currentlyScaled = null;

		function noPointerDown(item) {
			item.addEventListener('pointerup', (event) => {
				event.stopPropagation();
			})
		}

		function addTouchScaler(item, execute) {
			item.addEventListener('pointerup', async (event) => {
				if (event.pointerType === 'touch') {
					// TOUCH DEVICE
					if (currentlyScaled !== item) {
						if (currentlyScaled) {
							currentlyScaled.classList.remove('scaled');
						}
						item.classList.add('scaled');
						currentlyScaled = item;
						event.preventDefault();
					} else {
						item.classList.remove('scaled');
						currentlyScaled = null;
						execute();
					}
				} else if (event.button == 0) {
					// MOUSE DEVICE
					if (!item.classList.contains('scaled')) {
						item.classList.add('scaled');
						currentlyScaled = item;
					} else {
						item.classList.remove('scaled');
						currentlyScaled = null;
						execute();
					}
				}
			});

			item.addEventListener('mouseenter', () => {
				// Added this to unselect pre-scaled book

				if (currentlyScaled != null) {
					currentlyScaled.classList.remove('scaled');
					//currentlyScaled = null; //TODO check, This was removed but maybe it was needed?
				}

				item.classList.add('scaled');
			});

			item.addEventListener('mouseleave', () => {
				item.classList.remove('scaled');
			});
		}

		//MB Series Items Creation
		async function buildSeriesItem(item, serie, target) {
			//item.firstChild.remove();
			if (item.childNodes[0]) {
				item.childNodes[0].remove();
			}

			item.title = 'Open series';

			const seriesItem = addItem('div', {
				className: 'series-item'
			});
			const LNG = ((serie.metadata.language != 'en') ? `<span style="background-image:url('flags/${serie.metadata.language}.svg'" class="fa-solid fa-square-full glyph-dark glyph-flag"></span>` : '');
			const LTR = serie.metadata.readingDirection == 'RIGHT_TO_LEFT' ? '' : '<span class="fa-solid fa-clapperboard fa-rotate-270 glyph-dark"></span>';
			const spacer = ((LNG != '') && (LTR != '')) ? '&nbsp;' : '';

			const seriesTitle = addItem('div', {
				innerHTML: `
								<div class="title-row data-row top-row">
									<div style="flex-grow:1" class="series-title">${serie.metadata.title}</div>
									<div class="glyph-dark" style="text-align:right">${LTR}</div>
										${spacer}
									<div class="glyph-div" style="text-align:right">${LNG}</div>
								</div>`
			});

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper'
			});

			const seriesThumbnail = addItem('img', {
				className: 'series-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mbBaseUrl}/api/v1/series/${serie.id}/thumbnail`,
				alt: serie.metadata.title
			});

			addLazyLoading(seriesThumbnail);

			const seriesFader = addItem('div', {
				className: 'series-fader'
			});

			const seriesOverlay = addItem('div', {
				className: 'series-overlay'
			});

			const seriesStatus = addItem('div', {
				className: 'series-status'
			});

			const unreadCount = serie.booksUnreadCount;

			if (unreadCount > 0) {
				const unreadCountBadge = addItem('div', {
					className: 'unread-count',
					innerHTML: `<span>${unreadCount}</span>`
				});
				seriesStatus.appendChild(unreadCountBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark series as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			markAsRead.addEventListener('click', async (event) => {
				event.stopPropagation();
				await setReadStatus(serie.id, null, true, item);
			})
			noPointerDown(markAsRead);

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark series as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			markAsUnread.addEventListener('click', async (event) => {
				event.stopPropagation();
				await setReadStatus(serie.id, null, false, item);
			})
			noPointerDown(markAsUnread);

			// Find alternate title with label 'Time'
			const altTitle = getAltTitles(serie);

			// Fetch and display the number of books and alternate title
			const bookCount = serie.booksCount;
			const infoRow = addItem('div', {
				className: 'data-row info-row'
			});

			const timeLabel = addItem('span', {
				innerHTML: `<span class='${mbDarkTheme ? 'fa-solid' : 'fa-regular'} fa-calendar glyph-dark'></span>&nbsp;${altTitle.time}`,
				className: 'red search-trigger',
				title: `Filter time: ${altTitle.time}`
			});
			timeLabel.addEventListener('click', async (event) => {
				event.stopPropagation();
				if (target.binName) dashboardBin = target.binName;
				navigateTo(`#search?search_string=y:${altTitle.time}`);
			});
			noPointerDown(timeLabel);

			const booksLabel = addItem('span', {
				innerHTML: `<span class='fa-solid fa-book glyph-dark'></span>&nbsp;${bookCount}`
			});

			const artistRow = addItem('div', {
				className: 'data-row artist-row'
			});

			if (altTitle.story != altTitle.art) {

				const storyLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-pen-to-square glyph-dark'></span>&nbsp;${altTitle.story}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.story}`
				});

				const artLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-palette glyph-dark'></span>&nbsp;${altTitle.art}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.art}`
				});

				artistRow.appendChild(storyLabel);
				artistRow.appendChild(artLabel);
				storyLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target.binName) dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
				});
				artLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target.binName) dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.art.toLowerCase()}`);
				});
				noPointerDown(artLabel);
				noPointerDown(storyLabel);
			} else {
				const artistLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-user glyph-dark'></span>&nbsp;${altTitle.story}`,
					title: `Filter artist: ${altTitle.story}`,
					className: 'red data-label search-trigger'
				});
				artistRow.appendChild(artistLabel);
				artistLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target.binName) dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
					//getFilteredSeries(altTitle.story, serie.id);
				});
				noPointerDown(artistLabel);
			}

			item.mbSeriesTitle = serie.metadata.title ?? "";

			item.mbSeriesStart = timeSplit(altTitle.time)[0];
			item.mbSeriesStop = timeSplit(altTitle.time)[1];

			item.mbSeriesRead = (unreadCount == 0);
			item.mbSeriesLTR = (serie.metadata.readingDirection == "LEFT_TO_RIGHT");
			item.mbSeriesLanguage = serie.metadata.language;

			seriesItem.append(
				thumbnailWrapper,
				seriesTitle,
				infoRow,
				artistRow
			);
			thumbnailWrapper.append(
				seriesThumbnail,
				seriesFader,
				seriesOverlay,
				seriesStatus
			);
			seriesOverlay.append(
				markAsRead,
				markAsUnread
			);
			infoRow.append(
				timeLabel,
				booksLabel
			);

			addTouchScaler(seriesItem, () => {
				if (target.binName) dashboardBin = target.binName;
				navigateTo(`#series?library_id=${serie.libraryId}&series_id=${serie.id}`)
			});

			item.appendChild(seriesItem);
		}

		// Creates and populates the series grid with the data from the series array.
		async function displaySeries(series, target) {

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {

				const seriesContainer = document.createElement('div');
				seriesContainer.classList.add('series-container'); //XXX was ending with , 'fade-in');
				seriesContainer.id = serie.id;

				buildSeriesItem(seriesContainer, serie, target);

				target.appendChild(seriesContainer);
			});

			sectionShow(target); //XXX serve un fade qui???
		}

		// Function that fetches all the series list within a library, sorted by name, then calls displaySeries to show the fetched series
		async function fetchAllSeries(libraryId) {
			let allSeries = [];
			//const allSeriesPage = await callAPI(`/api/v1/series?library_id=${libraryId}&page=0&unpaged=true&sort=metadata.titleSort,asc`);
			const allSeriesPage = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"libraryId": {"operator": "is","value": "${libraryId}"}}}`
			);
			allSeries = allSeriesPage.content;
			// now it gets the series sorted by name so no need to elaborate the sorting, but for custom sorting based for example on title time?
			//allSeries.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
			return (allSeries);
		}

		function focusItem(focus) {
			if (focus == 'top') {
				mainContainer.scrollTo({ top: 0 });
			} else if (focus) {
				var item = document.getElementById(focus);
				const yOffset = -150;
				const y = item.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop + yOffset;

				mainContainer.scrollTo({ top: y });

				currentlyScaled = item.firstChild;
				item.firstChild.classList.add('scaled');
			}
		}

		// Compose function that opens a specific library based on it ID
		async function openLibrary(libraryId, seriesId) {
			await libraryHighlight(libraryId);		// Triggers and manages the library menu
			const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library
			await displaySeries(allSeries, seriesGrid);
			fetchLibraryFilters(libraryId);
			focusItem(seriesId || 'top');
			libraryMenu.classList.remove('disabled');
		}

		function displayLibraries(libraries) {
			librariesList.innerHTML = '';

			Array.from(libraries).forEach((library, index) => {
				const listItem = document.createElement('li');
				listItem.classList.add('library-item');
				listItem.id = library.id;

				const thumbnailWrapper = document.createElement('div');
				thumbnailWrapper.classList.add('thumbnail-wrapper');

				const libraryThumbnail = document.createElement('img');
				libraryThumbnail.classList.add('library-thumbnail');
				libraryThumbnail.src = `library-thumbnails/${library.name}.png`;

				libraryThumbnail.onerror = () => {
					libraryThumbnail.onerror = null;
					libraryThumbnail.src = `library-thumbnails/${library.name}.jpg`;
					libraryThumbnail.onerror = () => {
						libraryThumbnail.onerror = null;
						console.log('Both PNG and JPG images failed to load');
						libraryThumbnail.src = 'library-thumbnails/blank.png';
					};
				};

				libraryThumbnail.alt = `${library.name} Cover`;
				thumbnailWrapper.appendChild(libraryThumbnail);
				listItem.appendChild(thumbnailWrapper);

				const libraryName = document.createElement('div');
				libraryName.classList.add('library-name');
				libraryName.textContent = library.name;
				listItem.appendChild(libraryName);

				listItem.addEventListener('click', () => {
					currentPath = parseHashAndParams();
					if ((currentPath.path == 'series') && (currentPath.params.get('library_id') == library.id)) {
						navigateTo(`#library?library_id=${library.id}&series_id=${currentPath.params.get('series_id')}`);
					}
					else {
						navigateTo(`#library?library_id=${library.id}`);
					}

				});
				librariesList.appendChild(listItem);
			});
		}

		function getAltTitles(serie) {

			const labels = ['Time', 'Story', 'Art'];
			const altTitle = labels.reduce((out, label) => {
				const altTitle = serie.metadata.alternateTitles.find(
					(alt) => alt.label === label
				);
				out[label.toLowerCase()] = altTitle ? altTitle.title : 'N/A';
				return out;
			}, {});

			if (altTitle.time == 'N/A') {
				altTitle.time = serie.booksMetadata.releaseDate.split("-")[0];
			};

			if (altTitle.story == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === "writer"
				);
				altTitle.story = bookWriter ? bookWriter.name : "N/A";
			}
			if (altTitle.art == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === "penciller"
				);
				altTitle.art = bookWriter ? bookWriter.name : "N/A";
			}
			return altTitle;

		}


		async function displayHeader(serie) {
			const altTitle = getAltTitles(serie);
			const creditString = altTitle.story == altTitle.art
				? `Story and art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>`
				: `Story by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>, art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.art.toLowerCase()}');">${altTitle.art}</a>`;

			seriesHeader.innerHTML = `
			<div class="header-pic-container">
				<div class="thumbnail-wrapper">
					<img id="seriesHeaderThumbnail" src="${mbBaseUrl}/api/v1/series/${serie.id}/thumbnail" class="header-pic">
				</div>
			</div>
			<div class="header-title">
				<span class="title">${serie.metadata.title}<img width=20px height=20px style="margin-left:15px; margin-top:2px; vertical-align: top;" src="flags/${serie.metadata.language}.svg"></span>
				<span class="notes">
					<a class="red search-trigger" href="javascript:navigateTo('#search?search_string=y:${altTitle.time}');">${altTitle.time}</a> (${serie.booksCount} ${serie.booksCount == 1 ? "volume" : "volumes"}) - ${creditString}</span>
			</div>
			<div class="header-summary">${serie.metadata.summary.replace(/\n/g, '<br>')}</div>
			`;

			seriesHeaderThumbnail.src = await fetchMedia(seriesHeaderThumbnail.src);

			seriesMiniHeader.innerHTML = `
				<span class="mini-title">${serie.metadata.title}</span>
			`
		}

		//MB Book Details Panel 

		let currentbook = null;
		let prevbook = null;
		let nextbook = null;

		function closeBookDetails() {
			sectionHide(bookDetailsContainer);
			setTimeout(() => {
				bookDetailsContainer.innerHTML = ''
			}, 300);
		}

		function jumpBookDetailsPrev() {
			if (prevbook != null) showBookDetails(prevbook);
		}
		function jumpBookDetailsNext() {
			if (nextbook != null) showBookDetails(nextbook);
		}

		async function showBookDetails(book) {
			const seriesData = await callAPI(`/api/v1/series/${book.seriesId}`);
			//const seriesBooks = await callAPI(`/api/v1/series/${book.seriesId}/books?unpaged=true`);
			const seriesBooks = await callAPI(
				`/api/v1/books/list?unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${book.seriesId}"}}}`
			);
			const readingDirection = seriesData.metadata.readingDirection;

			currentbook = book;
			prevbook = null;
			nextbook = null;

			if (book.number > 1) {
				prevbook = seriesBooks.content[book.number - 2];
			}
			if (book.number < seriesData.booksCount) {
				nextbook = seriesBooks.content[book.number];
			}
			sectionShow(bookDetailsContainer);
			let summaryArray = book.metadata.summary.split(/\r?\n/);

			let text = `
			<div class="book-details-pic-container">
				<div class="mini-controls">
					<div class="mini-buttons-2 prev-book" title="Previous book" onclick="jumpBookDetailsPrev()">
						<span class="fa-solid fa-chevron-left"></span>
					</div>
					<div class="mini-buttons-2 prev-book" title="Go to library" onclick="navigateTo('#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}')">
						<span class="fa-solid fa-layer-group"></span>
					</div>
					<div class="mini-buttons-2 next-book" title="Next book" onclick="jumpBookDetailsNext()">
						<span class="fa-solid fa-chevron-right"></span>
					</div>			
				</div>
				<div id="bookDetailsContainerThumbnailWrapper" title="Open Book" onclick="navigateToReadBook(currentbook, '${readingDirection}')">
					<img id="bookDetailCover" class="book-thumbnail hidden" src="transparent.png">
				</div>
			</div>
			<div>
				<div class="book-details-title">${book.metadata.title}</div>
				<div class="ul-container">
					<ul>
						${summaryArray.map(element => `<li>${element}</li>`).join('')}
					</ul>
				</div>
			</div>
			<div class="close-details mini-buttons-2" onclick="closeBookDetails()">
				<span class="fa-solid fa-xmark"></span>
			</div>
			`;
			bookDetailsContainer.innerHTML = text;
			bookDetailCover.lazySrc = `${mbBaseUrl}/api/v1/books/${book.id}/thumbnail`;
			addLazyLoading(bookDetailCover);

		}

		//MB Book Item Creation

		async function buildBookItem(item, book, format, target) {
			if (item.childNodes[0]) {
				item.childNodes[0].remove();
			}
			item.title = 'Read book';

			const booksItem = addItem('div', {
				className: 'book-item'
			});

			const mainRow = addItem('div', {
				className: 'data-row top-row'
			});

			if (format == 'longname') {
				mainRow.classList.add('book-row');
				const volumeNumberLabel = document.createElement('span');
				volumeNumberLabel.innerHTML = `Volume ${book.metadata.number}`;
				const pagesLabel = document.createElement('span');
				pagesLabel.innerHTML = `<span class="${mbDarkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`;
				mainRow.appendChild(volumeNumberLabel);
				mainRow.appendChild(pagesLabel);
			} else {
				mainRow.classList.add('book-series-row', 'red');
				mainRow.title = `Open series: ${book.seriesTitle}`;
				mainRow.textContent = book.seriesTitle;
				mainRow.addEventListener('click', (event) => {
					event.stopPropagation();
					if (target.binName) dashboardBin = target.binName;
					navigateTo(`#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}`);
				});
				noPointerDown(mainRow);
			}

			const secondRow = document.createElement('div');
			secondRow.classList.add('data-row');

			if (format == 'longname') {
				secondRow.classList.add('info-row');
				secondRow.textContent = book.metadata.title;
			} else if (format == 'compact') {
				const volumeNumberLabel = document.createElement('span');
				volumeNumberLabel.innerHTML = `Volume ${book.metadata.number}`;
				const pagesLabel = document.createElement('span');
				pagesLabel.innerHTML = `<span class="${mbDarkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`;
				secondRow.appendChild(volumeNumberLabel);
				secondRow.appendChild(pagesLabel);
			} else if (format == 'timeline') {
				const volumeNumberLabelShort = document.createElement('span');
				volumeNumberLabelShort.innerHTML = `Vol.${book.metadata.number}`;
				const timeLabel = document.createElement('span');

				const dateString = book.readProgress ?
					new Intl.DateTimeFormat('en-GB', {
						day: '2-digit',
						month: 'short',
						year: '2-digit'
					}).format(new Date(book.readProgress.readDate))
					: '';

				timeLabel.innerHTML = `<span class='${mbDarkTheme ? 'fa-solid' : 'fa-regular'} fa-clock glyph-dark'></span>&nbsp;${dateString}`;
				secondRow.appendChild(volumeNumberLabelShort);
				secondRow.appendChild(timeLabel);
			}

			const thumbnailWrapper = document.createElement('div');
			thumbnailWrapper.classList.add('thumbnail-wrapper');

			const bookThumbnail = document.createElement('img');
			bookThumbnail.classList.add('book-thumbnail', 'hidden');
			bookThumbnail.src = 'transparent.png';
			bookThumbnail.lazySrc = `${mbBaseUrl}/api/v1/books/${book.id}/thumbnail`;
			bookThumbnail.alt = book.metadata.title;
			//bookThumbnail.loading = 'lazy';

			addLazyLoading(bookThumbnail);

			const bookFader = addItem('div', {
				className: 'book-fader'
			});

			const bookOverlay = addItem('div', {
				className: 'book-overlay'
			});

			const bookStatus = addItem('div', {
				className: 'book-status'
			});

			const unread = (book.readProgress == null);

			if (unread) {
				const unreadBookBadge = addItem('div', {
					className: 'unread-book'
				});
				bookStatus.appendChild(unreadBookBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark book as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			markAsRead.addEventListener('click', () => {
				event.stopPropagation();
				setReadStatus(null, book.id, true, item, format);
			})
			noPointerDown(markAsRead);

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark book as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			markAsUnread.addEventListener('click', () => {
				event.stopPropagation();
				setReadStatus(null, book.id, false, item, format);
			})
			noPointerDown(markAsUnread);

			bookOverlay.appendChild(markAsRead);
			bookOverlay.appendChild(markAsUnread);


			if (book.metadata.summary != "") {
				const bookDetails = addItem('div', {
					className: 'mini-buttons book-details',
					title: 'Book Details',
					innerHTML: `<span class="fa-solid fa-align-justify"></span>`
				});
				bookDetails.addEventListener('click', async (event) => {
					event.stopPropagation();
					showBookDetails(book);
				})
				noPointerDown(bookDetails);

				bookOverlay.appendChild(bookDetails);

			}


			const progress = (book.readProgress ? (book.readProgress.completed ? 0 : book.readProgress.page) : 0)
			const progressBar = document.createElement('div');
			progressBar.classList.add('progress-bar');
			const progressGauge = document.createElement('div');
			progressGauge.classList.add('progress-gauge');
			if (progress == 0) {
				progressBar.classList.add('no-show');
			} else {
				progressGauge.style.width = `${Math.round(100 * progress / book.media.pagesCount)}%`;
			}

			booksItem.append(
				thumbnailWrapper,
				progressBar,
				mainRow,
				secondRow
			);

			thumbnailWrapper.append(
				bookThumbnail,
				bookFader,
				bookOverlay,
				bookStatus
			);

			progressBar.appendChild(progressGauge);

			addTouchScaler(booksItem, async () => {
				const seriesData = await callAPI(`/api/v1/series/${book.seriesId}`);
				const readingDirection = seriesData.metadata.readingDirection;

				rd.historyPath = window.location.hash.split('&book_id=')[0] + (target == booksGrid ? '&book_id=' + book.id : '');
				setIncognito(false);
				if (target.binName) dashboardBin = target.binName;
				navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${(readingDirection == 'RIGHT_TO_LEFT' ? 'rtl' : 'ltr')}
						&pag=${(book.readProgress ? book.readProgress.page : 1)}`);
			});

			item.appendChild(booksItem);

		}

		function displayBooks(books, target, format, focus = null) {
			/*
				"format" can be one of the follows
				- longname: will not show the series name, but the book file name
				- compact: will show series name and pages 
				- timeline: will show latest read date
			*/
			// focus is the book id to focus on


			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}


			if (books.length === 0) {
				const noBooksMsg = document.createElement('p');
				noBooksMsg.textContent = 'No books available';
				booksGrid.appendChild(noBooksMsg);
				return;
			}

			books.forEach(book => {
				const bookContainer = addItem('div', {
					className: 'book-container',
					id: book.id
				});

				buildBookItem(bookContainer, book, format, target);

				target.appendChild(bookContainer);
			});

			if (target == booksGrid) {
				sectionShow(booksGrid);
				sectionShow(seriesHeader);
				sectionShow(seriesMiniHeader);
				seriesMiniHeader.classList.add('collapse');

				focusItem(focus);
				/*
				if (focus) {
					var item = document.getElementById(focus);
					const yOffset = -150;
					const y = item.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop + yOffset;

					mainContainer.scrollTo({ top: y });

					currentlyScaled = item.firstChild;
					item.firstChild.classList.add('scaled');

				} else {
					mainContainer.scrollTo({ top: 0 });
				}
				*/
			}
		}

		//MB Dashboard Management

		// Function to trigger the home page layout
		async function selectHome() {

			libraryHighlight('homeButton');

			seriesGrid.innerHTML = '';
			booksGrid.innerHTML = '';
			stripGrid.innerHTML = '';

			sectionShow(homeStripsContainer);

			await Promise.all(
				Object.entries(dashboardElements).map(async ([name, item]) => {
					const resultsObject = await item.getItems(0, 20);
					item.element.style.display = resultsObject.empty ? 'none' : 'block';
					item.showItems(resultsObject.content, item.homeStrip);
				})
			);
			setTimeout(updateSliderMax, 10);

		}

		homeButton.addEventListener('click', () => {
			navigateTo('#dashboard');
		});

		dashboardElements = {
			keepReading: {
				headerCode: '<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading',
				getItems: async (page, size) => {
					//	const out = await callAPI(`/api/v1/books?read_status=IN_PROGRESS&page=0&unpaged=true`);
					const out = await callAPI(
						`/api/v1/books/list?page=0&unpaged=true&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"IN_PROGRESS"}}}`
					);

					//out.content.sort((a, b) => new Date(b.readProgress.readDate) - new Date(a.readProgress.readDate));
					return (out);
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
				element: null,
				scrollBar: null,
				gridButton: null,
				homeStrip: null,
			},


			onDeck: {
				headerCode: '<span class="fa-solid fa-inbox glyph-dark"></span>&nbsp;On Deck',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/books/ondeck`));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
			},

			recentBooks: {
				headerCode: '<span class="fa-solid fa-book glyph-dark"></span>&nbsp;Last Added Books',
				getItems: async (page, size) => {
					//return (await callAPI(`/api/v1/books?page=${page}&size=${size}&sort=created,desc`));
					return (await callAPI(
						`/api/v1/books/list?page=${page}&size=${size}&sort=created,desc`,
						'POST', `{"condition":{"allOf":[]}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				}
			},

			recentSeries: {
				headerCode: '<span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Last Added Series',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/series/new?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			updatedSeries: {
				headerCode: '<span class="fa-solid fa-bullhorn glyph-dark"></span>&nbsp;Last Updated Series',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/series/updated?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			readBooks: {
				headerCode: '<span class="fa-solid fa-square-check glyph-dark"></span>&nbsp;Last Read Books',
				getItems: async (page, size) => {
					//return (await callAPI(`/api/v1/books?page=${page}&size=${size}&read_status=READ&sort=readProgress.readDate,desc`));
					return (await callAPI(
						`/api/v1/books/list?page=${page}&size=${size}&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"READ"}}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'timeline');
				},
			},
		}

		async function dashboardAll(element, page) {

			libraryHighlight('homeButton');

			seriesGrid.innerHTML = ''; // Clear the series grid
			booksGrid.innerHTML = ''; // Clear the series grid
			stripGrid.innerHTML = '';

			sectionShow(stripGridContainer);

			stripGridHeader.innerHTML = dashboardElements[element].headerCode;
			const data = await dashboardElements[element].getItems(page, 50);

			const array = data.content;

			stripPrevPage.classList.remove('disabled');
			stripNextPage.classList.remove('disabled');
			if (data.first) stripPrevPage.classList.add('disabled');
			if (data.last) stripNextPage.classList.add('disabled');

			dashboardElements[element].showItems(array, stripGrid);
		}

		Object.entries(dashboardElements).forEach(([name, item]) => {

			item.element = addItem('div', { className: 'home-strip-parent' });
			const headerContainer = addItem('div', { className: 'strip-header-container' });
			const stripHeader = addItem('div', {
				className: 'strip-header',
				innerHTML: item.headerCode,
			});
			item.scrollBar = addItem('div', {
				className: 'custom-scrollbar',
			});
			item.scrollInput = addItem('input', {
				type: "range",
				className: "range-bar",
				min: "0",
				max: "100",
				value: "0"
			});
			item.gridButton = addItem('div', {
				className: 'strip-all',
				innerHTML: '<span title="View All" class="fa-solid fa-grip glyph-dark"></span>',
			});
			item.homeStrip = addItem('div', {
				className: 'home-strip',
				binName: name,
			})
			item.gridButton.addEventListener('click', async () => {
				dashboardBin = name;
				navigateTo('#dashboard?all=' + name + '&page=0')
			});
			item.scrollInput.addEventListener('input', () => {
				item.homeStrip.scrollLeft = item.scrollInput.value;
			});
			item.homeStrip.addEventListener('scroll', () => {
				item.scrollInput.value = item.homeStrip.scrollLeft;
			});

			item.scrollBar.appendChild(item.scrollInput);

			headerContainer.appendChild(stripHeader);
			headerContainer.appendChild(item.scrollBar);
			headerContainer.appendChild(item.gridButton);

			item.element.appendChild(headerContainer);
			item.element.appendChild(item.homeStrip);

			homeStripsContainer.appendChild(item.element);
		});

		// Open a whole series fetching all its books and showing them with the correct header
		// if seriesdata is not available at the moment of the call, it fetches it from the server
		async function openSeries(libraryId, seriesId, bookId) {

			const seriesData = await callAPI(`/api/v1/series/${seriesId}`);
			//const books = await fetchBooks(seriesId);
			//let books = await callAPI(`/api/v1/series/${seriesId}/books?page=0&unpaged=true`);			
			let books = await callAPI(
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${seriesId}"}}}`
			);

			books = books.content;

			await libraryHighlight(libraryId);
			displayHeader(seriesData);
			displayBooks(books, booksGrid, 'longname', bookId);
		}

		async function bootSequence() {
			changeAccent(mbAccentColor);
			changeTheme(mbDarkTheme);
			setIncognito(false);

			buildLanguageList();

			sectionShow(stickyContainer);

			let series_data = null;
			await fetchLibraries();
			loadContent();
		}

		//MB Reader Functions and Data

		// General reader data structure
		let rd = {
			thresholdRatio: 1.0,	//Orientation threshold

			preloadCount: 15,			// Imge preload count
			preloadPicDelay: 300,	// Delay before adding new spreads to the preload stack
			loadDelay: 100,			// Delay used when jumping to a spread before really updating
			jumpTimeout: null,		// Timeout counter for jumping to spreads

			preloadStack: {}, 		// Contains all the preload timers, one for each spread that's going to be loaded
			picLoadStack: [], 		// Contains all load image objects, both direct load and preload

			ltr: null,
			currentPage: 0,
			pages: [],					// this is the array of pages data in the form url, iscover etc
			uiPages: [],				// array of page images with alt = page number
			uiPagesContainer: [],

			uiSpreads: [],				// array of divs with the correct paged uiPages inside
			uiSpreadsPagenums: [],		// array of arrays that associates each uiSpread div index to page index.
			uiSpreadsImageRefs: [],		// array of arrays that associates each uiSpread div index to IMAGE index (for double spreads).
			uiSpreadsKind: [],

			currentPageIndex: 0,
			currentSpreadIndex: 0,
			oldSpreadIndex: 0,
			isDraggingProgressBar: false,

			thumbZoom: false,
			thumbsWidth: 0,

			uiPagesThumbs: [],
			uiSpreadsThumbs: [],

			libraryId: 0,
			seriesId: 0,
			bookId: 0,

			historyPath: '',
			bookPath: '',

			incognito: false,

			spreadFocus: 'focus-center'
		};

		// Function that prepares the page for reading a book, once the url is setup, navigateTo triggers readBook function
		function navigateToReadBook(book, readingDirection) {
			setIncognito(false);
			navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${(readingDirection == 'RIGHT_TO_LEFT' ? 'rtl' : 'ltr')}
						&pag=${(book.readProgress ? book.readProgress.page : 1)}`);
		}

		// Function that setups the reader for a specific book, this is not run directly
		function readBook(libraryId, seriesId, bookId, dir, pag) {
			//TODO aggiungere funzione per pulire l'array del preload e quello delle pic
			Object.entries(dashboardElements).forEach(([name, item]) => {
				item.homeStrip.innerHTML = '';
			});
			clearReader(); //TODO forse eccessivo?
			clearAllTimeouts();
			rd.picLoadStack = [];
			rd.jumpTimeout = null;

			rd.ltr = (dir == 'ltr');
			rd.currentPage = pag;
			rd.pages = [];					// this is the array of pages data in the form url; iscover etc
			rd.uiPages = [];				// array of page images with alt = page number
			rd.uiPagesContainer = [];				// array of page images with alt = page number
			rd.uiSpreads = [];				// array of divs with the correct paged uiPages inside
			rd.uiSpreadsPagenums = [];		// array of arrays that associates each uiSpreads div index to its uiPages index.
			rd.uiSpreadsImageRefs = [];		// array of arrays that associates each uiSpreads div index to its uiPages index.
			rd.uiSpreadsKind = [];

			rd.currentPageIndex = 0;
			rd.currentSpreadIndex = 0;
			rd.oldSpreadIndex = 0;
			rd.isDraggingProgressBar = false;

			rd.uiSpreadsThumbs = [];
			rd.uiPagesThumbs = [];

			rd.libraryId = libraryId;
			rd.seriesId = seriesId;
			rd.bookId = bookId;

			rd.spreadFocus = 'focus-center';

			readerViewer.innerHTML = '';

			setThumbZoom(false);
			sectionShow(readerContainer);

			initViewer();

		}

		// Reader cleanup functions to remove all dangling spreads and pages
		function clearReader() {
			rd.uiPages.forEach(item => {
				item.remove();
				item = null;
			});

			rd.uiPagesContainer.forEach(item => {
				item.remove();
				item = null;
			});

			rd.uiSpreads.forEach(item => {
				item.remove();
				item = null;
			});

			rd.uiPagesThumbs.forEach(item => {
				item.remove();
				item = null;
			});

			rd.uiSpreadsThumbs.forEach(item => {
				item.remove();
				item = null;
			});
		}

		const frames = {
			"focus-right-page": 'translate(-75%, -50%)',
			"focus-left-page": 'translate(-25%, -50%)',
			"focus-center": 'translate(-50%, -50%)',
			"none": 'translate(-50%, -50%)',
		}

		//TODO Verificare se smoothMove è ancora utile
		function spreadSetFocus(focusString, smoothMove = false) {
			readerViewer.animate(
				[{ transform: frames[focusString] }],
				{ duration: smoothMove ? 500 : 0, easing: "ease", fill: "forwards" }
			);
			rd.spreadFocus = focusString;
		}


		// Setup close button
		function handleCloseReader() {
			hideMenu();
			incognitoMark.classList.remove('incognito');

			clearTimeout(rd.jumpTimeout);
			setTimeout(() => {
				spreadSetFocus("none");
				clearReader();
			}, 400); //300ms timeout so the reader can slide out

			purgeLoading();
			clearAllTimeouts();

			navigateTo(rd.historyPath == '' ? '#dashboard' : rd.historyPath);
		}

		readerClose.addEventListener('click', () => {
			handleCloseReader();
		})

		// Setup incognito button
		function setIncognito(status) {

			readerIncognito.classList.remove('incognito');
			incognitoMark.classList.remove('incognito');

			if (status) {
				readerIncognito.classList.add('incognito');
				incognitoMark.classList.add('incognito')
			};

			rd.incognito = status;
		}

		readerIncognito.addEventListener('click', () => {
			setIncognito(!rd.incognito);
		})

		function setThumbZoom(status) {
			rd.thumbZoom = status;
			rd.thumbsWidth = thumbStripInner.clientWidth;
			thumbStrip.style.overflow = "hidden";
			const oldWidth = thumbStripInner.clientWidth;

			let thumbHeight = status ? 300 : 150;
			if (window.innerHeight - thumbHeight - 60 - 60 - 30 < 0) {
				thumbHeight = window.innerHeight - 60 - 60 - 30;
			}
			document.documentElement.style.setProperty('--mb-thumb-height-px', thumbHeight + 'px');

			const newWidth = thumbStripInner.clientWidth;

			const scrollScaler = newWidth / oldWidth;
			thumbStrip.scrollLeft = thumbStrip.scrollLeft * scrollScaler;
			//centerThumb(true);

		}

		thumbStripButton.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});


		const resizeObserver = new ResizeObserver(entries => {
			for (let entry of entries) {
				const oldWidth = rd.thumbsWidth;
				const newWidth = thumbStripInner.clientWidth;
				const scrollScaler = newWidth / oldWidth;
				thumbStrip.scrollLeft = thumbStrip.scrollLeft * scrollScaler;
				rd.thumbsWidth = newWidth;
				testpr("Size changed:", entry.contentRect.width, entry.contentRect.height);
			}
		});

		resizeObserver.observe(thumbStripInner);

		//TODO remove this and trigger rd.thumbsWidth when zoom is initiated

		thumbStripInner.addEventListener("transitionrun", () => {

			testpr("Transition started")
		});
		thumbStripInner.addEventListener("transitionstart", () => testpr("Transition actually started"));

		thumbStripInner.addEventListener("transitionend", () => {
			thumbStrip.style.overflow = "auto";
			testpr("Transition ended")

		});


		function updateProgressBar() {
			const progressPercent = (rd.currentSpreadIndex / (rd.uiSpreads.length - 1)) * 100;
			readerProgress.style.width = `${progressPercent}%`;
			readerProgress.style.float = rd.ltr ? 'left' : 'right';

			[rd.currentPage, readerPage.innerText] = getPage(rd.currentSpreadIndex);

			readerPage.style.left = rd.ltr
				? `min(max(0px, calc(${progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
				: `min(max(0px, calc(${100 - progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`

		}

		function preloadPage(index) {
			if (picLoadStackSize() >= 20000000) {
				return;
			}
			populateSpread(index, true);
		}

		function calcDelay(i, delay, scale, power) {
			return ((delay * (1 - scale) + (i ** power) * delay * scale))
		}

		// This function triggers multiple preloads starting from the current spread
		function preloadPages(startSpreadIndex, count) {
			if (isSectionHidden(readerContainer)) return;

			for (let i = 1; i <= count; i++) {
				const forwardIndex = startSpreadIndex + i;
				const backwardIndex = startSpreadIndex - i;

				if (forwardIndex < rd.uiSpreads.length && !(forwardIndex in rd.preloadStack)) {
					startTimeout(forwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(forwardIndex));
				}
				if (backwardIndex >= 0 && !(backwardIndex in rd.preloadStack)) {
					startTimeout(backwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(backwardIndex));
				}
			}
		}

		// Initialize viewer with page data
		async function initViewer() {
			rd.pages = await fetchPages(rd.bookId);

			let bookData = await callAPI(`/api/v1/books/${rd.bookId}`);

			if (!rd.incognito && bookData.readProgress && (bookData.readProgress.completed === true)) {
				rd.currentSpreadIndex = 0; //TODO Maybe change this with a check with the top page?
			}

			leftLimit.innerText = rd.ltr ? 1 : rd.uiPages.length;
			rightLimit.innerText = rd.ltr ? rd.pages.length : 1;
			bookName.innerText = `${bookData.seriesTitle} Vol.${bookData.metadata.number} (${bookData.metadata.title})`

			buildFlock(readerViewer, rd.currentSpreadIndex, rd.uiSpreads.length)

			populateSpread(rd.currentSpreadIndex);
			spreadShow(rd.uiSpreads[rd.currentSpreadIndex]);

			centerThumb();
			updateProgressBar();
		}

		function buildSizePic(item, ratio, picratio) {
			item.style.width = `calc(min(${100 * picratio / ratio}vw, ${picratio * 100}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh))`;
		}

		function buildSize(item, ratio) {
			item.style.width = `calc(min(100vw, ${100 * ratio}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh))`;
		}

		// Size the spread for a two pages spread with fit on page
		function buildSize2P(item, ratio) {
			item.style.width = `calc(2 * min(100vw, ${100 * ratio * 0.5}vh))`;
			item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, 100vh))`;
		}

		// Add this once when initializing the viewer
//readerViewer.style.transition = "left 0.3s ease, border-width 0.3s ease, border-image-slice 0.3s ease";

function buildFlock(item, index, total) {
    /*
	 if (rd.uiSpreads[index].singlePage) {
        readerViewer.style.transition = "none"; // Disable transition for single pages
        readerViewer.style.boxShadow = 'none';
        readerViewer.style.left = `50%`;
        readerViewer.style.borderWidth = `0px 0px 0px 0px`;
        return;
    }
    readerViewer.style.transition = "left 0.3s ease, border-width 0.3s ease, border-image-slice 0.3s ease"; // Restore transition
    */
	//TODO SISTEAMRE IL BORDO MINIMO
	if (index == 1) index = 0;
	if (index == total - 1) index = total;
 
	 const flockRate = [
        rd.ltr ? (1.0 - index / total) : (index / total),
        rd.ltr ? (index / total) : (1.0 - index / total),
        rd.ltr ? -0.5 * (1.0 - 2 * index / total) : 0.5 * (1.0 - 2 * index / total)
    ];
    
    const bookThickness = (80 - (80 / (800 * 800)) * (total * 2 - 800) * (total * 2 - 800)) / 800;
    const flockCut = Math.min(360 * total * 2 / 700, 360);
    const flockOffset = flockRate.map(rate => 100 * bookThickness * rate);

    /*TODO RIVEDERE readerViewer.style.boxShadow = '0px 0px 15px 0px rgba(60, 40, 30, 0.8)';*/
    readerViewer.style.left = `calc(50% - ${flockOffset[2]}vh)`;
    readerViewer.style.borderWidth = `0px ${flockOffset[0]}vh 0px ${flockOffset[1]}vh`;
    readerViewer.style.borderImageSlice = `0 ${flockCut * flockRate[0]} 0 ${flockCut * flockRate[1]}`;
}

/*
		function buildFlock(item, index, total) {
			if (rd.uiSpreads[index].singlePage) {
				readerViewer.style.boxShadow = 'none';
				readerViewer.style.left = `50%`;
				readerViewer.style.borderWidth = `0px 0px 0px 0px`;
				return
			}
			const flockRate = [
				rd.ltr ? (1.0 - index / total) : (index / total),
				rd.ltr ? (index / total) : (1.0 - index / total),
				rd.ltr ? - 0.5 * (1.0 - 2 * index / total) : 0.5 * (1.0 - 2 * index / total)
			]
			const bookThickness = (80 - (80 / (800 * 800)) * (total * 2 - 800) * (total * 2 - 800)) / 800;//Was 40/800 and (15 / 800) * (dataOut.length / 100) before
			const flockCut = Math.min(360 * total * 2 / 700, 360);
			const flockOffset = flockRate.map(rate => 100 * bookThickness * rate);

			readerViewer.style.boxShadow = '0px 0px 15px 0px rgba(60, 40, 30, 0.8)';
			readerViewer.style.left = `calc(50% - ${flockOffset[2]}vh)`;
			readerViewer.style.borderWidth = `0px ${flockOffset[0]}vh 0px ${flockOffset[1]}vh`;
			readerViewer.style.borderImageSlice = `0 ${flockCut * flockRate[0]} 0 ${flockCut * flockRate[1]}`;
		}
*/
		//MB Reader Fetch Page Function
		// Master function that builds all the pages slots for the book spreads
		async function fetchPages(bookId) {

			// Get the pages data structure from komga for the current book
			const data = await callAPI(`/api/v1/books/${bookId}/pages`);

			// Create dataOut structure with the fields from fetched data
			const dataOut = data.map(page => ({
				url: `${mbBaseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: `${mbBaseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: page.number == 1,
				isCurrent: page.number == rd.currentPage,
				isDoubleSpread: page.width > page.height,
				size: page.sizeBytes
			}));

			readerMaxRatio = Math.max(...dataOut.map(item => (item.isCover || item.isDoubleSpread) ? 0 : ((item.width / item.height) < 1 ? 2 * item.width / item.height : 2 * item.width / item.height)));

			// readerViewer.style.height='100vh';
			readerViewer.style.height = `calc(min(${100 / (0.5 * readerMaxRatio)}vw, 100vh))`;
			//readerViewer.style.width=`calc(${readerMaxRatio} * 100vh)`;
			readerViewer.style.width = `calc(min(200vw, ${100 * readerMaxRatio}vh))`;

			let leftPos = 0;

			// Create html structure for every page and related page thumbnails
			// and organize data structur for spread formation

			rd.uiSpreadsPagenums = []; 	// page number for each spread
			rd.uiSpreadsImageRefs = []; 		// Image reference number for each spread
			rd.uiSpreadsKind = [];			// Spreads kind ('cover-page', 'two-pages', 'double-spread', 'back-cover')

			let i_image = 0;
			let i_counter = 0;
			let i_spread = 0;

			let arrayPagenums = null;
			let arrayImageRefs = null;
			let spreadKind = null;

			let element = null;

			let doubleSpread = false;
			let secondPage = false;

			while (i_image < dataOut.length) {
				console.log("i_image:" + i_image);
				// Create an image entry for page image
				const imgDiv = addItem('div', {
					className: 'page-container'
				});
				const imgPage = addItem('img', {
					alt: dataOut[i_image].pageNum,
					className: 'page multiply hidden',
					src: 'transparent.png',
					hasSrc: false,
					lazySrc: dataOut[i_image].url,
					size: dataOut[i_image].size
				});
				imgDiv.appendChild(imgPage);

				rd.uiPages.push(imgPage);
				rd.uiPagesContainer.push(imgDiv);

				// Create a thumb entry for page image
				const imgThumb = addItem('img', {
					className: 'page-thumb multiply hidden',
					alt: dataOut[i_image].pageNum,
					src: 'transparent.png',
					lazySrc: dataOut[i_image].thumb,
				});
				console.log(imgThumb);
				imgThumb.style.height = "var(--mb-thumb-height-px)";
				imgThumb.style.aspectRatio = dataOut[i_image].AR;

				addLazyLoading(imgThumb);
				rd.uiPagesThumbs.push(imgThumb);

				if (dataOut[i_image].isCover) {
					console.log("isCover");
					// Element is a cover
					rd.uiSpreadsPagenums.push([i_image]);
					rd.uiSpreadsImageRefs.push([i_counter]);
					rd.uiSpreadsKind.push('cover-page');
					i_counter++;
					i_image++;
					i_spread++;
				}
				else if ((dataOut[i_image].isDoubleSpread && !doubleSpread)) {
					console.log("isDoubleSpread");
					// Element is a double spread and we ar not running second spread pass
					console.log("DOUBLESPREAD");
					doubleSpread = true;
					arrayPagenums = [i_image];
					arrayImageRefs = [i_counter];
					spreadKind = 'double-spread';
					i_counter++;
				}
				else if (dataOut[i_image].isDoubleSpread && doubleSpread) {
					console.log("SecondDoubleSpread");
					// Element is a double spread, this is the second picture
					doubleSpread = false;
					arrayPagenums.push(i_image);
					arrayImageRefs.push(i_counter);
					i_counter++;
					i_image++;
					i_spread++;
					rd.uiSpreadsPagenums.push(arrayPagenums);
					rd.uiSpreadsImageRefs.push(arrayImageRefs);
					rd.uiSpreadsKind.push(spreadKind);
				}
				else if (!secondPage) {
					console.log("TwoPages");
					arrayPagenums = [i_image];
					arrayImageRefs = [i_counter];
					spreadKind = 'two-pages';

					if (i_image == dataOut.length - 1){
						rd.uiSpreadsPagenums.push([i_image]);
						rd.uiSpreadsImageRefs.push([i_counter]);
						rd.uiSpreadsKind.push('back-cover');
						i_counter++;
						i_image++;
						i_spread++;
					} 
					else if ((i_image + 1 < dataOut.length) && (dataOut[i_image + 1].isDoubleSpread)) {
						console.log("Single");
						// This is an orphan page!

						// Create blank page
						const imgDivBlank = addItem('div', {
							className: 'page-container'
						});
						const imgPageBlank = addItem('img', {
							alt: '',
							className: 'page multiply hidden',
							src: 'transparent.png',
							hasSrc: true,
							size: 0
						});
						imgDivBlank.appendChild(imgPageBlank);

						rd.uiPages.push(imgPageBlank);
						rd.uiPagesContainer.push(imgDivBlank);

						// Create a thumb entry for blank page
						const imgThumbBlank = addItem('img', {
							className: 'page-thumb multiply hidden',
							alt: '',
							src: 'transparent.png',
						});
						imgThumbBlank.style.height = "var(--mb-thumb-height-px)";
						imgThumbBlank.style.aspectRatio = dataOut[i_image].AR;

						rd.uiPagesThumbs.push(imgThumbBlank);

						arrayPagenums.push(i_image);
						i_counter++;
						arrayImageRefs.push(i_counter);
						i_counter++;

						i_spread++;
						i_image++;
						rd.uiSpreadsPagenums.push(arrayPagenums.reverse());
						rd.uiSpreadsImageRefs.push(arrayImageRefs.reverse());
						rd.uiSpreadsKind.push(spreadKind);
					} else {
						console.log("Double");

						secondPage = true;
						i_counter++;
						i_image++;
					}
				}
				else if (secondPage) {
					console.log("SecondPage");
					secondPage = false;
					arrayPagenums.push(i_image);
					arrayImageRefs.push(i_counter);
					i_counter++;
					i_image++;
					i_spread++;
					rd.uiSpreadsPagenums.push(arrayPagenums);
					rd.uiSpreadsImageRefs.push(arrayImageRefs);
					rd.uiSpreadsKind.push(spreadKind);
				}
			}

			console.log("FINE BLOCCO");
			console.log("uiSpreadsPagenums");
			console.log(rd.uiSpreadsPagenums); 	// page number for each spread
			console.log("uiSpreadsImageRefs");
			console.log(rd.uiSpreadsImageRefs); 		// Image reference number for each spread
			console.log("uiSpreadsKind");
			console.log(rd.uiSpreadsKind);
			console.log('uiPages');
			console.log(rd.uiPages);
			console.log('uiPagesThumbs');
			console.log(rd.uiPagesThumbs);
			console.log('uiSpreadsThumbs');
			console.log(rd.uiSpreadsThumbs.length);
			console.log(rd.uiSpreadsThumbs);
			// Prepare "spreads" structure based on the layout chosen in the UI

			let i = 0; // Counter of page number
			let ipic = 0; // Counter of image elements. Double spreads have one page number and two image elements 
			doubleSpread = false;

			let spreadTotal = 0;

			readerHorizontal = ((screenAR / readerMaxRatio > rd.thresholdRatio));
			thumbStripInner.style.flexDirection = !rd.ltr ? 'row-reverse' : 'row';

			let currentPageSingle = false;

			// Populate and create spread structure
			rd.uiSpreadsKind.forEach((spreadKind, index) => {
				const spreadItem = document.createElement('div');
				const spreadItemThumb = document.createElement('div');

				spreadItem.classList.add('spread-layout');
				spreadItemThumb.classList.add('spread-thumb');

				if ((spreadKind == 'cover-page')){
					let imageIndex = rd.uiSpreadsImageRefs[index][0];
					let pageRef = rd.uiSpreadsPagenums[index][0];

					spreadItem.singlePage = true; //TODO forse non servirà in futuro
					spreadItemThumb.appendChild(rd.uiPagesThumbs[imageIndex]);

					spreadItem.appendChild(rd.uiPagesContainer[imageIndex]);
					spreadItem.classList.add('cover-page')

					buildSize2P(spreadItem, readerMaxRatio);
					//buildFlock(spreadItem, i, dataOut.length);
					spreadItem.style.width = `calc(min(200vw, ${100 * readerMaxRatio}vh))`;


					buildSizePic(rd.uiPagesContainer[imageIndex], readerMaxRatio * 0.5, readerMaxRatio * 0.5);

					rd.uiPagesContainer[imageIndex].classList.add(rd.ltr ? 'cover-page-LTR' : 'cover-page-RTL');
					if (rd.ltr) {
						rd.uiPagesContainer[imageIndex].style.marginLeft = 'auto';
					} else {
						rd.uiPagesContainer[imageIndex].style.marginRight = 'auto';
					}


					buildSizePic(rd.uiPages[imageIndex], dataOut[pageRef].AR, dataOut[pageRef].AR);

					rd.uiPages[imageIndex].style.objectFit = 'cover';
					rd.uiPages[imageIndex].style.objectPosition = rd.ltr ? 'right' : 'left';
					rd.uiPages[imageIndex].style.height = rd.uiPagesContainer[imageIndex].style.height;

					if (dataOut[pageRef].isCurrent) {
						currentPageSingle = true;
						rd.currentSpreadIndex = index;
					}

					const coverlay = document.createElement('div');
					coverlay.id = 'coverlayer';
					coverlay.classList.add(rd.ltr ? 'LTR' : 'RTL')
					coverlay.style.width = rd.uiPagesContainer[imageIndex].style.width;
					coverlay.style.height = rd.uiPagesContainer[imageIndex].style.height;
					rd.uiPagesContainer[imageIndex].appendChild(coverlay);
					
				} 
				else if ((spreadKind == 'back-cover')){
					let imageIndex = rd.uiSpreadsImageRefs[index][0];
					let pageRef = rd.uiSpreadsPagenums[index][0];

					spreadItem.singlePage = true; //TODO forse non servirà in futuro
					spreadItemThumb.appendChild(rd.uiPagesThumbs[imageIndex]);

					spreadItem.appendChild(rd.uiPagesContainer[imageIndex]);
					spreadItem.classList.add('cover-page')

					buildSize2P(spreadItem, readerMaxRatio);
					//buildFlock(spreadItem, i, dataOut.length);
					spreadItem.style.width = `calc(min(200vw, ${100 * readerMaxRatio}vh))`;


					buildSizePic(rd.uiPagesContainer[imageIndex], readerMaxRatio * 0.5, readerMaxRatio * 0.5);

					rd.uiPagesContainer[imageIndex].classList.add(rd.ltr ? 'cover-page-RTL' : 'cover-page-LTR');
					if (rd.ltr) {
						rd.uiPagesContainer[imageIndex].style.marginRight = 'auto';
					} else {
						rd.uiPagesContainer[imageIndex].style.marginLeft = 'auto';
					}


					buildSizePic(rd.uiPages[imageIndex], dataOut[pageRef].AR, dataOut[pageRef].AR);

					rd.uiPages[imageIndex].style.objectFit = 'cover';
					rd.uiPages[imageIndex].style.objectPosition = rd.ltr ? 'right' : 'left';
					rd.uiPages[imageIndex].style.height = rd.uiPagesContainer[imageIndex].style.height;

					if (dataOut[pageRef].isCurrent) {
						currentPageSingle = true;
						rd.currentSpreadIndex = index;
					}

					const coverlay = document.createElement('div');
					coverlay.id = 'coverlayer';
					coverlay.classList.add(rd.ltr ? 'RTL' : 'LTR')
					coverlay.style.width = rd.uiPagesContainer[imageIndex].style.width;
					coverlay.style.height = rd.uiPagesContainer[imageIndex].style.height;
					rd.uiPagesContainer[imageIndex].appendChild(coverlay);
					
				}
				else if (spreadKind == 'two-pages') {
					let imageIndex1 = rd.uiSpreadsImageRefs[index][0];
					let imageIndex2 = rd.uiSpreadsImageRefs[index][1];
					let pageRef1 = rd.uiSpreadsPagenums[index][0];
					let pageRef2 = rd.uiSpreadsPagenums[index][1];

					spreadItem.singlePage = false;
					spreadItemThumb.appendChild(rd.uiPagesThumbs[rd.ltr ? imageIndex1 : imageIndex2]);
					spreadItemThumb.appendChild(rd.uiPagesThumbs[rd.ltr ? imageIndex2 : imageIndex1]);

					spreadItem.appendChild(rd.uiPagesContainer[rd.ltr ? imageIndex1 : imageIndex2]);
					spreadItem.appendChild(rd.uiPagesContainer[rd.ltr ? imageIndex2 : imageIndex1]);

					rd.uiPages[imageIndex1].style.float = rd.ltr ? 'right' : 'left';
					rd.uiPages[imageIndex2].style.float = rd.ltr ? 'left' : 'right';

					rd.uiPagesContainer[imageIndex1].classList.add(rd.ltr ? 'left-page' : 'right-page');
					rd.uiPagesContainer[imageIndex2].classList.add(rd.ltr ? 'right-page' : 'left-page');

					spreadItem.classList.add('two-pages', 'flock');

					buildSize2P(spreadItem, readerMaxRatio);
					//buildFlock(spreadItem, i, dataOut.length);
					//TODO Ma questo serve????
					spreadItem.style.width = `calc(min(200vw, ${100 * readerMaxRatio}vh))`;

					buildSizePic(rd.uiPagesContainer[imageIndex1], readerMaxRatio * 0.5, readerMaxRatio * 0.5);
					buildSizePic(rd.uiPagesContainer[imageIndex2], readerMaxRatio * 0.5, readerMaxRatio * 0.5);

					rd.uiPages[imageIndex1].style.height = rd.uiPagesContainer[imageIndex1].style.height;
					rd.uiPages[imageIndex2].style.height = rd.uiPagesContainer[imageIndex2].style.height;

					if (dataOut[pageRef1].isCurrent) rd.currentSpreadIndex = index;
					if (dataOut[pageRef2].isCurrent) rd.currentSpreadIndex = index;

				}
				else if (spreadKind == 'double-spread') {
					spreadItem.singlePage = false;

					let imageIndex1 = rd.uiSpreadsImageRefs[index][0];
					let imageIndex2 = rd.uiSpreadsImageRefs[index][1];
					let pageRef = rd.uiSpreadsPagenums[index][0];
					// Crop double spreads thumbnails
					rd.uiPagesThumbs[imageIndex1].style.aspectRatio = dataOut[pageRef].AR * 0.5;
					rd.uiPagesThumbs[imageIndex2].style.aspectRatio = dataOut[pageRef].AR * 0.5;
					rd.uiPagesThumbs[imageIndex1].style.objectFit = 'cover';
					rd.uiPagesThumbs[imageIndex2].style.objectFit = 'cover';
					rd.uiPagesThumbs[imageIndex1].style.objectPosition = rd.ltr ? 'left' : 'right';
					rd.uiPagesThumbs[imageIndex2].style.objectPosition = rd.ltr ? 'right' : 'left';

					spreadItemThumb.appendChild(rd.uiPagesThumbs[rd.ltr ? imageIndex1 : imageIndex2]);
					spreadItemThumb.appendChild(rd.uiPagesThumbs[rd.ltr ? imageIndex2 : imageIndex1]);

					// Add page containers
					spreadItem.appendChild(rd.uiPagesContainer[rd.ltr ? imageIndex1 : imageIndex2]);
					spreadItem.appendChild(rd.uiPagesContainer[rd.ltr ? imageIndex2 : imageIndex1]);

					rd.uiPages[imageIndex1].style.float = rd.ltr ? 'right' : 'left';
					rd.uiPages[imageIndex2].style.float = rd.ltr ? 'left' : 'right';

					rd.uiPagesContainer[imageIndex1].classList.add(rd.ltr ? 'left-page' : 'right-page');
					rd.uiPagesContainer[imageIndex2].classList.add(rd.ltr ? 'right-page' : 'left-page');

					spreadItem.classList.add('two-pages', 'flock');

					buildSize2P(spreadItem, readerMaxRatio);
					//buildFlock(spreadItem, i, dataOut.length);
					spreadItem.style.width = `calc(min(200vw, ${100 * readerMaxRatio}vh))`;

					//buildSizePic(rd.uiPages[ipic], dataOut[i].AR, dataOut[i].AR);
					//buildSizePic(rd.uiPages[ipic + 1], dataOut[i].AR, dataOut[i].AR);

					buildSizePic(rd.uiPagesContainer[imageIndex1], readerMaxRatio * 0.5, readerMaxRatio * 0.5);
					buildSizePic(rd.uiPagesContainer[imageIndex2], readerMaxRatio * 0.5, readerMaxRatio * 0.5);

					buildSizePic(rd.uiPages[imageIndex1], dataOut[pageRef].AR * 0.5, dataOut[pageRef].AR * 0.5);
					buildSizePic(rd.uiPages[imageIndex2], dataOut[pageRef].AR * 0.5, dataOut[pageRef].AR * 0.5);

					rd.uiPages[imageIndex1].style.objectFit = 'cover';
					rd.uiPages[imageIndex2].style.objectFit = 'cover';

					rd.uiPages[imageIndex1].style.objectPosition = rd.ltr ? 'left' : 'right';
					rd.uiPages[imageIndex2].style.objectPosition = rd.ltr ? 'right' : 'left';

					rd.uiPages[imageIndex1].style.height = rd.uiPagesContainer[imageIndex1].style.height;
					rd.uiPages[imageIndex2].style.height = rd.uiPagesContainer[imageIndex2].style.height;

					if (dataOut[pageRef].isCurrent) rd.currentSpreadIndex = index;
					

				}
				rd.uiSpreads.push(spreadItem);
				readerViewer.appendChild(spreadItem);
				spreadHide(spreadItem);

				const localSpread = index;

				spreadItemThumb.addEventListener('click', () => {
					jumpToSpread(localSpread);
				});
				rd.uiSpreadsThumbs.push(spreadItemThumb);
				thumbStripInner.appendChild(spreadItemThumb);

			});
			console.log("CURRENTINDEX:"+rd.currentSpreadIndex)
			spreadSetFocus(readerHorizontal ? 'focus-center' : (currentPageSingle ? 'focus-center' : (rd.ltr ? 'focus-left-page' : 'focus-right-page')));


				
return dataOut;
		}
/*
			while (i < dataOut.length) {


				 else if (dataOut[i].isDoubleSpread) {




				} else if ((dataOut.length > i + 1)) {
				} else {
					spreadItem.singlePage = true;

					spreadItemThumb.appendChild(rd.uiPagesThumbs[i]);

					spreadItem.appendChild(rd.uiPagesContainer[i]);
					spreadItem.classList.add('single-page')

					buildSize(spreadItem, dataOut[i].AR);

					rd.uiPages[i].style.width = rd.uiPagesContainer[i].style.width = spreadItem.style.width;
					rd.uiPages[i].style.height = rd.uiPagesContainer[i].style.height = spreadItem.style.height;
					if (dataOut[i].isCurrent) rd.currentSpreadIndex = spreadTotal;
					i++;
				}
				const localSpread = spreadTotal;

				spreadTotal++;

				rd.uiSpreadsPagenums.push(spreadArray);
				rd.uiSpreadsImageRefs.push(spreadImagesArray);

	

			}

			spreadSetFocus(readerHorizontal ? 'focus-center' : (currentPageSingle ? 'focus-center' : (rd.ltr ? 'focus-left-page' : 'focus-right-page')));

			console.log(rd.uiSpreadsPagenums);
			console.log(rd.uiSpreadsImageRefs);

			return dataOut;
		}
*/
		
		// Starts timeout for element id of the preload stack
		function startTimeout(id, duration, callback) {
			const timeoutId = setTimeout(() => {
				// Execute the callback when the timeout finishes
				callback();
				delete rd.preloadStack[id];
			}, duration);

			// Add the timeoutId to the stack
			rd.preloadStack[id] = timeoutId;
		}

		// Function to clear all timeouts (optional, if you need this functionality)
		function clearAllTimeouts() {
			Object.values(rd.preloadStack).forEach(timer => {
				clearTimeout(timer);
			});
			rd.preloadStack = {};
		}

		// Calculate stack size for the image loading stack
		function picLoadStackSize() {
			let out = 0;
			rd.picLoadStack.forEach(element => {
				out += rd.uiPages[element].size;
			});
			return (out);
		}

		function printStack(str_in) {
			return; //XXX Disable debug of preload stack
			let out = str_in + ' *';
			rd.picLoadStack.forEach(element => {
				out = out + ' ' + element;
			})
			out = 'tot:' + rd.picLoadStack.length + ' ' + out + ' *';
			console.log(out);
		}

		// Actually load media in the selected index, isPreload is true if the population action is
		// triggered by a preload, so it doesn't trigger further preloads

		async function populateSpread(spreadIndex, isPreload = false) {
			if (isSectionHidden(readerContainer)) return; //XXX THIS IS PROBABLY THE BEST

			const promises = rd.uiSpreadsImageRefs[spreadIndex].map(async (element, index) => {
				if (rd.picLoadStack.indexOf(element) == -1) {
					if (!rd.uiPages[element].hasSrc) {
						//rd.uiPages[element].src = 'anim5.gif';
						rd.picLoadStack.push(element); // Add to the stack
						printStack('S');
						rd.uiPages[element].classList.add('loading');
						try {
							// Fetch the image
							const blobUrl = await fetchMedia(rd.uiPages[element].lazySrc);
							rd.uiPages[element].src = blobUrl;
							rd.uiPages[element].hasSrc = true;
							//rd.uiPages[element].src = rd.pages[element].url;
							// Handle successful load
							rd.uiPages[element].addEventListener('load', () => {
								rd.uiPages[element].classList.add('loaded');
								rd.uiPages[element].classList.remove('hidden');
								rd.uiPages[element].classList.remove('loading');
								if (isSectionHidden(readerContainer)) {
									printStack('LX ');
									return;
								}
								const index = rd.picLoadStack.indexOf(element);
								printStack('L ' + index);
								if (index !== -1) {
									rd.picLoadStack.splice(index, 1); // Remove from stack
								};
								if (!isPreload) {
									preloadPages(spreadIndex, rd.preloadCount)
								}
							});

						} catch (error) {
							console.error(`Failed to load image for element ${element}:`, error);
							// Handle error (optional: remove from stack or show fallback)
						}
					}

					// Immediately handle cached images
					else if (rd.uiPages[element].complete) {
						rd.uiPages[element].classList.add('loaded');
						rd.uiPages[element].classList.remove('hidden');
						rd.uiPages[element].classList.remove('loading');
						const index = rd.picLoadStack.indexOf(element);
						if (index !== -1) {
							rd.picLoadStack.splice(index, 1);
						}
						//XXX REMOVED Force preload when landing on a cached image

						if (!isPreload) {
							preloadPages(spreadIndex, rd.preloadCount)
						}
					}
				}
			});

			// Wait for all fetches to complete
			await Promise.all(promises);
		}

		function handleLeftArrow() {
			if (readerHorizontal) {
				jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? -1 : 1), "focus-center");
			} else {
				if ((rd.uiSpreads[rd.currentSpreadIndex].singlePage)) {
					jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? -1 : 1), rd.ltr ? "focus-left-page" : "focus-right-page");
				}
				else {
					if (rd.spreadFocus == 'focus-right-page') {
						spreadSetFocus('focus-left-page', true);
					}
					else {
						jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? -1 : 1), "focus-right-page");
					}
				}
			}
		}

		function handleRightArrow() {
			if (readerHorizontal) {
				jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? 1 : -1), "focus-center");
			} else {
				if ((rd.uiSpreads[rd.currentSpreadIndex].singlePage)) {
					jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? 1 : -1), rd.ltr ? "focus-right-page" : "focus-left-page");
				}
				else {
					if (rd.spreadFocus == 'focus-left-page') {
						spreadSetFocus('focus-right-page', true);
					}
					else {
						jumpToSpread(rd.currentSpreadIndex + (rd.ltr ? 1 : -1), "focus-left-page");
					}
				}
			}
		}

		function handleLeftLimit() {
			jumpToSpread(rd.ltr ? 0 : rd.uiSpreads.length - 1);
		}
//FIXME Trovar perché sballa pasand oda 0 a last
		function handleRightLimit() {
			jumpToSpread(rd.ltr ? rd.uiSpreads.length - 1 : 0);
		}

		function handleSmallThumbs() {
			setThumbZoom(false);
		};

		function handleLargeThumbs() {
			setThumbZoom(true);
		};


		function getPage(index) {
			let pageNumber = (1 + Number((rd.ltr
				? rd.uiSpreadsPagenums[index][0]
				: rd.uiSpreadsPagenums[index][1] ?? rd.uiSpreadsPagenums[index][0]))
			);

			const twoPages = rd.uiSpreads[index].classList.contains("two-pages");
			const lastSpread = (twoPages && (index == (rd.uiSpreads.length - 1)));

			const out = [
				(lastSpread && rd.ltr) ? pageNumber + 1 : pageNumber,
				pageNumber + (twoPages ? " " + (pageNumber + (rd.ltr ? 1 : -1)) : "")
			];

			return out;
		}
		//TODO con newpage calcoalto dalla funzione esterna e a ogni bar update, ripulire se serve questa cosa
		function jumpString() {
			const stringOut = `${basePath}#bookread
			?library_id=${rd.libraryId}
			&series_id=${rd.seriesId}
			&book_id=${rd.bookId}
			&dir=${rd.ltr ? 'ltr' : 'rtl'}
			&pag=${rd.currentPage}`;

			if (!rd.incognito) {
				callAPI(`/api/v1/books/${rd.bookId}/read-progress`, 'PATCH', JSON.stringify({ page: rd.currentPage }), false)
					.then(data => console.log('Read progress updated:', data))
					.catch(error => console.error('Error:', error));
			}

			return (stringOut);
		}

		function purgeLoading() {
			for (let i = rd.picLoadStack.length - 1; i >= 0; i--) {
				const item = rd.picLoadStack[i];
				rd.uiPages[item].hasSrc = false;
				rd.uiPages[item].src = 'transparent.png';
				rd.picLoadStack.splice(i, 1); // Remove the element at index i
				printStack('P');
			}
			clearAllTimeouts();
		}

		// Thumbnail scrolling functions
		function smoothScroll(container, targetScrollLeft, duration = 500) {
			const start = container.scrollLeft;
			const change = targetScrollLeft - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollLeft = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}

			requestAnimationFrame(animateScroll);
		}

		function centerThumb(fast = false) {
			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInner.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInner.children[rd.currentSpreadIndex]; // n-th element (0-based index)
			console.log("TARGET");
			console.log(targetElement);
			if (targetElement) {
				// Step scroll
				//	thumbStrip.scrollLeft = - thumbStrip.clientWidth / 2 + targetElement.offsetLeft - thumbStrip.offsetLeft + targetElement.clientWidth / 2;

				// Smooth Scroll
				/*
				thumbStrip.scrollTo({
					left: -thumbStrip.clientWidth / 2 + targetElement.offsetLeft - thumbStrip.offsetLeft + targetElement.clientWidth / 2,
					behavior: "smooth"
				});			
				*/

				const targetScrollLeft = -thumbStrip.clientWidth / 2 + targetElement.offsetLeft - thumbStrip.offsetLeft + targetElement.clientWidth / 2;

				if (!fast) {
					smoothScroll(thumbStrip, targetScrollLeft, 300);
				} else {
					//smoothScroll(thumbStrip, targetScrollLeft, 150);
					thumbStrip.scrollLeft = targetScrollLeft;
				};

				thumbStripInner.children[rd.currentSpreadIndex].classList.add('current');

				/*	thumbStrip.scrollTo({
						left: -thumbStrip.clientWidth / 2 + targetElement.offsetLeft - thumbStrip.offsetLeft + targetElement.clientWidth / 2,
						behavior: 'smooth' // Enable smooth scrolling
					});
				*/
			}
		}

		function pageTurn(index, oldindex, turnDirection) {
			const turnSpeed = 500;
			//turnDirection can be "turn-right" or "turn-left"

			rd.uiSpreads[index].style.zIndex = rd.uiSpreads.length + 1;

			// TODO Sistemare le cover in modo che siano anche quelle single page e poi togliere questo fix
			//if (rd.uiSpreadsImageRefs[index].length == 1) return;
			
			if (rd.uiSpreadsImageRefs[index].length != 1) {
				if (turnDirection == 'turn-right') {
					rd.uiSpreads[oldindex].style.zIndex = rd.ltr ? rd.uiSpreads.length - oldindex : oldindex;

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][rd.ltr ? 1 : 0]].animate(
						[
							{ clipPath: 'inset(0 0 0 100%)', left: '-100%' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)', left: '0%' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][rd.ltr ? 0 : 1]].animate(
						[
							{ clipPath: 'inset(0 100% 0 0)' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
				} else {
					rd.uiSpreads[oldindex].style.zIndex = rd.ltr ? oldindex : rd.uiSpreads.length - oldindex;

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][rd.ltr ? 0 : 1]].animate(
						[
							{ clipPath: 'inset(0 100% 0 0)', left: '100%' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)', left: '0%' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][rd.ltr ? 1 : 0]].animate(
						[
							{ clipPath: 'inset(0 0 0 100%)' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
				}
			} else {
				let cover = rd.uiSpreadsKind[index] == 'cover-page';

				if (turnDirection == 'turn-right') {
					rd.uiSpreads[oldindex].style.zIndex = rd.ltr ? rd.uiSpreads.length - oldindex : oldindex;

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][0]].animate(
						[
							{ clipPath: 'inset(0 0 0 100%)', left: '-100%' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)', left: '0%' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
					rd.uiPagesContainer[rd.uiSpreadsImageRefs[oldindex][cover ? 0 : 1]].animate(
						[
							{ clipPath: 'inset(0 0 0 0)' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 100%)' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
					spreadSetFocus('focus-right-page', true);
				} else {
					rd.uiSpreads[oldindex].style.zIndex = rd.ltr ? oldindex : rd.uiSpreads.length - oldindex;

					rd.uiPagesContainer[rd.uiSpreadsImageRefs[index][0]].animate(
						[
							{ clipPath: 'inset(0 100% 0 0)', left: '100%' }, // Fully clipped
							{ clipPath: 'inset(0 0 0 0)', left: '0%' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
					rd.uiPagesContainer[rd.uiSpreadsImageRefs[oldindex][cover ? 0 : 1]].animate(
						[
							{ clipPath: 'inset(0 0 0 0)' }, // Fully clipped
							{ clipPath: 'inset(0 100% 0 0)' } // Fully visible
						],
						{ duration: turnSpeed, easing: "ease", fill: "forwards" }
					);
				}
			}
		}

		//TODO Verificare negli altri casi se usare una spreadClass neutra
		function jumpToSpread(newSpreadTarget, spreadClass = null, turnDirection = null) {

			buildFlock(readerViewer, newSpreadTarget, rd.uiSpreads.length)

			const localOldSpreadIndex = rd.currentSpreadIndex;
			const localNewSpreadIndex = newSpreadTarget;

			if ((newSpreadTarget < 0) || (newSpreadTarget >= rd.uiSpreads.length) || (localOldSpreadIndex == localNewSpreadIndex)) return;

			if (readerHorizontal || rd.uiSpreads[localNewSpreadIndex].singlePage) {
				spreadClass = "focus-center"
			}

			purgeLoading();

			rd.oldSpreadIndex = localOldSpreadIndex;
			rd.currentSpreadIndex = localNewSpreadIndex;

			if (isSectionHidden(readerContainer)) return;


			spreadHide(rd.uiSpreads[localOldSpreadIndex]);

			populateSpread(localNewSpreadIndex);

			spreadSetFocus(spreadClass == null ? (rd.ltr ? "focus-left-page" : "focus-right-page") : spreadClass, true);

			spreadShow(rd.uiSpreads[localNewSpreadIndex]);

			/*
			rd.uiSpreads[localNewSpreadIndex].animate(
				[{transform: 'translate(-100%, -50%)'},{transform: 'translate(-50%, -50%)'}],
				{ duration: 550, easing: "linear", fill: "forwards" }
			)
			*/
			let turnDirectionCalc = null;

			if (turnDirection != null) {
				pageTurn(localNewSpreadIndex, localOldSpreadIndex, turnDirection)
			} else {
				if (rd.ltr) {
					turnDirectionCalc = (localNewSpreadIndex > localOldSpreadIndex) ? 'turn-left' : 'turn-right';
				} else {
					turnDirectionCalc = (localNewSpreadIndex > localOldSpreadIndex) ? 'turn-right' : 'turn-left';
				}
				pageTurn(localNewSpreadIndex, localOldSpreadIndex, turnDirectionCalc)
			}

			centerThumb();
			updateProgressBar();
			history.replaceState(null, '', jumpString());
		}

		// Reader UI Control Buttons
		function toggleMenu() {
			sectionToggle(controlPanel);
			touchPanel.classList.toggle('shrink');
		}

		function hideMenu() {
			sectionHide(controlPanel);
			touchPanel.classList.remove('shrink');
		}

		leftArrow.addEventListener('click', handleLeftArrow);
		rightArrow.addEventListener('click', handleRightArrow);
		leftLimit.addEventListener('click', handleLeftLimit);
		rightLimit.addEventListener('click', handleRightLimit);

		toLeftPage.addEventListener('click', handleLeftArrow);
		toRightPage.addEventListener('click', handleRightArrow);
		openMenu.addEventListener('click', toggleMenu);

		// Seek function to move to specific spread based on click or drag
		function seek(event) {
			const progressBarWidth = readerProgressBar.offsetWidth;
			const clickX = event.clientX - readerProgressBar.getBoundingClientRect().left;
			const newProgressPercent = Math.min(1, Math.max(0, rd.ltr ? clickX / progressBarWidth : (progressBarWidth - clickX) / progressBarWidth));

			jumpToSpread(Math.floor(newProgressPercent * (rd.uiSpreads.length - 1)));
		}

		// Dragging the progress bar
		readerProgressBar.addEventListener('mousedown', (event) => {
			rd.isDraggingProgressBar = true;
			event.preventDefault();

			seek(event);
		});
		readerProgressBar.addEventListener('touchstart', (event) => {
			rd.isDraggingProgressBar = true;
			seek(event.touches[0]); // Use the first touch point
		});


		mainContainer.addEventListener('scroll', function () {

			if (!isSectionHidden(seriesMiniHeader)) {
				if ((mainContainer.scrollTop > 180) && (seriesMiniHeader.classList.contains('collapse'))) {
					seriesMiniHeader.classList.remove('collapse');
				} else if ((mainContainer.scrollTop < 200) && !seriesMiniHeader.classList.contains('collapse')) {
					seriesMiniHeader.classList.add('collapse');
				}
			}

			if (!isSectionHidden(stripGridContainer)) {
				if ((mainContainer.scrollTop < 5) && (stripGridHeaderContainer.classList.contains('collapse'))) {
					stripGridHeaderContainer.classList.remove('collapse');
				} else if ((mainContainer.scrollTop > 10) && !stripGridHeaderContainer.classList.contains('collapse')) {
					stripGridHeaderContainer.classList.add('collapse');
				}
			}
		});

		seriesMiniHeader.addEventListener('click', () => {
			mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
		});

		document.addEventListener('mousemove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event);
			}
		});
		document.addEventListener('touchmove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event.touches[0]); // Use the first touch point
			}
		});

		document.addEventListener('mouseup', () => {
			rd.isDraggingProgressBar = false;
		});
		document.addEventListener('touchend', () => {
			rd.isDraggingProgressBar = false;
		});

		document.addEventListener('keydown', (event) => {
			if (event.key === 'ArrowLeft') {
				if (!isSectionHidden(readerContainer)) handleLeftArrow();
			} else if (event.key === 'ArrowRight') {
				if (!isSectionHidden(readerContainer)) handleRightArrow();
			} else if (event.key === 'Escape' || event.key === 'ArrowDown') {
				if (!isSectionHidden(readerContainer)) handleCloseReader();
			} else if (event.code === 'Space' || event.key === ' ') {
				if (!isSectionHidden(readerContainer)) toggleMenu();
			}
		});

		document.addEventListener('pointerup', (event) => {
			if (currentlyScaled && !currentlyScaled.contains(event.target)) {
				currentlyScaled.classList.remove('scaled');
				currentlyScaled = null;
			}
		});

		//MB URL Parsing and LoadContent Function 
		function parseHashAndParams() {
			const fullHash = window.location.hash.substring(1); // Remove leading '#'
			const [path, paramString] = fullHash.split('?'); // Separate path and parameters
			const params = paramString == undefined ? null : new URLSearchParams(paramString ?? '');
			return { path, params };
		}

		async function loadContent() {
			const { path, params } = parseHashAndParams();

			await executeFade(1);
			document.querySelectorAll('.section').forEach(section => sectionHide(section));
			libraryMenu.classList.add('disabled');
			sectionHide(extraMenuBar);
			closeBookDetails();
			screenAR = getScreenAR();

			switch (path) {
				case '':
				case 'dashboard':
					searchInput.value = '';
					setIncognito(false);
					if ((params == null) || (params.size == 0)) {
						await selectHome();
						if (dashboardBin) {
							const y = dashboardElements[dashboardBin].element.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop - 10;

							mainContainer.scrollTo({ top: y });
							dashboardBin = '';
						}
					} else {
						dashboardAll(params.get('all'), params.get('page'));
					}
					break;
				case 'library':
					dashboardBin = '';;
					searchInput.value = '';
					setIncognito(false);
					await openLibrary(params.get('library_id'), params.get('series_id'));
					break;
				case 'series':
					searchInput.value = '';
					setIncognito(false);
					await openSeries(params.get('library_id'), params.get('series_id'), params.get('book_id'));
					break;
				case 'search':
					setIncognito(false);
					searchInput.value = params.get('search_string');
					await performSearch(params.get('search_string'));
					break;
				case 'bookread':
					await readBook(params.get('library_id'), params.get('series_id'), params.get('book_id'), params.get('dir'), params.get('pag'));
					break;
				default:
					console.log('no selection');
			}
			await executeFade(0);
		}

		function navigateTo(path) {
			history.pushState(null, '', basePath + path);
			loadContent();
		}

		// Lazy-loading setup with Intersection Observer
		const observer = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				if (entry.isIntersecting) {
					const img = entry.target;
					img.classList.add('loading');

					// Set the actual src from lazySrc
					const imageUrl = await fetchMedia(img.lazySrc);
					img.src = imageUrl;

					// Remove lazySrc to clean up
					delete img.lazySrc;

					img.addEventListener('load', () => {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
						setTimeout(() => {
							img.classList.remove('loaded');
							img.classList.add('finished');
						}, 1000);
					});
					if (img.complete) {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
					}
					// Stop observing this image
					observer.unobserve(img);
				}
			});
		});

		// Function to add lazy loading to an image
		function addLazyLoading(img) {
			observer.observe(img);
		}

		window.addEventListener('hashchange', loadContent);
		document.addEventListener('popstate', loadContent);

		if (loginScreen.classList.contains('auth-hidden')) bootSequence();


		//MB Reader touch response fucntions

		function enableTouchResponse(item, threshold, onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown) {
			item.SingleTouch = true;
			item.TouchStartX = 0;
			item.TouchStartY = 0;

			function handleTouchStart(event) {
				if (window.visualViewport.scale > 1.01) return;
				if (event.touches.length > 1) {
					item.SingleTouch = false; // Multiple touches: ignore for swipe
					return;
				}
				item.SingleTouch = true;
				item.TouchStartX = event.touches[0].clientX;
				item.TouchStartY = event.touches[0].clientY;
			}

			function handleTouchMove(event) {
				if (window.visualViewport.scale > 1.01 || !item.SingleTouch) return;

				const touchEndX = event.touches[0].clientX;
				const touchEndY = event.touches[0].clientY;

				const diffX = touchEndX - item.TouchStartX;
				const diffY = touchEndY - item.TouchStartY;


				if (Math.abs(diffX) > threshold && Math.abs(diffY) < threshold) {
					if (diffX > 0) {
						onSwipeRight?.(); // Call custom right swipe function
					} else {
						onSwipeLeft?.(); // Call custom left swipe function
					}
					item.SingleTouch = false; // Prevent repeat action on the same swipe
				} else if (Math.abs(diffY) > threshold && Math.abs(diffX) < threshold) {
					if (diffY > 0) {
						onSwipeDown?.(); // Call custom down swipe function
					} else {
						onSwipeUp?.(); // Call custom up swipe function
					}
					item.SingleTouch = false;
				}
			}

			item.addEventListener('touchstart', handleTouchStart);
			item.addEventListener('touchmove', handleTouchMove);
		}

		enableTouchResponse(touchPanel, 30, handleRightArrow, handleLeftArrow, null, handleCloseReader);
		enableTouchResponse(thumbStrip, 20, null, null, handleLargeThumbs, handleSmallThumbs);

	</script>
</body>

</html>