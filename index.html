<!DOCTYPE html>
<html lang="en">

<head>
	<title>MangaBox</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="theme-color" content="black">

	<!--<link rel="icon" href="ab_16_alpha.png" type="image/png">-->
	<link rel="icon" href="mangabox-logo-16.svg" type="image/svg+xml">
	<link rel="apple-touch-icon" href="mangabox-logo-new-red.png">


	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap" rel="stylesheet">


	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="manifest" href="manifest.json">
	<link rel="stylesheet" type="text/css" href="auth.css">

	<link rel="stylesheet" href="fontawesome/all.min.css">

	<link rel="stylesheet" href="mangabox-main.css">
	<link rel="stylesheet" href="mangabox-reader.css">

</head>

<body>
	<div id="mainUI">
		<div id="menuBars">
			<div id="stickyContainer" class="hidden">
				<ul id="librariesList"></ul>
				<ul id="librariesRightBlock">
					<li id="fullscreenChanger" title="Toggle Fullscreen" class="library-item press-button">
						<div class="button-wrapper">
							<span id="fullscreenLabel" class="fa-expand fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="themeChanger" title="Light/Dark Theme" class="library-item press-button">
						<div class="button-wrapper">
							<span id="themeLabel" class="theme-label fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="colorChanger" title="Theme Color" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-paint-roller glyph-dark mb-accent"></span>
						</div>
					</li>
					<li id="searchField" title="Search" class="library-item search-field press-button">
						<div id="searchIcon" class="button-wrapper">
							<span class="fa-solid fa-magnifying-glass glyph-dark"></span>
						</div>
						<input id="searchInput" type="text" class="search-input" placeholder="Search...">
					</li>
					<li id="logOut" title="Logout" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-arrow-right-from-bracket glyph-dark"></span>
						</div>
					</li>
				</ul>
			</div>

			<div id="filtersBar" class="extra-bar hidden">
				<ul id="extraButtons" class="filters-list buttons"></ul>
			</div>

			<div id="colorSwatchBar" class="extra-bar hidden">
			</div>

		</div>
		<div class="scrollbox" data-scroll-direction="vertical">
			<div id="mainContainer" class="scrollbox-content">
				<div id="seriesHeader" class="section hidden"></div>

				<div id="seriesGrid" class="section hidden"></div>

				<div id="booksGrid" class="section hidden"></div>

				<div id="stripGridContainer" class="section hidden">
					<div id="stripGrid" class="strip-grid"></div>
					<div id="stripGridHeaderContainer" class="stripgrid-header-container">
						<div id="stripGridHeader" class="strip-header">
							<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading
						</div>
						<div id="stripGridRight" class="stripgrid-all">
							<span id="stripPrevPage" title="Previous Page" class="fa-solid fa-play flip-horizontal glyph-dark press-flat-button"></span>
							<span id="stripNextPage" title="Next Page" class="fa-solid fa-play glyph-dark press-flat-button"></span>
						</div>
					</div>
				</div>

				<div id="seriesMiniHeader" class="section hidden collapse"></div>

				<div id="homeStripsContainer" class="section hidden"></div>

				<div id="searchStripsContainer" class="section hidden">
					<div class="strip-header-container">
						<div class="strip-header"><span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Series Results</div>
					</div>
					<div id="homeStripSeriesResults" class="series-results search-results"></div>

					<div class="strip-header-container">
						<div class="strip-header"><span class="fa-solid fa-book glyph-dark"></span>&nbsp;Books Results</div>
					</div>
					<div id="homeStripBooksResults" class="books-results search-results"></div>
				</div>

				<div id="bookDetailsContainer" class="section hidden"></div>

				<div id="blanker"></div>
			</div>
			<div class="scrollbox-scrollbar">
				<div class="scrollbox-thumb"></div>
			</div>
		</div>
	</div>

	<div id="readerContainer" class="section hidden">
		<div id="readerBackground" class="hidden"></div>

		<div id="readerViewer"></div>

		<div id="readerOverlay">
			<div id="incognitoMark"></div>

			<div id="touchPanel">
				<div id="toLeftPage"></div>
				<div id="openMenu"></div>
				<div id="toRightPage"></div>
			</div>

			<div id="controlPanel" class="hidden">
				<div id="topControls">
					<span id="readerClose" title="Close Reader" class="reader-buttons press-button corner-circle fa-solid fa-xmark"></span>
					<span></span>
					<span id="bookName"></span>
					<span id="readerTheme" title="Reader Theme" class="reader-buttons press-button corner-left fa-solid"></span>
					<span id="readerIncognito" title="Incognito Reading" class="reader-buttons press-button corner-right fa-solid fa-ghost"></span>
				</div>

				<div id="thumbStrip" class="scrollbox" data-scroll-direction="horizontal">
					<div id="thumbStripScrollContent" class="scrollbox-content">
						<div id="thumbStripInner"></div>
					</div>
					<div class="scrollbox-scrollbar">
						<div class="scrollbox-thumb"></div>
					</div>
				</div>
				<div id="thumbStripButton">
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
					<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				</div>

				<div id="bottomControls">
					<span id="leftArrow" class="reader-buttons press-button corner-left fa-solid fa-caret-left"></span>
					<span id="leftLimit" class="bar-note press-button corner-right"></span>
					<div id="readerProgressBar" onclick="seek(event)">
						<div id="readerProgress"></div>
						<div id="readerPage"></div>
					</div>
					<span id="rightLimit" class="bar-note press-button corner-left"></span>
					<span id="rightArrow" class="reader-buttons press-button corner-right fa-solid fa-caret-right"></span>
				</div>
			</div>
		</div>
	</div>

	<div id="dragbar" class="draggable">
		<img id="barLogo" src="mangabox-logo-16.svg">

		<!--<img id="barLogo" src="mangabox-logo-new.svg">-->
		<span id="dragbarAppTitle">MangaBox</span>
		<div id="windowControls" , class="window-controls no-drag">
			<span class="fa-solid fa-window-minimize glyph-dark" id="dragbarMinBtn"></span>
			<span class="fa-regular fa-window-maximize glyph-dark" id="dragbarMaxBtn"></span>
			<span class="fa-solid fa-xmark glyph-dark" id="dragbarCloseBtn"></span>
		</div>
	</div>

	<div id="loginScreen" class="auth-hidden">
		<div id="loginDialog" class="dialog">
			<img src="mangabox-logo-new.svg" width="80px" height="80px">
			<img src="mangabox-logoname.svg" width="280px" style="opacity:0.7; margin-bottom:5px;">

			<div class="input-wrapper" title="Server Address">
				<i class="fas fa-link"></i> <!-- Example icon for the base URL -->
				<input type="text" class="login-input" id="mbBaseUrl" placeholder="Komga Base URL (e.g., https://komga.example.com)">
			</div>

			<div class="input-wrapper" title="Username">
				<i class="fas fa-user"></i> <!-- Icon for username -->
				<input type="text" class="login-input" id="username" placeholder="Username">
			</div>

			<div class="input-wrapper" title="Password">
				<i class="fas fa-lock"></i> <!-- Icon for password -->
				<input type="password" class="login-input" id="password" placeholder="Password">
			</div>

			<div class="login-buttons">
				<div class="remember-me-container">
					<input type="checkbox" id="rememberMe" class="remember-me-checkbox">
					<label for="rememberMe" class="remember-me-label">Remember Me</label>
				</div>
				<button class="login-button" onclick="login()">Login</button>
			</div>

			<p id="loginError" class="error-message auth-hidden">Invalid credentials or server URL, please try again.</p>
		</div>
	</div>

	<div id="myModal" class="modal">
		<div class="modal-content">
			<div id="modalWrapper"><img id="modalImage"></div>
			<p id="modalMessage">This is the message content.</p>
			<button id="modalOk" class="ok press-button">OK</button>
			<button id="modalCancel" class="cancel press-button">Cancel</button>
		</div>
	</div>

	<div id="debuggerObj"></div>

	<script src="auth.js"></script>

	<script>


		//MB Manage Electron titlebar

		const isElectronApp = !!window.electronAPI;

		function enableDragbar(enabled) {
			if (!enabled) {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '0px');
				document.getElementById('dragbar').style.display = 'none';
			} else {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '22px');
				document.getElementById('dragbar').style.display = '';
			}
		}

		if (isElectronApp) {
			dragbarMinBtn.addEventListener('click', () => {
				window.electronAPI.minimize();
			});

			dragbarMaxBtn.addEventListener('click', () => {
				window.electronAPI.maximize();
			});

			dragbarCloseBtn.addEventListener('click', () => {
				window.electronAPI.close();
			});

			window.electronAPI.onFullscreenChange((isFullscreen) => {
				enableDragbar(!isFullscreen);
			});

			window.electronAPI.onMaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-maximize');
				dragbarMaxBtn.classList.add('fa-window-restore');
			});

			window.electronAPI.onUnmaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-restore');
				dragbarMaxBtn.classList.add('fa-window-maximize');
			});

			window.electronAPI.getAppVersion().then(version => {
				dragbarAppTitle.textContent = 'MangaBox v' + version;
			});
		}

		// Hide dragbar in PWA mode
		(function () {
			enableDragbar(isElectronApp);
		})();


		//MB General Functions 
		function debugPrint(text) {
			debuggerObj.innerText = debuggerObj.innerText + text;
		}

		function addItem(itemkind, properties) {
			const { style, ...rest } = properties;
			const element = Object.assign(document.createElement(itemkind), rest);
			if (style) Object.assign(element.style, style);
			return element;
		}

		function getScreenAR() {
			return (window.innerWidth / window.innerHeight);
		}

		function toggleFullscreen() {
			if (!document.fullscreenElement) {
				document.documentElement.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		}

		document.addEventListener('fullscreenchange', updateFullscreenLabel);

		function updateFullscreenLabel() {
			fullscreenLabel.classList.remove('fa-expand', 'fa-compress');
			if (document.fullscreenElement) {
				fullscreenLabel.classList.add('fa-compress');
			} else {
				fullscreenLabel.classList.add('fa-expand');
			}
		}

		//MB Main Variable Setup 

		// Main MangaBox data structure, for variables that are common to the whole app
		let mb = {

			libMenuVisible: null,
			swatchMenuVisible: false,

			authHeader: localStorage.getItem('mbAuthHeader'),
			baseUrl: localStorage.getItem('mbBaseUrl'),
			rememberMe: localStorage.getItem('mbRememberMe'),

			basePath: '', //'/mangabox/'
			darkTheme: false,

			// Scaling of selected item control
			currentlyScaled: null,

			// Current book references for book details
			currentBook: null,
			prevBook: null,
			nextBook: null,

			// Screen aspect ratio functions
			screenAR: getScreenAR(),
			readerMaxRatio: 1,
			readerHorizontal: true,
			resizeTimeout: null,

			// Filter table placeholders
			filterTable: null,
			filterButtons: null,
			filterSizer: null,

			libraryMenuButtons: {},

			libSizer: {}, // Used to calculate libraries button size
			dashboardBin: "",
			/*
				When an item from a bin is opened, the mb.dashboardBin is set, so when the dashboard is reloaded
				it reads this variable, if it is not "" the focus is shifted to the bin, and the variable is cleared.
				In this way subsequent clicks on dashboard button will load the top position.
				This variable is cleared whenever a new "Navigate To" is called that is not to dashboard
			*/

			// Theme management variables
			themeControl: [
				{
					label: "Light theme",
					icon: "fa-sun",
					isDark: 0
				}, {
					label: "Dark theme",
					icon: "fa-moon",
					isDark: 1
				}, {
					label: "System theme",
					icon: "fa-wand-magic-sparkles",
					isDark: 2
				}
			],

			readerThemeControl: [
				{
					label: "Classic theme",
					icon: "fa-palette",
					style: "classic"
				}, {
					label: "Dark accent",
					icon: "fa-moon",
					style: "dark-accent"
				}, {
					label: "Light accent",
					icon: "fa-sun",
					style: "light-accent"
				}, {
					label: "White",
					icon: "fa-w",
					style: "white"
				}, {
					label: "Black",
					icon: "fa-b",
					style: "black"
				}
			],

			swatchesHi: getComputedStyle(document.documentElement)
				.getPropertyValue('--mb-swatches-hi')
				.match(/hsl\([^)]*\)/g)
				.map(swatch => swatch.match(/(\d+%?)/g)),

			swatchesLo: getComputedStyle(document.documentElement)
				.getPropertyValue('--mb-swatches-lo')
				.match(/hsl\([^)]*\)/g)
				.map(swatch => swatch.match(/(\d+%?)/g)),

			// Media Cache
			mediaCache: new Map(), 	//Media cache table structure
			cacheLimit: 250,			//Limit of items in media cache

			prefersDarkMode: window.matchMedia('(prefers-color-scheme: dark)'),

		}
		//TODO: make this a function that repsonds to theme changes and create/colorizes the blocks? and maybe use it at bootsequence
		const colorValues = getComputedStyle(document.documentElement)
			.getPropertyValue('--mb-swatches-hi')
			.match(/hsl\([^)]*\)/g);

		colorValues.forEach((value, index) => {
			const appleColor = [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1];
			const colorSwatch = addItem('span', {
				className: 'color-swatch press-flat-button-shallow', //TODO tornare ai vecchi modi?
				innerHTML: appleColor[index] == 1 ? '<i class="fa-brands fa-apple"></i>' : '',
				style: {
					backgroundColor: value,
				},
			});
			addPressEvents(colorSwatch, scaleDownShallow, scaleUp);
			colorSwatch.addEventListener('click', () => {
				event.stopPropagation();
				mb.accentColor = index;
				applyAccent();
			});
			colorSwatchBar.append(colorSwatch);
		});


		//MB API Call Function 
		async function callAPI(API_url, method = 'GET', body = null, returnval = true) {
			try {
				const response = await fetch(`${mb.baseUrl}${API_url}`, {
					method: method,
					headers: {
						'Authorization': mb.authHeader,
						'Content-Type': 'application/json',
						'skip_zrok_interstitial': '1' // Add header to skip interstitial
					},
					body: body
				});

				if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);

				if (returnval) {
					const output = await response.json();
					return output;
				}
			} catch (error) {
				console.error('Fetch libraries error:', error);
			}
		}

		async function getUserSettings() {
			const settings = await callAPI('/api/v1/client-settings/user/list', 'GET');
			const mangaboxFlat = Object.fromEntries(
				Object.entries(settings)
					.filter(([key]) => key.startsWith("mangabox"))
					.map(([key, obj]) => [key, obj.value])
			);
			return mangaboxFlat
		}

		async function setUserSettings(key, value) {
			const payload = {
				[key]: { value: value },
			};
			await callAPI('/api/v1/client-settings/user', 'PATCH', JSON.stringify(payload), false);
		}

		async function delUserSettings() {
			await callAPI('/api/v1/client-settings/user', 'DELETE', JSON.stringify([
				'mangabox.ui.accentcolor',
				'mangabox.ui.themeprefs',
				'mangabox.ui.readerthemeprefs',
				'mangabox.ui.libraryfilters',
				'mangabox.ui.libraryicons',
			]), false);
		}

		let userSettings;

		//delUserSettings()

		function applyUserSettings() {
			// Local storage variable setup
			mb.accentColor = Number(userSettings['mangabox.ui.accentcolor'] ?? 0);
			mb.themePrefs = Number(userSettings['mangabox.ui.themeprefs'] ?? 0);
			mb.readerThemePrefs = Number(userSettings['mangabox.ui.readerthemeprefs'] ?? 0);
			mb.libraryFilters = JSON.parse(userSettings['mangabox.ui.libraryfilters'] || '{}');
			mb.libraryIcons = JSON.parse(userSettings['mangabox.ui.libraryicons'] || '{}');
		}



		//MB Local Storage Update
		rememberMe.checked = (mb.rememberMe == 'true');

		//Questa cosa qui spostarla quando uno chiude la finestra!
		if (mb.rememberMe != 'true') {
			localStorage.removeItem('mbAuthHeader');
		};

		//MB Theme Management 

		function warmth(hue) {
			const warmth = (Math.cos((hue - 50) * Math.PI / 180) + 1) / 2;
			return warmth;
		}

		function applyAccent() {
			const swatches = mb.darkTheme ? mb.swatchesLo : mb.swatchesHi;

			['--mb-h', '--mb-s', '--mb-l'].forEach((varName, index) => {
				document.documentElement.style.setProperty(varName, swatches[mb.accentColor][index]);
			});
			document.documentElement.style.setProperty('--mb-h-deg', swatches[mb.accentColor][0] + 'deg');

			document.documentElement.style.setProperty('--mb-gradient-1', Number(swatches[mb.accentColor][0]));
			document.documentElement.style.setProperty('--mb-gradient-2', Number(swatches[mb.accentColor][0]) - 10);

			setUserSettings("mangabox.ui.accentcolor", mb.accentColor);
		}

		function swapThemeClass(classSelector, lightClass, darkClass, toDark) {
			Array.from(document.getElementsByClassName(classSelector)).forEach((item) => {
				if (!item.classList.contains('no-theme-icon')) {
					item.classList.remove(toDark ? lightClass : darkClass);
					item.classList.add(toDark ? darkClass : lightClass);
				}
			});
		}

		function updatePWABar(color = null) {
			document.querySelector('meta[name="theme-color"]')
				.setAttribute('content', color ?? (mb.darkTheme ? '#353535' : '#ffffff'));
		}

		function changeTheme() {
			let toDark = false;

			if (mb.themePrefs != 2) {
				toDark = (mb.themePrefs == 1)
			} else {
				toDark = mb.prefersDarkMode.matches ? true : false
			}

			// Set css theme to dark or light
			document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');

			mb.themeControl.forEach(item => {
				themeLabel.classList.remove(item.icon);
			});

			themeLabel.classList.add(mb.themeControl[mb.themePrefs].icon);
			themeLabel.title = mb.themeControl[mb.themePrefs].label;
			// Change fa icons for light or dark theme
			swapThemeClass('fa-file', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-calendar', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-clock', 'fa-regular', 'fa-solid', toDark);

			// Save theme setting in local storage
			setUserSettings('mangabox.ui.themeprefs', mb.themePrefs);

			mb.darkTheme = toDark;

			//Ttheme based top bar
			updatePWABar();

			applyAccent(); //TODO Maybe this substitutes other accent color changes?
		}

		mb.prefersDarkMode.addEventListener('change', changeTheme);

		// Show/Hide section functions
		function sectionHide(item) {
			if (!item.classList.contains('hidden')) item.classList.add('hidden');
		}
		function sectionShow(item) {
			item.classList.remove('hidden');
		}
		function sectionToggle(item) {
			item.classList.toggle('hidden');
		}
		function isSectionHidden(item) {
			return (item.classList.contains('hidden'));
		}

		// Show/Hide reader pages/spreads
		function spreadHide(index) {
			rd.spreadsArray[index].uiItem.classList.add('hidden-spread');
		}
		function spreadShow(index) {
			rd.spreadsArray[index].uiItem.classList.remove('hidden-spread');
		}
		function isSpreadHidden(index) {
			return (rd.spreadsArray[index].uiItem.classList.contains('hidden-spread'));
		}

		colorChanger.addEventListener('click', () => {

			sectionToggle(colorSwatchBar)
			mb.swatchMenuVisible = !mb.swatchMenuVisible
			/*
			mb.accentColor = (mb.accentColor + 1) % mb.swatchesHi.length;
			applyAccent();
			*/
		});

		themeChanger.addEventListener('click', () => {
			mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
			changeTheme();
		})

		fullscreenChanger.addEventListener('click', () => {
			//mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
			//changeTheme();
			toggleFullscreen();
		})

		logOut.addEventListener('click', async () => {
			sectionHide(stickyContainer);
			sectionShow(blanker);
			localStorage.removeItem('mbAuthHeader');
			history.pushState(null, '', mb.basePath);
			location.reload(true);
		})

		searchInput.addEventListener('keydown', (event) => {
			if (event.key === 'Enter') {
				mb.dashboardBin = '';
				if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
			}
		});

		searchIcon.addEventListener('click', () => {
			if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
		})

		//MB Scroll Bars

		function createCustomScrollbar(scrollbox) {
			if (scrollbox.dataset.scrollbarInitialized) return;
			scrollbox.dataset.scrollbarInitialized = 'true';

			const direction = scrollbox.dataset.scrollDirection || 'vertical';
			const isHorizontal = direction === 'horizontal';

			const content = scrollbox.querySelector('.scrollbox-content');
			const scrollbar = scrollbox.querySelector('.scrollbox-scrollbar');
			const thumb = scrollbar.querySelector('.scrollbox-thumb');

			let fadeTimeout;

			function showScrollbarTemporarily() {
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
				fadeTimeout = setTimeout(() => {
					scrollbar.classList.remove('visible');
				}, 1000);
			}

			function updateThumb() {
				const total = isHorizontal ? content.scrollWidth : content.scrollHeight;
				const visible = isHorizontal ? content.clientWidth : content.clientHeight;
				const scroll = isHorizontal ? content.scrollLeft : content.scrollTop;

				const scrollable = total > visible;

				if (!scrollable) {
					scrollbar.classList.remove('visible');
					thumb.style.display = 'none';
					return;
				}

				thumb.style.display = 'block';

				const margin = 10;

				let thumbSize = Math.max((visible / total) * visible, 30);
				let midBoxRate = (scroll / (total - visible));
				let thumbPos = margin + midBoxRate * (visible - 2 * margin - thumbSize);

				if (isHorizontal) {
					thumb.style.width = thumbSize + 'px';
					thumb.style.left = thumbPos + 'px';
				} else {
					thumb.style.height = thumbSize + 'px';
					thumb.style.top = thumbPos + 'px';
				}
			}


			content.addEventListener('scroll', () => {
				updateThumb();
				showScrollbarTemporarily();
			});

			scrollbox.addEventListener('mouseenter', showScrollbarTemporarily);

			// Drag support
			let isDragging = false;
			let startPos, startThumbPos;

			thumb.addEventListener('mousedown', (e) => {
				isDragging = true;
				startPos = isHorizontal ? e.clientX : e.clientY;
				startThumbPos = parseInt(thumb.style[isHorizontal ? 'left' : 'top']) || 0;
				document.body.style.userSelect = 'none';
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				const delta = (isHorizontal ? e.clientX : e.clientY) - startPos;
				const trackSize = isHorizontal ? content.clientWidth : content.clientHeight;
				const newThumbPos = Math.min(trackSize - (isHorizontal ? thumb.offsetWidth : thumb.offsetHeight), Math.max(0, startThumbPos + delta));
				const scrollRatio = newThumbPos / trackSize;
				if (isHorizontal) {
					content.scrollLeft = scrollRatio * content.scrollWidth;
				} else {
					content.scrollTop = scrollRatio * content.scrollHeight;
				}
			});

			document.addEventListener('mouseup', () => {
				if (isDragging) {
					isDragging = false;
					document.body.style.userSelect = '';
					showScrollbarTemporarily();
				}
			});

			const observer = new MutationObserver(updateThumb);
			observer.observe(content, {
				childList: true,
				subtree: true,
				characterData: true,
				attributes: true,
			});

			scrollbox.refreshScrollbar = updateThumb;
			updateThumb();
		}

		document.querySelectorAll('.scrollbox').forEach(createCustomScrollbar);

		//MB Modal Dialog
		let modalOkGlobal = null;
		let modalCancelGlobal = null;

		function showModal(image, bg, message, okText, cancelText, okFunction, cancelFunction) {
			modalOkGlobal = okFunction;
			modalCancelGlobal = cancelFunction;
			modalWrapper.style.backgroundImage = bg ? "" : "none";
			modalImage.src = image;
			modalMessage.textContent = message;
			//myModal.style.display = 'flex';

			myModal.classList.add('visible');

			modalOk.addEventListener('click', modalOkGlobal);
			if (cancelText != null) {
				myModal.classList.remove('ok-only');
				modalCancel.addEventListener('click', modalCancelGlobal);
			} else {
				myModal.classList.add('ok-only');
			}
		}

		function closeModal() {
			modalOk.removeEventListener('click', modalOkGlobal);
			modalCancel.removeEventListener('click', modalCancelGlobal);
			myModal.classList.add("unfade");
			modalImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

			setTimeout(() => {
				// Optional: if you still want to hide it completely from screen readers / tab order
				myModal.classList.remove("visible");
				myModal.classList.remove("unfade");
				workOk = null;
				workCancel = null;
			}, 300);
		}

		//MB Search Functions 

		function timeSplit(inTime) {
			let outTime = inTime ?? '1111';
			outTime = outTime.replace('TBD', '9999').split('-');
			if (outTime.length == 1) outTime.push(outTime[0]);
			return outTime
		}

		async function performSearch(searchString) {
			libraryHighlight('searchField', false);

			if (searchString.includes('y:')) {
				const unFilteredSeries = await callAPI(
					`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
					'POST', `{"condition": {"allOf": []}}`
				);
				const dataArray = unFilteredSeries.content;
				const searchYear = timeSplit(searchString.split('y:')[1].split(' ')[0]);

				let start = 0;
				let stop = 0;
				let filterArray = [];

				for (let i = 0; i < dataArray.length; i++) {
					if (dataArray[i].metadata.alternateTitles.length == 0) {
						filterArray.push(false);
						continue;
					}
					const dateArray = dataArray[i].metadata.alternateTitles.find(item => item.label === 'Time').title.replace('TBD', '5000').split('-');
					start = (Number(dateArray[0]));
					stop = (Number(dateArray[1] ?? dateArray[0]));

					filterArray.push(!((start > Number(searchYear[1])) || (stop < Number(searchYear[0]))));
				}

				const filteredSeries = dataArray.filter((item, index) =>
					filterArray[index]
				);
				displaySeries(filteredSeries, homeStripSeriesResults);
				focusItem('top');
				setTimeout(updateSliderProperties, 10);
				sectionShow(searchStripsContainer);

				return
			}

			const unFilteredSeries = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredSeries = unFilteredSeries.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.titleSort.toLowerCase().includes(searchString) ||
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title.toLowerCase().includes(searchString)
				)
			);
			displaySeries(filteredSeries, homeStripSeriesResults);
			focusItem('top');

			const unFilteredBooks = await callAPI(
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.summary.toLowerCase().includes(searchString) ||
				item.metadata.tags.some(
					tagIn => tagIn.toLowerCase().includes(searchString)
				)
			);
			displayBooks(filteredBooks, homeStripBooksResults, 'compact', 'top');

			setTimeout(updateSliderProperties, 10);
			sectionShow(searchStripsContainer);
		}

		//MB Library Filtering 

		mb.filterTable = {
			sorting: {
				name: 'sorting',
				selected: 0,
				iconClass: 'fa-solid fa-heading glyph-dark',
				item: null,
				icon: null,
				caption: null,
				title: 'Sort items',
				switches: [
					{
						name: 'a_to_z',
						caption: 'by Title',
						iconClass: 'fa-solid fa-arrow-down-a-z glyph-dark',
						sortFunction: (a, b) => a.mbSeriesTitle.localeCompare(b.mbSeriesTitle)
					}, {
						name: 'z_to_a',
						caption: 'by Title',
						iconClass: 'fa-solid fa-arrow-down-z-a glyph-dark',
						sortFunction: (a, b) => b.mbSeriesTitle.localeCompare(a.mbSeriesTitle)
					}, {
						name: '9_to_1',
						caption: 'by Start',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)) - (Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)))
					}, {
						name: '1_to_9',
						caption: 'by Start',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)) - (Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)))
					}, {
						name: '9_to_1',
						caption: 'by End',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)) - (Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)))
					}, {
						name: '1_to_9',
						caption: 'by End',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)) - (Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)))
					}, {
						name: '1_to_9',
						caption: 'Books',
						iconClass: 'fa-solid fa-cubes-stacked fa-flip-vertical glyph-dark',
						sortFunction: (a, b) => (Number(b.mbBooksCount) - Number(a.mbBooksCount))
					}, {
						name: '9_to_1',
						caption: 'Books',
						iconClass: 'fa-solid fa-cubes-stacked glyph-dark',
						sortFunction: (a, b) => (Number(a.mbBooksCount) - Number(b.mbBooksCount))
					}
				],
			},
			filter_by_read: {
				name: 'filter_by_read',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by read status',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-circle-half-stroke glyph-dark',
						filterFunction: (a) => true
					}, {
						name: 'unread',
						caption: 'Unread',
						iconClass: 'fa-regular fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == false)
					}, {
						name: 'read',
						caption: 'Read',
						iconClass: 'fa-solid fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == true)
					}
				],
			},
			filter_by_direction: {
				name: 'filter_by_direction',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by reading direction',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-arrow-right-arrow-left glyph-dark',
						filterFunction: (a) => true

					}, {
						name: 'l_to_r',
						caption: 'L to R',
						iconClass: 'fa-solid fa-arrow-right glyph-dark',
						filterFunction: (a) => (a.mbSeriesLTR == true)

					}, {
						name: 'r_to_l',
						caption: 'R to L',
						iconClass: 'fa-solid fa-arrow-left glyph-dark',
						filterFunction: (a) => (a.mbSeriesLTR == false)
					}
				],
			},
			filter_by_language: {
				name: 'filter_by_language',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by language',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-earth-europe glyph-dark',
						filterFunction: (a) => true
					}
				],
			},
		};

		async function buildLanguageList() {
			const languageList = await callAPI(`/api/v1/languages`);
			languageList.forEach(item => {
				mb.filterTable.filter_by_language.switches.push({
					name: item,
					caption: item.toUpperCase(),
					iconClass: 'fa-solid fa-square glyph-dark glyph-flag-button',
					iconStyle: `background-image:url('flags/${item}.svg')`,
					filterFunction: (a) => a.mbSeriesLanguage == item
				})
			});
		};

		mb.filterButtons = [
			mb.filterTable.sorting,
			mb.filterTable.filter_by_read,
			mb.filterTable.filter_by_direction,
			mb.filterTable.filter_by_language
		];

		function saveLibraryFilters() {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');
			let filterOut = {};
			mb.filterButtons.forEach(button => {
				filterOut[button.name] = button.selected;
			});
			mb.libraryFilters[libraryId] = filterOut;
			setUserSettings('mangabox.ui.libraryfilters', JSON.stringify(mb.libraryFilters));
		}

		function fetchLibraryFilters(libraryId) {
			filterValues = mb.libraryFilters[libraryId];
			if (filterValues) {
				mb.filterButtons.forEach(button => {
					mb.filterTable[button.name].selected = filterValues[button.name];
				});
				applyLibraryFilters()
			}
		}

		async function applyLibraryFilters() {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');

			const divs = Array.from(seriesGrid.children);
			divs.forEach(div => {
				div.infilter = true;
			});

			const isFiltered = Object.values(mb.filterButtons).reduce((sum, item) => sum + (item.selected || 0), 0);

			mb.libraryMenuButtons[libraryId].classList.remove('filtered');
			if (isFiltered != 0) mb.libraryMenuButtons[libraryId].classList.add('filtered');

			mb.filterButtons.forEach(button => {
				button.icon.innerHTML = `<span style="${button.switches[button.selected].iconStyle}" class="${button.switches[button.selected].iconClass}${button.selected != 0 ? ' mb-accent' : ''}"></span>`;
				button.caption.innerHTML = `${button.switches[button.selected].caption}`;

				if (button.switches[button.selected].sortFunction) {
					divs.sort((a, b) => {
						return button.switches[button.selected].sortFunction(a, b);
					});
					divs.forEach((item, index) => {
						item.style.order = index;
					});
				} else {
					divs.forEach((div) => {
						div.infilter = div.infilter && button.switches[button.selected].filterFunction(div);
					});
				}
			});
			divs.forEach((div) => {
				div.style.display = div.infilter ? '' : 'none';
			});
		}

		// Build filter buttons items

		mb.filterButtons.forEach(button => {
			button.item = addItem('li', {
				className: `filter-item press-button`,
				title: button.title,
			});
			button.icon = addItem('div', {
				className: `smallbutton-wrapper`,
				innerHTML: `<span style="${button.switches[0].iconStyle}" class="${button.switches[0].iconClass}"></span>`
			});
			button.caption = addItem('div', {
				className: `library-name`,
				innerHTML: `${button.switches[0].caption}`
			});
			button.item.append(
				button.icon,
				button.caption
			);
			extraButtons.append(button.item);
			button.item.addEventListener('click', async () => {
				button.selected = ((button.selected + 1) % button.switches.length);
				await executeFade(1);
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			})
		});

		extraButtons.append(addItem('li', {
			title: 'Reset filters and sorting',
			className: `filter-item press-button`,
			innerHTML: `<div class="smallbutton-wrapper">
								<span class="fa-solid fa-arrows-rotate fa-flip-horizontal glyph-dark"></span>
							</div>`,
			onclick: async () => {
				await executeFade(1);
				mb.filterButtons.forEach(button => {
					button.selected = 0;
				});
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			}
		}));

		function isReaderHorizontal(screenAR) {
			return (screenAR / mb.readerMaxRatio > rd.orientationThresholdRatio);
		}

		function updateReaderOrientation() {
			let newScreenAR = getScreenAR();

			if (isSectionHidden(readerContainer)) {
				mb.screenAR = newScreenAR;
				mb.readerHorizontal = isReaderHorizontal(newScreenAR);
			} else {
				let newReaderHorizontal = isReaderHorizontal(newScreenAR);
				if (newReaderHorizontal != mb.readerHorizontal) {
					mb.screenAR = newScreenAR;
					mb.readerHorizontal = newReaderHorizontal;
					spreadSetFocusSmooth(getSpreadFocus(rd.currentSpreadIndex));
				}
			}
		}

		// Set the slider max value and grpahics properties based on the scroll width
		function updateSliderProperties() {
			if (isSectionHidden(homeStripsContainer)) return;

			Object.entries(dashboardElements).forEach(([name, item]) => {

				item.scrollInput.max = item.homeStrip.scrollWidth - item.homeStrip.clientWidth;
				const isOverflowing = item.homeStrip.scrollWidth > item.homeStrip.clientWidth;

				item.scrollInput.style.display = isOverflowing ? 'block' : 'none';

				const visibleRatio = item.homeStrip.clientWidth / item.homeStrip.scrollWidth;
				const thumbWidth = (100 * visibleRatio);

				item.scrollInput.style.setProperty('--thumb-width', `${thumbWidth}%`);
			});
		};

		function stepPageChange(increment) {
			const { path, params } = getHashAndParams();
			navigateTo('#dashboard?all=' + params.get('all') + '&page=' + (parseInt(params.get('page')) + increment));
		}

		stripPrevPage.addEventListener('click', () => stepPageChange(-1));
		stripNextPage.addEventListener('click', () => stepPageChange(1));

		function updateStickyMenu() {
			const containerWidth = mainUI.getBoundingClientRect().width;

			if (containerWidth - mb.libSizer.rightmin - mb.libSizer.large >= 0) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');

			} else if (containerWidth - mb.libSizer.rightmin - mb.libSizer.medium >= 0) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-medium');
			} else {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-small');

				if (containerWidth - mb.libSizer.large >= 9) {
					document.body.classList.add('sticky-hybrid');
				}
			};

			if (containerWidth - mb.filterSizer >= 0) {
				extraButtons.classList.remove('filter-small')
			} else {
				extraButtons.classList.add('filter-small')
			}

		}

		window.addEventListener('resize', () => {
			clearTimeout(mb.resizeTimeout);
			mb.resizeTimeout = setTimeout(() => {
				updateStickyMenu();
				updateSliderProperties();
				updateReaderOrientation();
			}, 250);
		});

		function fixZoomOnPWA() {
			let metaViewport = document.querySelector('meta[name="viewport"]');
			if (!metaViewport) return;

			// Disable zoom temporarily
			metaViewport.content = 'width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no';

			// Wait for two animation frames to ensure the change takes effect
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					// Now restore zoom capability
					metaViewport.content = 'width=device-width, initial-scale=1, maximum-scale=5, minimum-scale=1';
				});
			});
		}


		window.addEventListener('orientationchange', fixZoomOnPWA);
		document.addEventListener('visibilitychange', fixZoomOnPWA);
		window.addEventListener('pageshow', (event) => {
			if (event.persisted) fixZoomOnPWA();
		});
		// Fade in and Fade out routines
		function wait(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		async function executeFade(val) {
			blanker.style.opacity = val;
			await wait(100);
		}

		//MB Media Cache 

		async function fetchMedia(url) {
			if (mb.mediaCache.has(url)) {
				// Move the accessed item to the end to mark it as recently used
				const value = mb.mediaCache.get(url);
				mb.mediaCache.delete(url);
				mb.mediaCache.set(url, value);
				return value;
			}

			try {
				const response = await fetch(url, {
					method: 'GET',
					headers: {
						'Authorization': mb.authHeader,
						'skip_zrok_interstitial': '1' // Add header to skip interstitial
					}
				});

				if (response.ok) {
					const blob = await response.blob();
					const objectURL = URL.createObjectURL(blob);

					// Add to cache and enforce size limit
					mb.mediaCache.set(url, objectURL);
					if (mb.mediaCache.size > mb.cacheLimit) {
						// Remove the oldest entry
						const oldestKey = mb.mediaCache.keys().next().value;
						URL.revokeObjectURL(mb.mediaCache.get(oldestKey)); // Revoke object URL
						mb.mediaCache.delete(oldestKey);
					}

					return objectURL;
				} else {
					console.error(`Failed to load media from ${url}`, response.status);
					return 'fallback-image.jpg';
				}
			} catch (error) {
				console.error(`Error fetching media: ${error.message}`);
				return 'fallback-image.jpg';
			}
		}


		// Function to clear the cache entirely
		function clearMediaCache() {
			for (const objectURL of mb.mediaCache.values()) {
				URL.revokeObjectURL(objectURL);
			}
			mb.mediaCache.clear();
		}

		async function setReadStatus(seriesId, bookId, read, item, format) {
			if (bookId == null) {
				await callAPI(`/api/v1/series/${seriesId}/read-progress`, read ? 'POST' : 'DELETE', null, false);
				const seriesData = await callAPI(`/api/v1/series/${seriesId}`);
				buildSeriesItem(item, seriesData, null);
			} else {
				await callAPI(`/api/v1/books/${bookId}/read-progress`, read ? 'PATCH' : 'DELETE', read ? JSON.stringify({ completed: true }) : null, false);
				const { path, params } = getHashAndParams();
				if (path == 'dashboard' || path == '') {
					const oldTop = mainContainer.scrollTop;
					await Promise.all(
						Object.entries(dashboardElements).map(async ([name, item]) => {
							const resultsObject = await item.getItems(0, 20);
							item.showItems(resultsObject.content, item.homeStrip);
						})
					);
					setTimeout(updateSliderProperties, 10);
					mainContainer.scrollTop = oldTop;
				} else {
					const bookData = await callAPI(`/api/v1/books/${bookId}`);
					buildBookItem(item, bookData, format, null);
				}
			}
		}

		async function setSeriesReadStatus(seriesId, read, item) {
			setReadStatus(seriesId, null, read, item, null);
		}

		async function setBookReadStatus(bookId, read, item, format) {
			setReadStatus(null, bookId, read, item, format);
		}

		// Function that fetches the libraries list, sort it by name, then calls displayLibraries to show the fetched libraries
		async function fetchLibraries() {
			const gapSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-gap'));
			const libSmallSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-button-size'));
			const libLargeSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-large'));
			const filterButtonSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-filter-button-size'));
			const searchFieldSize = libLargeSize;
			const margin = 10;

			const libraries = await callAPI('/api/v1/libraries');
			libraries.sort((a, b) => a.name.localeCompare(b.name));
			await displayLibraries(libraries);

			const rightBlockButtons = librariesRightBlock.childElementCount - 1;
			document.documentElement.style.setProperty('--mb-num-buttons', rightBlockButtons - 1);

			const libNum = libraries.length;
			const mainLibAndMenu = margin + libLargeSize + 40;
			mb.libSizer.large = mainLibAndMenu + libNum * (libLargeSize + gapSize);
			mb.libSizer.medium = mainLibAndMenu + libNum * (libSmallSize + gapSize);
			mb.libSizer.rightmin = margin + rightBlockButtons * (libSmallSize + gapSize) + searchFieldSize + gapSize;

			mb.filterSizer = mb.filterButtons.length * (100 + gapSize) + filterButtonSize + 2 * margin;

			updateStickyMenu();
		}


		// This function is called when a library is selected, it manages the library menu and library naming in the URL
		function libraryHighlight(libraryId, withMenu) {
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('highlighted'));
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('with-menu'));
			document.getElementById(libraryId).classList.add('highlighted');
			if (withMenu) document.getElementById(libraryId).classList.add('with-menu');
		}

		async function getFilteredSeries(filterTitle, serieId) {
			const unFilteredSeries = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredItems = unFilteredSeries.content.filter(item =>
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title === filterTitle
				)
			);

			displaySeries(filteredItems, seriesGrid);
			focusItem('top');

		}

		//MB Touch And Hover Scaler 

		function noPointerDown(item) {
			item.addEventListener('pointerup', (event) => {
				event.stopPropagation();
			})
		}

		function addTouchScaler(item, execute) {
			item.addEventListener('pointerup', async (event) => {
				if (event.pointerType === 'touch') {
					// TOUCH DEVICE
					if (mb.currentlyScaled !== item) {
						if (mb.currentlyScaled) {
							mb.currentlyScaled.classList.remove('scaled');
							mb.currentlyScaled.parentElement.classList.remove('top-pop');

						}
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');

						mb.currentlyScaled = item;
						event.preventDefault();
					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');

						mb.currentlyScaled = null;
						*/
						execute();
					}
				} else if (event.button == 0) {
					// MOUSE DEVICE
					if (!item.classList.contains('scaled')) {
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');
						mb.currentlyScaled = item;
					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');
						mb.currentlyScaled = null;
						*/
						execute();
					}
				}
			});

			item.addEventListener('mouseenter', () => {
				// Added this to unselect pre-scaled book
				if (mb.currentlyScaled != null) {
					mb.currentlyScaled.classList.remove('scaled');
					mb.currentlyScaled.parentElement.classList.remove('top-pop');

					// mb.currentlyScaled = null; //TODO check, This was removed but maybe it was needed?
				}
				item.classList.add('scaled');
				item.parentElement.classList.add('top-pop');
			});

			item.addEventListener('mouseleave', () => {
				item.classList.remove('scaled');
				item.parentElement.classList.remove('top-pop');
			});
		}

		function preventHyphenBreaks(str) {
			return str.replace(/-/g, '\u2011')
		}

		//MB Series Items Creation
		async function buildSeriesItem(item, serie, target) {
			item.childNodes[0]?.remove();

			item.title = 'Open series';

			const seriesItem = addItem('div', {
				className: 'series-item'
			});
			const LNG = ((serie.metadata.language != 'en') ? `<span style="background-image:url('flags/${serie.metadata.language}.svg')" class="fa-solid fa-square-full glyph-dark glyph-flag"></span>` : '');
			const LTR = serie.metadata.readingDirection == 'RIGHT_TO_LEFT' ? '' : '<span class="fa-solid fa-clapperboard fa-rotate-270 glyph-dark" style="margin-left:2px;"></span>';
			const spacer = ((LNG != '') && (LTR != '')) ? '&nbsp;' : '';

			const seriesTitle = addItem('div', {
				innerHTML: `
								<div class="title-row data-row top-row">
									<div style="flex-grow:1" class="series-title">${preventHyphenBreaks(serie.metadata.title)}</div>
									<div class="glyph-dark" style="text-align:right">${LTR}</div>
										${spacer}
									<div class="glyph-div" style="text-align:right">${LNG}</div>
								</div>`
			});

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper'
			});

			const seriesThumbnail = addItem('img', {
				className: 'series-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail`,
				alt: serie.metadata.title
			});

			addLazyLoading(seriesThumbnail);

			const seriesFader = addItem('div', {
				className: 'series-fader'
			});

			const seriesOverlay = addItem('div', {
				className: 'series-overlay'
			});

			const seriesStatus = addItem('div', {
				className: 'series-status'
			});

			const unreadCount = serie.booksUnreadCount;

			if (unreadCount > 0) {
				const unreadCountBadge = addItem('div', {
					className: 'unread-count',
					innerHTML: `<span>${unreadCount}</span>`
				});
				seriesStatus.append(unreadCountBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark series as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			markAsRead.addEventListener('click', async (event) => {
				event.stopPropagation();
				await setSeriesReadStatus(serie.id, true, item);
			})
			noPointerDown(markAsRead);

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark series as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			markAsUnread.addEventListener('click', async (event) => {
				event.stopPropagation();
				await setSeriesReadStatus(serie.id, false, item);
			})
			noPointerDown(markAsUnread);

			// Find alternate title with label 'Time'
			const altTitle = getAltTitles(serie);

			// Fetch and display the number of books and alternate title
			const bookCount = serie.booksCount;
			const infoRow = addItem('div', {
				className: 'data-row info-row'
			});

			const timeLabel = addItem('span', {
				innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-calendar glyph-dark'></span>&nbsp;${altTitle.time}`,
				className: 'red search-trigger',
				title: `Filter time: ${altTitle.time}`
			});
			timeLabel.addEventListener('click', async (event) => {
				event.stopPropagation();
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#search?search_string=y:${altTitle.time}`);
			});
			noPointerDown(timeLabel);

			const booksLabel = addItem('span', {
				innerHTML: `<span class='fa-solid fa-book glyph-dark'></span>&nbsp;${bookCount}`
			});

			const artistRow = addItem('div', {
				className: 'data-row artist-row'
			});

			if (altTitle.story != altTitle.art) {

				const storyLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-pen-to-square glyph-dark'></span>&nbsp;${altTitle.story}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.story}`
				});

				const artLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-palette glyph-dark'></span>&nbsp;${altTitle.art}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.art}`
				});

				artistRow.append(storyLabel, artLabel);
				storyLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
				});
				artLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.art.toLowerCase()}`);
				});
				noPointerDown(artLabel);
				noPointerDown(storyLabel);
			} else {
				const artistLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-user glyph-dark'></span>&nbsp;${altTitle.story}`,
					title: `Filter artist: ${altTitle.story}`,
					className: 'red data-label search-trigger'
				});
				artistRow.append(artistLabel);
				artistLabel.addEventListener('click', async (event) => {
					event.stopPropagation();
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
				});
				noPointerDown(artistLabel);
			}

			item.mbSeriesTitle = serie.metadata.title ?? '';

			item.mbSeriesStart = timeSplit(altTitle.time)[0];
			item.mbSeriesStop = timeSplit(altTitle.time)[1];

			item.mbBooksCount = serie.booksCount;

			item.mbSeriesRead = (unreadCount == 0);
			item.mbSeriesLTR = (serie.metadata.readingDirection == 'LEFT_TO_RIGHT');
			item.mbSeriesLanguage = serie.metadata.language;

			seriesItem.append(
				thumbnailWrapper,
				seriesTitle,
				infoRow,
				artistRow
			);
			thumbnailWrapper.append(
				seriesThumbnail,
				seriesFader,
				seriesOverlay,
				seriesStatus
			);
			seriesOverlay.append(
				markAsRead,
				markAsUnread
			);
			infoRow.append(
				timeLabel,
				booksLabel
			);

			addTouchScaler(seriesItem, () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#series?library_id=${serie.libraryId}&series_id=${serie.id}`)
			});

			item.append(seriesItem);
		}

		// Creates and populates the series grid with the data from the series array.
		async function displaySeries(series, target) {

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {

				const seriesContainer = addItem('div', {
					className: 'series-container', //XXX was ending with , 'fade-in');
					id: serie.id,
				});

				buildSeriesItem(seriesContainer, serie, target);

				target.append(seriesContainer);
			});

			sectionShow(target); //XXX serve un fade qui???
		}

		// Function that fetches all the series list within a library, sorted by name, then calls displaySeries to show the fetched series
		async function fetchAllSeries(libraryId) {
			let allSeries = [];
			const allSeriesPage = await callAPI(
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"libraryId": {"operator": "is","value": "${libraryId}"}}}`
			);
			allSeries = allSeriesPage.content;
			// now it gets the series sorted by name so no need to elaborate the sorting, but for custom sorting based for example on title time?
			// allSeries.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
			return (allSeries);
		}

		function focusItem(focus) {
			if (focus == 'top') {
				mainContainer.scrollTo({ top: 0 });
			} else if (focus) {
				var item = document.getElementById(focus);
				const yOffset = -150;
				const y = item.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop + yOffset;

				mainContainer.scrollTo({ top: y });

				mb.currentlyScaled = item.firstChild;
				item.firstChild.classList.add('scaled');
				item.classList.add('top-pop');

			}
		}

		// Compose function that opens a specific library based on it ID
		async function openLibrary(libraryId, seriesId) {
			await libraryHighlight(libraryId, true);		// Triggers and manages the library menu
			const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library
			await displaySeries(allSeries, seriesGrid);
			fetchLibraryFilters(libraryId);
			focusItem(seriesId || 'top');
			//TODO Move here the logic that enables the library options buttons?
		}

		const menuClassUp = 'fa-caret-up';
		const menuClassDown = 'fa-caret-down'

		function libMenuClear(item) {
			item.classList.remove(menuClassUp);
			item.classList.remove(menuClassDown);
		}

		function libMenuDown(item) {
			libMenuClear(item);
			item.classList.add(menuClassDown);
		}

		function libMenuUp(item) {
			libMenuClear(item);
			item.classList.add(menuClassUp);
		}

		function clearLibrariesMenus() {
			Object.entries(mb.libraryMenuButtons).forEach(([name, item]) => {
				libMenuClear(item);
				libMenuDown(item);
			});
		}

		function pressDown(item) {
			item.animate(
				{
					transform: 'scale(0.975) translateY(1px)',
					filter: 'brightness(0.98)',
					boxShadow: 'var(--mb-button-press)'
				},
				{ duration: 150, fill: 'forwards', easing: 'ease-out' }
			);
		}

		function pressUp(item) {//TODO reduce press up time
			item.animate(
				{
					transform: 'scale(1) translateY(0px)',
					filter: 'brightness(1)',
					boxShadow: 'var(--mb-button-unpress)'
				},
				{ duration: 50, fill: 'forwards', easing: 'ease-in' }
			);
		}

		function scaleDownShallow(item) {
			item.animate({ scale: 0.95 }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
		}
		function scaleDown(item) {
			item.animate({ scale: 0.9 }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
		}
		function scaleDownDeep(item) {
			item.animate({ scale: 0.8 }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
		}
		function scaleUp(item) {
			item.animate({ scale: 1 }, { duration: 50, fill: 'forwards', easing: 'ease-in' });
		}

		function addPressEvents(item, downFunction, upFunction) {
			item.addEventListener('pointerdown', (event) => {
				event.stopPropagation();
				event.preventDefault();
				downFunction(item);
			});
			item.addEventListener('pointerup', () => {
				upFunction(item);
			});
			item.addEventListener('pointerleave', () => {
				upFunction(item);
			});
			item.addEventListener('pointercancel', () => {
				upFunction(item);
			});
		};

		function buildLibraryItem(itemId, libraryName, imagePath = null) {
			const isLib = (imagePath == null);

			const listItem = addItem('li', {
				id: itemId,
				className: 'library-item press-button',
				title: libraryName,
			});

			addPressEvents(listItem, pressDown, pressUp);

			const thumbnailWrapper = addItem('div', {
				className: 'button-wrapper',
			})

			const base64Image = mb.libraryIcons[itemId];
			const imageSrc = base64Image || (isLib
				? `library-thumbnails/${libraryName}.png`
				: imagePath);

			const libraryThumbnail = addItem('img', {
				className: 'library-thumbnail',
				src: imageSrc,
				alt: isLib ? `${libraryName} Cover` : libraryName,
			})

			if (isLib) {
				libraryThumbnail.onerror = () => {
					libraryThumbnail.onerror = null;
					libraryThumbnail.src = `library-thumbnails/${libraryName}.jpg`;
					libraryThumbnail.onerror = () => {
						libraryThumbnail.onerror = null;
						console.log('Both PNG and JPG images failed to load');
						libraryThumbnail.src = 'library-thumbnails/blank.png';
					};
				};
			}

			const libraryNameDiv = addItem('div', {
				className: 'library-name',
				textContent: libraryName
			});

			thumbnailWrapper.append(libraryThumbnail);
			listItem.append(thumbnailWrapper, libraryNameDiv);

			if (isLib) {
				mb.libraryMenuButtons[itemId] = addItem('span', {
					className: "fa-solid " + menuClassDown + " is-lib-menu"
				})

				const thumbnailWrapperMenu = addItem('div', {
					className: 'button-wrapper library-menu-button press-flat-button-deep',
				})

				thumbnailWrapperMenu.append(mb.libraryMenuButtons[itemId]);
				listItem.append(thumbnailWrapperMenu);

				addPressEvents(thumbnailWrapperMenu, scaleDownDeep, scaleUp)

				thumbnailWrapperMenu.addEventListener('click', (event) => {
					libMenuClear(mb.libraryMenuButtons[itemId]);

					if (isSectionHidden(filtersBar)) {
						libMenuUp(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = itemId;
						mb.swatchMenuVisible = false;
						sectionHide(colorSwatchBar);
					} else {
						libMenuDown(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = null;
					}

					event.stopPropagation();
					event.preventDefault();
					sectionToggle(filtersBar);
				});

			}

			return listItem;
		}

		function readFileAsBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file); // This gives you "data:image/png;base64,..." format
			});
		}

		function addLongPressListener(element, callback, duration = 600) {
			let pressTimer;
			let wasLongPress = false;

			const start = (e) => {
				if (e.target.classList.contains('is-lib-menu')) return;
				wasLongPress = false;
				pressTimer = setTimeout(() => {
					wasLongPress = true;
					callback(e);
				}, duration);
			};

			const cancel = () => {
				clearTimeout(pressTimer);
			};

			element.addEventListener('mousedown', start);
			element.addEventListener('mouseup', cancel);
			element.addEventListener('mouseleave', cancel);
			element.addEventListener('dragstart', cancel);

			element.addEventListener('touchstart', start);
			element.addEventListener('touchend', cancel);
			element.addEventListener('touchcancel', cancel);

			// Prevent click after long press
			element.addEventListener('click', (e) => {
				if (wasLongPress) {
					e.preventDefault();
					e.stopImmediatePropagation();
					// Optionally log or debug here
				}
			}, true); // Capture phase to stop early
		}

		function cancelUpdate() {
			closeModal();
			bootSequence();
		}

		function displayLibraries(libraries) {
			librariesList.innerHTML = '';

			let dashboard = buildLibraryItem('homeButton', 'Dashboard', 'mangabox-logo-new.svg')
			librariesList.append(dashboard);
			homeButton.addEventListener('click', () => {
				navigateTo('#dashboard');
			});

			Array.from(libraries).forEach((library, index) => {
				const listItem = buildLibraryItem(library.id, library.name);

				addLongPressListener(listItem, async () => {

					const libraryId = listItem.id
					if (mb.libraryIcons[libraryId] == null) {
						showModal('circle-info-svg.svg', true, 'Drop an image on the library button to change thumbnail.', 'Ok', null, closeModal);
					} else {
						showModal(mb.libraryIcons[libraryId], false, 'Remove custom library thumbnail?', 'Ok', 'Cancel', async () => {
							await delete mb.libraryIcons[libraryId];
							await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons))

							closeModal();
							bootSequence();
						}, cancelUpdate);
					}
				});

				listItem.addEventListener('dragover', (event) => {
					event.preventDefault(); // This is required to allow drop
					listItem.style.backgroundColor = 'hsl(200, 60%, 70%)';
				});

				listItem.addEventListener('dragleave', () => {
					listItem.style.backgroundColor = ''; // Reset visual feedback
				});

				listItem.addEventListener('drop', async (event) => {
					event.preventDefault();

					const libraryId = listItem.id
					const file = event.dataTransfer.files[0];

					if (!file || !file.type.startsWith('image/')) {
						showModal('circle-mark-svg.svg', true, 'Please drop a valid image file.', 'Ok', null, cancelUpdate, cancelUpdate);

					} else {
						const base64 = await readFileAsBase64(file);
						showModal(base64, false, 'Set this image as library thumbnail?', 'Ok', 'Cancel', async () => {
							mb.libraryIcons[libraryId] = base64;
							await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons))
							closeModal();
							bootSequence();
						}, cancelUpdate);
					}
				})

				listItem.addEventListener('click', () => {
					const { path, params } = getHashAndParams();
					if ((path == 'series') && (params.get('library_id') == library.id)) {
						navigateTo(`#library?library_id=${library.id}&series_id=${params.get('series_id')}`);
					}
					else {
						navigateTo(`#library?library_id=${library.id}`);
					}
				});

				librariesList.append(listItem);
			});

		}

		function getAltTitles(serie) {

			const labels = ['Time', 'Story', 'Art'];
			const altTitle = labels.reduce((out, label) => {
				const altTitle = serie.metadata.alternateTitles.find(
					(alt) => alt.label === label
				);
				out[label.toLowerCase()] = altTitle ? altTitle.title : 'N/A';
				return out;
			}, {});

			if ((altTitle.time == 'N/A') && (serie.booksMetadata.releaseDate != null)) {
				altTitle.time = serie.booksMetadata.releaseDate.split('-')[0];
			};

			if (altTitle.story == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'writer'
				);
				altTitle.story = bookWriter ? bookWriter.name : 'N/A';
			}
			if (altTitle.art == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'penciller'
				);
				altTitle.art = bookWriter ? bookWriter.name : 'N/A';
			}
			return altTitle;

		}


		async function displayHeader(serie) {
			const altTitle = getAltTitles(serie);
			const creditString = altTitle.story == altTitle.art
				? `Story and art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>`
				: `Story by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>, art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.art.toLowerCase()}');">${altTitle.art}</a>`;

			seriesHeader.innerHTML = `
			<div class="header-pic-container">
				<div class="thumbnail-wrapper">
					<img id="seriesHeaderThumbnail" src="${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail" class="header-pic">
				</div>
			</div>
			<div class="header-title">
				<span class="title">
				${serie.metadata.title}
				${serie.metadata.language ? `<img width="20px" height="20px" style="margin-left:15px; margin-top:2px; vertical-align: top;" src="flags/${serie.metadata.language}.svg">` : ''}
				</span>
				<span class="notes">
					<a class="red search-trigger" href="javascript:navigateTo('#search?search_string=y:${altTitle.time}');">${altTitle.time}</a> (${serie.booksCount} ${serie.booksCount == 1 ? "volume" : "volumes"}) - ${creditString}</span>
			</div>
			<div id="bookScrollBox" class="header-summary scrollbox" data-scroll-direction="vertical">
				<div class="scrollbox-content">${serie.metadata.summary.replace(/\n/g, '<br>')}</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			`;

			seriesHeaderThumbnail.src = await fetchMedia(seriesHeaderThumbnail.src);
			createCustomScrollbar(bookScrollBox);
			seriesMiniHeader.innerHTML = `
				<span class="mini-title">${serie.metadata.title}</span>
			`
		}

		//MB Book Details Panel 

		function closeBookDetails() {
			sectionHide(bookDetailsContainer);
			setTimeout(() => {
				bookDetailsContainer.innerHTML = ''
			}, 300);
		}

		function jumpBookDetailsPrev() {
			if (mb.prevBook != null) showBookDetails(mb.prevBook);
		}
		function jumpBookDetailsNext() {
			if (mb.nextBook != null) showBookDetails(mb.nextBook);
		}

		async function showBookDetails(book) {
			const seriesData = await callAPI(`/api/v1/series/${book.seriesId}`);
			const seriesBooks = await callAPI(
				`/api/v1/books/list?unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${book.seriesId}"}}}`
			);
			const readingDirection = seriesData.metadata.readingDirection;

			mb.currentBook = book;
			mb.prevBook = null;
			mb.nextBook = null;

			if (book.number > 1) {
				mb.prevBook = seriesBooks.content[book.number - 2];
			}
			if (book.number < seriesData.booksCount) {
				mb.nextBook = seriesBooks.content[book.number];
			}
			sectionShow(bookDetailsContainer);
			let summaryArray = book.metadata.summary.split(/\r?\n/);

			let text = `
			<div class="book-details-pic-container">
				<div class="mini-controls">
					<div class="mini-buttons-2 prev-book press-flat-button" title="Previous book" onclick="jumpBookDetailsPrev()">
						<span class="fa-solid fa-chevron-left"></span>
					</div>
					<div class="mini-buttons-2 prev-book  press-flat-button" title="Go to library" onclick="navigateTo('#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}')">
						<span class="fa-solid fa-layer-group"></span>
					</div>
					<div class="mini-buttons-2 next-book  press-flat-button" title="Next book" onclick="jumpBookDetailsNext()">
						<span class="fa-solid fa-chevron-right"></span>
					</div>			
				</div>
				<div id="bookDetailsContainerThumbnailWrapper" title="Open Book" onclick="navigateToReadBook(mb.currentBook, '${readingDirection}')">
					<img id="bookDetailCover" class="book-thumbnail hidden" src="transparent.png">
				</div>
			</div>
			<div>
				<div class="book-details-title">${book.metadata.title}</div>
				<div class="ul-container">
					<ul>
						${summaryArray.map(element => `<li>${element}</li>`).join('')}
					</ul>
				</div>
			</div>
			<div class="close-details mini-buttons-2  press-flat-button" onclick="closeBookDetails()">
				<span class="fa-solid fa-xmark"></span>
			</div>
			`;
			bookDetailsContainer.innerHTML = text;
			bookDetailCover.lazySrc = `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`;
			addLazyLoading(bookDetailCover);
			document.querySelectorAll('.mini-buttons-2').forEach(item => addPressEvents(item, scaleDown, scaleUp));

		}

		//MB Book Item Creation

		async function buildBookItem(item, book, format, target) {
			item.childNodes[0]?.remove();

			item.title = 'Read book';

			const booksItem = addItem('div', {
				className: 'book-item'
			});

			const mainRow = addItem('div', {
				className: 'data-row top-row'
			});

			if (format == 'longname') {
				mainRow.classList.add('book-row');
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Volume ${book.metadata.number}`,
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				mainRow.append(volumeNumberLabel, pagesLabel);
			} else {
				mainRow.classList.add('book-series-row', 'red');
				mainRow.title = `Open series: ${book.seriesTitle}`;
				mainRow.textContent = book.seriesTitle;
				mainRow.addEventListener('click', (event) => {
					event.stopPropagation();
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}`);
				});
				noPointerDown(mainRow);
			}

			const secondRow = addItem('div', {
				className: 'data-row',
			});

			if (format == 'longname') {
				secondRow.classList.add('info-row');
				secondRow.textContent = book.metadata.title;
			} else if (format == 'compact') {
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Volume ${book.metadata.number}`
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				secondRow.append(volumeNumberLabel, pagesLabel);
			} else if (format == 'timeline') {
				const dateString = book.readProgress ?
					new Intl.DateTimeFormat('en-GB', {
						day: '2-digit',
						month: 'short',
						year: '2-digit'
					}).format(new Date(book.readProgress.readDate))
					: '';

				const volumeNumberLabelShort = addItem('span', {
					innerHTML: `Vol.${book.metadata.number}`
				});
				const timeLabel = addItem('span', {
					innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-clock glyph-dark'></span>&nbsp;${dateString}`
				});

				secondRow.append(volumeNumberLabelShort, timeLabel);
			}

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper',
			});

			const bookThumbnail = addItem('img', {
				className: 'book-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`,
				alt: book.metadata.title
			});

			addLazyLoading(bookThumbnail);

			const bookFader = addItem('div', { className: 'book-fader' });
			const bookOverlay = addItem('div', { className: 'book-overlay' });
			const bookStatus = addItem('div', { className: 'book-status' });

			const unread = (book.readProgress == null);

			if (unread) {
				const unreadBookBadge = addItem('div', {
					className: 'unread-book'
				});
				bookStatus.append(unreadBookBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark book as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			markAsRead.addEventListener('click', () => {
				event.stopPropagation();
				setBookReadStatus(book.id, true, item, format);
			})
			noPointerDown(markAsRead);

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark book as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			markAsUnread.addEventListener('click', () => {
				event.stopPropagation();
				setBookReadStatus(book.id, false, item, format);
			});
			noPointerDown(markAsUnread);

			bookOverlay.append(markAsRead, markAsUnread);


			if (book.metadata.summary != '') {
				const bookDetails = addItem('div', {
					className: 'mini-buttons book-details',
					title: 'Book Details',
					innerHTML: `<span class="fa-solid fa-align-justify"></span>`
				});
				bookDetails.addEventListener('click', async (event) => {
					event.stopPropagation();
					showBookDetails(book);
				})
				noPointerDown(bookDetails);

				bookOverlay.append(bookDetails);
			}


			const progress = (book.readProgress ? (book.readProgress.completed ? 0 : book.readProgress.page) : 0)
			const progressBar = addItem('div', { className: 'progress-bar' });
			const progressGauge = addItem('div', { className: 'progress-gauge' });

			if (progress == 0) {
				progressBar.classList.add('no-show');
			} else {
				progressGauge.style.width = `${Math.round(100 * progress / book.media.pagesCount)}%`;
			}

			booksItem.append(
				thumbnailWrapper,
				progressBar,
				mainRow,
				secondRow
			);

			thumbnailWrapper.append(
				bookThumbnail,
				bookFader,
				bookOverlay,
				bookStatus
			);

			progressBar.append(progressGauge);

			addTouchScaler(booksItem, async () => {
				const seriesData = await callAPI(`/api/v1/series/${book.seriesId}`);
				const readingDirection = seriesData.metadata.readingDirection;

				rd.historyPath = window.location.hash.split('&book_id=')[0] + (target == booksGrid ? '&book_id=' + book.id : '');
				setIncognito(false);
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${(readingDirection == 'RIGHT_TO_LEFT' ? 'rtl' : 'ltr')}
						&pag=${(book.readProgress ? book.readProgress.page : 1)}`);
			});

			item.append(booksItem);

		}

		function displayBooks(books, target, format, focus = null) {
			/*
				"format" can be one of the follows
				- longname: will not show the series name, but the book file name
				- compact: will show series name and pages 
				- timeline: will show latest read date
			*/
			// focus is the book id to focus on

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			if (books.length === 0) {
				const noBooksMsg = document.createElement('p');
				noBooksMsg.textContent = 'No books available';
				booksGrid.append(noBooksMsg);
				return;
			}

			books.forEach(book => {
				const bookContainer = addItem('div', {
					className: 'book-container',
					id: book.id
				});

				buildBookItem(bookContainer, book, format, target);

				target.append(bookContainer);
			});

			if (target == booksGrid) {
				sectionShow(booksGrid);
				sectionShow(seriesHeader);
				sectionShow(seriesMiniHeader);
				seriesMiniHeader.classList.add('collapse');

				focusItem(focus);

			}
		}

		//MB Dashboard Management

		// Function to trigger the home page layout
		async function selectHome() {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = '';
			booksGrid.innerHTML = '';
			stripGrid.innerHTML = '';

			sectionShow(homeStripsContainer);

			await Promise.all(
				Object.entries(dashboardElements).map(async ([name, item]) => {
					const resultsObject = await item.getItems(0, 20);
					item.element.style.display = resultsObject.empty ? 'none' : 'block';
					item.showItems(resultsObject.content, item.homeStrip);
				})
			);
			setTimeout(updateSliderProperties, 10);

		}

		dashboardElements = {
			keepReading: {
				headerCode: '<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading',
				getItems: async (page, size) => {
					const out = await callAPI(
						`/api/v1/books/list?page=0&unpaged=true&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"IN_PROGRESS"}}}`
					);
					return (out);
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
				element: null,
				scrollBar: null,
				gridButton: null,
				homeStrip: null,
			},


			onDeck: {
				headerCode: '<span class="fa-solid fa-inbox glyph-dark"></span>&nbsp;On Deck',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/books/ondeck`));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
			},

			recentBooks: {
				headerCode: '<span class="fa-solid fa-book glyph-dark"></span>&nbsp;Last Added Books',
				getItems: async (page, size) => {
					return (await callAPI(
						`/api/v1/books/list?page=${page}&size=${size}&sort=created,desc`,
						'POST', `{"condition":{"allOf":[]}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				}
			},

			recentSeries: {
				headerCode: '<span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Last Added Series',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/series/new?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			updatedSeries: {
				headerCode: '<span class="fa-solid fa-bullhorn glyph-dark"></span>&nbsp;Last Updated Series',
				getItems: async (page, size) => {
					return (await callAPI(`/api/v1/series/updated?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			readBooks: {
				headerCode: '<span class="fa-solid fa-square-check glyph-dark"></span>&nbsp;Last Read Books',
				getItems: async (page, size) => {
					return (await callAPI(
						`/api/v1/books/list?page=${page}&size=${size}&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"READ"}}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'timeline');
				},
			},
		}

		async function dashboardAll(element, page) {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = ''; // Clear the series grid
			booksGrid.innerHTML = ''; // Clear the series grid
			stripGrid.innerHTML = '';

			sectionShow(stripGridContainer);

			stripGridHeader.innerHTML = dashboardElements[element].headerCode;
			const data = await dashboardElements[element].getItems(page, 50);

			const array = data.content;

			stripPrevPage.classList.remove('disabled');
			stripNextPage.classList.remove('disabled');
			if (data.first) stripPrevPage.classList.add('disabled');
			if (data.last) stripNextPage.classList.add('disabled');

			dashboardElements[element].showItems(array, stripGrid);
		}

		const dashEntries = Object.entries(dashboardElements);

		dashEntries.forEach(([name, item], index) => {
			const isLast = dashEntries.length - 1 === index;

			item.element = addItem('div', { className: 'home-strip-parent' });
			const headerContainer = addItem('div', { className: 'strip-header-container' });
			const stripHeader = addItem('div', {
				className: 'strip-header',
				innerHTML: item.headerCode,
			});
			item.scrollBar = addItem('div', {
				className: 'custom-scrollbar',
			});
			item.scrollInput = addItem('input', {
				type: 'range',
				className: 'range-bar',
				min: '0',
				max: '100',
				value: '0'
			});
			item.gridButton = addItem('div', {
				className: 'strip-all press-flat-button',
				innerHTML: '<span title="View All" class="fa-solid fa-grip glyph-dark"></span>',
			});
			item.homeStrip = addItem('div', {
				className: 'home-strip' + (isLast ? ' last-strip' : ''),
				binName: name,
			})
			item.gridButton.addEventListener('click', async () => {
				mb.dashboardBin = name;
				navigateTo('#dashboard?all=' + name + '&page=0')
			});
			item.scrollInput.addEventListener('input', () => {
				item.homeStrip.scrollLeft = item.scrollInput.value;
			});
			item.homeStrip.addEventListener('scroll', () => {
				item.scrollInput.value = item.homeStrip.scrollLeft;
			});

			item.scrollBar.append(item.scrollInput);
			headerContainer.append(stripHeader, item.scrollBar, item.gridButton);
			item.element.append(headerContainer, item.homeStrip);
			homeStripsContainer.append(item.element);
		});

		// Open a whole series fetching all its books and showing them with the correct header
		// if seriesdata is not available at the moment of the call, it fetches it from the server
		async function openSeries(libraryId, seriesId, bookId) {

			const seriesData = await callAPI(`/api/v1/series/${seriesId}`);

			const books = (await callAPI(
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${seriesId}"}}}`
			)).content;

			await libraryHighlight(libraryId, false);
			displayHeader(seriesData);
			displayBooks(books, booksGrid, 'longname', bookId);
		}

		async function bootSequence() {
			userSettings = await getUserSettings();

			applyUserSettings();

			applyAccent();
			// Apply first theme change
			changeTheme();
			changeReaderTheme();
			setIncognito(false);

			buildLanguageList();

			sectionShow(stickyContainer);

			let series_data = null;
			await fetchLibraries();
			await loadContent();
		}

		//MB Reader Functions and Data

		// General reader data structure
		let rd = {
			dragbarTimer: null,

			orientationThresholdRatio: 1.0,		//Orientation threshold

			preloadCount: 15,			// Image preload count
			preloadPicDelay: 300,	// Delay before adding new spreads to the preload stack
			loadDelay: 100,			// Delay used when jumping to a spread before really updating
			jumpTimeout: null,		// Timeout counter for jumping to spreads

			preloadStack: {}, 		// Contains all the preload timers, one for each spread that's going to be loaded
			picLoadStack: [], 		// Contains all load image objects, both direct load and preload

			ltr: null,
			currentPage: 0,
			pagesDataArray: [],		// this is the array of pages data in the form url, iscover etc
			spreadsArray: [],			// Array of spreads objects, containing:

			currentPageIndex: 0,
			currentSpreadIndex: 0,
			oldSpreadIndex: 0,
			isDraggingProgressBar: false,

			thumbZoom: false,
			thumbWidth: 0,

			libraryId: 0,
			seriesId: 0,
			bookId: 0,

			historyPath: '',
			bookPath: '',

			incognito: false,

			foreEdgeL: null,
			foreEdgeR: null,
			dropShadowL: null,
			dropShadowR: null,

			turnTimeout: null,
			pageTurning: null,

			turnTime: 500,				// Duration of turning page animation
			scrollSpeed: 500,			// Duration of spread page scrolling
			turnScrollDelay: 300,	// Delay of spread page scrolling during page turn
			turnScrollTime: 500,		// Duration of spread page scrolling during page turn

			pageShadowOpacityFWD: '0.4',
			pageShadowOpacityBWD: '0.3',
			pageShadowWidthFWD: '10%',
			pageShadowWidthBWD: '15%',

			spreadFocus: 'focus-center',

			focusTransition: {
				'focus-right-page': 'translate(-75%, -50%)',
				'focus-left-page': 'translate(-25%, -50%)',
				'focus-center': 'translate(-50%, -50%)',
				'none': 'translate(-50%, -50%)',
			}

		};

		// Function that prepares the page for reading a book, once the url is setup, navigateTo triggers openBookReader function
		function navigateToReadBook(book, readingDirection) {
			setIncognito(false);
			navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${(readingDirection == 'RIGHT_TO_LEFT' ? 'rtl' : 'ltr')}
						&pag=${(book.readProgress ? book.readProgress.page : 1)}`);
		}

		// Function that setups the reader for a specific book, this is not run directly
		function openBookReader(libraryId, seriesId, bookId, dir, pag) {
			//TODO aggiungere funzione per pulire l'array del preload e quello delle pic
			Object.entries(dashboardElements).forEach(([name, item]) => {
				item.homeStrip.innerHTML = '';
			});
			clearReader(); //TODO forse eccessivo?
			clearAllTimeouts();
			rd.picLoadStack = [];
			rd.jumpTimeout = null;

			rd.ltr = (dir == 'ltr');
			rd.currentPage = pag;

			rd.spreadsArray = [];

			rd.currentPageIndex = 0;
			rd.currentSpreadIndex = 0;
			rd.oldSpreadIndex = 0;
			rd.isDraggingProgressBar = false;

			rd.libraryId = libraryId;
			rd.seriesId = seriesId;
			rd.bookId = bookId;

			rd.spreadFocus = 'focus-center';

			readerViewer.innerHTML = '';

			setThumbZoom(false);

			dragbarOnReader();
			sectionShow(readerContainer);

			initViewer();

		}

		// Reader cleanup functions to remove all dangling spreads and pages
		function clearReader() {

			// Cleanup ForeEdge and drop shadows
			["foreEdgeL", "foreEdgeR", "dropShadowL", "dropShadowR"].forEach(key => {
				if (rd[key]) {
					rd[key].remove();
					rd[key] = null;
				}
			});

			// Cleanup all the spreads: remove each uiItem (and their descendants) from dom, then null all the graphics item
			// like uiShadowL and uiShadowR, then cleanup the array
			rd.spreadsArray.forEach(item => {
				item.uiItem.remove();
				item.uiThumb.remove();
				item.uiItem = null;
				item.uiThumb = null;
				item.uiShadowL = null;
				item.uiShadowR = null;
				item.uiLightL = null;
				item.uiLightR = null;
				['pageObjL', 'pageObjR'].forEach(key => {
					if (item[key] != null) {
						item[key].uiPage.remove();
						item[key].uiContainer.remove();
						item[key].uiThumb.remove();
						item[key].uiPage = null;
						item[key].uiContainer = null;
						item[key].uiThumb = null;
					}
					item[key] = null;
				});
			});
			rd.spreadsArray = [];
		}

		function spreadSetFocus(focusString, smoothMove = false, delayMove = false) {
			let [duration, delay] = !smoothMove ? [0, 0] : (delayMove ? [rd.turnScrollTime, rd.turnScrollDelay] : [rd.scrollSpeed, 0]);

			readerViewer.animate(
				[{ transform: rd.focusTransition[focusString] }],
				{ duration: duration, easing: 'ease', fill: 'forwards', delay: delay }
			);
			rd.spreadFocus = focusString;
		}

		function spreadSetFocusSmooth(focusString) {
			spreadSetFocus(focusString, true, false)
		};

		function spreadSetFocusSmoothDelay(focusString) {
			spreadSetFocus(focusString, true, true)
		}

		// Setup close button
		function handleCloseReader() {
			hideMenu();
			setIncognito(false);
			//XXX WAS incognitoMark.classList.remove('incognito'); but why didn't I just sue setIncognito(false)?

			clearTimeout(rd.jumpTimeout);
			setTimeout(() => {
				spreadSetFocus('none');
				clearReader();
			}, 400); //300ms timeout so the reader can slide out

			purgeLoading();
			clearAllTimeouts();

			navigateTo(rd.historyPath == '' ? '#dashboard' : rd.historyPath);
			//dragbarOffReader();

			updatePWABar();
		}

		readerClose.addEventListener('click', () => {
			handleCloseReader();
		});

		function changeReaderTheme() {
			mb.readerThemeControl.forEach(item => {
				readerTheme.classList.remove(item.icon);
			});
			readerTheme.classList.add(mb.readerThemeControl[mb.readerThemePrefs].icon);
			readerTheme.title = mb.readerThemeControl[mb.readerThemePrefs].label;

			document.documentElement.setAttribute('data-theme-reader', mb.readerThemeControl[mb.readerThemePrefs].style);

			setUserSettings('mangabox.ui.readerthemeprefs', mb.readerThemePrefs);

		}

		readerTheme.addEventListener('click', () => {
			mb.readerThemePrefs = (mb.readerThemePrefs + 1) % mb.readerThemeControl.length;
			changeReaderTheme();
		});

		// Setup incognito button
		function setIncognito(status) {
			readerIncognito.classList.remove('incognito');
			incognitoMark.classList.remove('incognito');

			if (status) {
				readerIncognito.classList.add('incognito');
				incognitoMark.classList.add('incognito')
			};

			rd.incognito = status;
		}

		readerIncognito.addEventListener('click', () => {
			setIncognito(!rd.incognito);
		})

		function setThumbZoom(status) {
			rd.thumbZoom = status;
			rd.thumbWidth = thumbStripInner.clientWidth;
			thumbStripScrollContent.style.overflow = 'hidden';
			const oldWidth = thumbStripInner.clientWidth;

			let thumbHeight = status ? 300 : 150;
			if (window.innerHeight - thumbHeight - 60 - 60 - 30 < 0) {
				thumbHeight = window.innerHeight - 60 - 60 - 30;
			}
			document.documentElement.style.setProperty('--mb-thumb-height-px', thumbHeight + 'px');

			const newWidth = thumbStripInner.clientWidth;

			const scrollScaler = newWidth / oldWidth;
			thumbStripScrollContent.scrollLeft = thumbStripScrollContent.scrollLeft * scrollScaler;
		}

		thumbStripButton.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});

		const resizeObserver = new ResizeObserver(entries => {
			for (let entry of entries) {
				const oldWidth = rd.thumbWidth;
				const newWidth = thumbStripInner.clientWidth;
				const scrollScaler = newWidth / oldWidth;
				thumbStripScrollContent.scrollLeft = thumbStripScrollContent.scrollLeft * scrollScaler;
				rd.thumbWidth = newWidth;
			}
		});

		resizeObserver.observe(thumbStripInner);

		thumbStripInner.addEventListener('transitionend', () => {
			thumbStripScrollContent.style.overflow = 'auto';
		});

		function updateProgressBar(currentSpreadIndex = rd.currentSpreadIndex) {
			const progressPercent = (currentSpreadIndex / (spreadsTotal() - 1)) * 100;
			readerProgress.style.width = `${progressPercent}%`;
			readerProgress.style.float = rd.ltr ? 'left' : 'right';

			[rd.currentPage, readerPage.innerText] = getPageFromSpread(currentSpreadIndex);

			readerPage.style.left = rd.ltr
				? `min(max(0px, calc(${progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
				: `min(max(0px, calc(${100 - progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
		}

		function preloadPage(index) {
			if (picLoadStackSize() < 20000000) populateSpreadPreload(index);
		}

		function calcDelay(i, delay, scale, power) {
			return ((delay * (1 - scale) + (i ** power) * delay * scale))
		}

		// This function triggers multiple preloads starting from the current spread
		function preloadPages(startSpreadIndex, count) {
			if (isSectionHidden(readerContainer)) return;

			for (let i = 1; i <= count; i++) {
				const forwardIndex = startSpreadIndex + i;
				const backwardIndex = startSpreadIndex - i;

				if (forwardIndex < spreadsTotal() && !(forwardIndex in rd.preloadStack)) {
					startTimeout(forwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(forwardIndex));
				}
				if (backwardIndex >= 0 && !(backwardIndex in rd.preloadStack)) {
					startTimeout(backwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(backwardIndex));
				}
			}
		}

		function dragbarOffReader() {
			rd.dragbarTimer = setTimeout(() => {
				dragbar.classList.remove('onReader');
			}, 500);
			//dragbar.classList.remove('offReader');
		}

		function dragbarOnReader() {
			clearTimeout(rd.dragbarTimer);
			dragbar.classList.remove('onReader');
			dragbar.classList.add('onReader');
		}

		function initReaderUI(pagesData, bookData) {
			leftLimit.innerText = rd.ltr ? 1 : pagesData.length;
			rightLimit.innerText = rd.ltr ? pagesData.length : 1;
			bookName.innerText = `${bookData.seriesTitle} Vol.${bookData.metadata.number} (${bookData.metadata.title})`
		}

		// Initialize viewer with page data
		async function initViewer() {
			updatePWABar('black');

			const bookData = await callAPI(`/api/v1/books/${rd.bookId}`);
			const noCover = bookData.metadata.tags.includes('no-cover');
			const noWhitePage = bookData.metadata.tags.includes('no-blank-page');

			const pagesData = await fetchPages(rd.bookId, noCover, noWhitePage);

			if (!rd.incognito && bookData.readProgress && (bookData.readProgress.completed === true)) {
				rd.currentSpreadIndex = 0; //TODO Maybe change this with a check with the top page?
			}

			initReaderUI(pagesData, bookData)

			jumpToSpreadSkipHistory(rd.currentSpreadIndex);
		}

		function buildSize(item, ratio) {
			item.style.width = `calc(min(100vw, ${100 * ratio}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh))`;
		}

		function buildSizeCV(item, ratio) {
			//item.style.objectFit = 'fill';
			item.style.objectPosition = "center center";
			item.style.width = `calc(min(100vw, ${100 * ratio}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh))`;
		}

		// Size the spread for a two pages spread with fit on page
		function buildSize2P(item, ratio) {
			item.style.width = `calc(2 * min(100vw, ${100 * ratio * 0.5}vh))`;
			item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, 100vh))`;
		}

		// Add this once when initializing the viewer
		//readerViewer.style.transition = "left 0.3s ease, border-width 0.3s ease, border-image-slice 0.3s ease";

		function buildForeEdge(index, total) {
			// book size is a parabola based on number of spreads capped at 400 spreads
			const fullBook = (total / 400 > 1 ? 1 : ((1 - (total / 400 - 1) * (total / 400 - 1))));
			const pageRate = rd.ltr ? index / total : 1.0 - index / total;

			[clipLeft, clipRight] = [
				`inset(0 0 0 ${100 * ((1.0 - fullBook) + fullBook * (1 - pageRate))}%)`,
				`inset(0 ${100 * (1.0 - fullBook + fullBook * pageRate)}% 0 0)`]

			return ({ left: clipLeft, right: clipRight, dropL: fullBook * pageRate, dropR: fullBook * (1 - pageRate) })
		}

		//MB Reader Fetch Page Function

		function buildSpreadObject(spreadKind, spreadPages, spreadRefPage) {
			// I put the image item and container item in the array so I can target them for changes
			// and I put all the metadata like "hasSrc" in the object metadata instead of in a separate item.
			return ({
				// dom object, spread div and its content
				// dom object, shadow for page effect, children of uiItem in the dom
				//  "
				// dom object, thumbnail of the spread for the strip view
				uiItem: addItem('div', { className: 'spread-layout' }),
				uiShadowL: addItem('div', { className: 'page-shadow-left' }),
				uiShadowR: addItem('div', { className: 'page-shadow-right' }),
				uiLightL: addItem('div', { className: 'page-light-left' }),
				uiLightR: addItem('div', { className: 'page-light-right' }),
				uiThumb: addItem('div', { className: 'spread-thumb' }),
				pageObjL: spreadPages["left"] ?? null,
				pageObjR: spreadPages["right"] ?? null,
				spreadKind: spreadKind,	// what kind of page is this (cover, double spread, two pages etc)
				spreadRefPage: spreadRefPage
			})
		}

		function spreadsTotal() {
			return rd.spreadsArray.length
		}

		function buildPageObject(pageData) {
			const isBlank = (pageData == 'blank');
			const isHidden = (pageData == 'hidden');

			const pageItem = {
				uiPage: addItem('img', {
					alt: isBlank ? '' : pageData.pageNum,
					className: 'page multiply hidden',
					src: 'transparent.png',
				}),
				uiContainer: addItem('div', {
					className: isHidden ? 'page-container hidden-page' : 'page-container'
				}),
				uiThumb: addItem('img', {
					className: isHidden ? 'page-thumb multiply hidden hidden-page' : 'page-thumb multiply hidden',
					alt: (isBlank || isHidden) ? '' : pageData.pageNum,
					src: 'transparent.png',
					lazySrc: (isBlank || isHidden) ? '' : pageData.thumb,
					style: {
						height: 'var(--mb-thumb-height-px)',
						aspectRatio: isHidden ? '0.001' : pageData.AR,
					}
				}),
				hasSrc: (isBlank || isHidden) ? true : false,
				lazySrc: (isBlank || isHidden) ? '' : pageData.url,
				size: (isBlank || isHidden) ? 0 : pageData.size,
				pageNum: (isBlank || isHidden) ? '' : pageData.pageNum,
				isCurrent: (isBlank || isHidden) ? false : pageData.isCurrent,
				AR: isBlank ? null : pageData.AR,
			}

			if ((pageData != 'blank') && (pageData != 'hidden')) addLazyLoading(pageItem.uiThumb);
			pageItem.uiContainer.append(pageItem.uiPage);

			return pageItem;
		};

		function pageTable(page1, page2) {
			return (
				rd.ltr ?
					{ left: page1, right: page2 } :
					{ left: page2, right: page1 }
			)
		}

		function addCoverSpine(pageObjectL, pageObjectR) {
			const coverlayR = addItem('div', {
				id: 'coverlayer',
				className: 'LTR',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectR.uiContainer.append(coverlayR);
			const coverlayL = addItem('div', {
				id: 'coverlayer',
				className: 'RTL',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectL.uiContainer.append(coverlayL);
		}

		// Master function that builds all the pages slots for the book spreads
		async function fetchPages(bookId, noCover, noWhitePage) {

			// Get the pages data structure from komga for the current book
			const komgaPageData = await callAPI(`/api/v1/books/${bookId}/pages`);

			// mb.readerMaxRatioOLD = Math.max(...dataOut.map(item => (item.isCover || item.isDoubleSpread) ? 0 : ((item.width / item.height) < 1 ? 2 * item.width / item.height : 2 * item.width / item.height)));
			mb.readerMaxRatio = komgaPageData.map(item => ((item.width / item.height) < 1 ? 2 * item.width / item.height : item.width / item.height))
				.reduce((sum, ratio) => sum + ratio, 0) / komgaPageData.length;
			// readerViewer.style.height='100vh';
			readerViewer.style.height = `calc(min(${100 / (0.5 * mb.readerMaxRatio)}vw, 100vh))`;
			//readerViewer.style.width=`calc(${mb.readerMaxRatio} * 100vh)`;
			readerViewer.style.width = `calc(min(200vw, ${100 * mb.readerMaxRatio}vh))`;

			mb.readerHorizontal = isReaderHorizontal(mb.screenAR);
			thumbStripInner.style.flexDirection = !rd.ltr ? 'row-reverse' : 'row';

			// Create pageData structure with the fields from fetched data
			const pageData = komgaPageData.map(page => ({
				url: `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: noCover ? false : page.number == 1,
				isOrphan: noWhitePage && (page.number == 2),
				isCurrent: page.number == rd.currentPage,
				isDoubleSpread: page.width > page.height,
				size: page.sizeBytes
			}));

			rd.foreEdgeL = addItem('div', {
				id: 'foreEdgeL',
				src: 'pages-left.png',
				style: {
					clipPath: 'inset(0 0 0 100%)'
				},
			});

			rd.foreEdgeR = addItem('div', {
				id: 'foreEdgeR',
				src: 'pages-right.png',
				style: {
					clipPath: 'inset(0 100% 0 0)'
				}
			});

			//Default shadow opacity is 0, it is overriden at the time of creation so it transitions in 0.5s
			rd.dropShadowL = addItem('div', { id: 'dropShadowL' });
			rd.dropShadowR = addItem('div', { id: 'dropShadowR' });

			readerViewer.append(rd.foreEdgeL, rd.foreEdgeR, rd.dropShadowL, rd.dropShadowR);

			// Create html structure for every page and related page thumbnails
			// and organize data structur for spread formation

			let i_page = 0; 		// Index of komga page data

			// double spread with single page are treated as this:
			// one div for the spread contains TWO pages sharing the same image, but with different alignment properties
			// therefore the pageNums are like [5, 5] and the imageRefs are like (5,6)

			// Create spreads objects and pages objects
			while (i_page < pageData.length) {
				let spreadObject = null;
				if (pageData[i_page].isCover) {
					// Element is a cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('cover-page', pageTable(hidden, cover), pageData[i_page].pageNum);
				}
				else if (pageData[i_page].isDoubleSpread) {
					// Element is a double spread, generate second set of images
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('double-spread', pageTable(page1, page2), pageData[i_page].pageNum);
				}
				else if (i_page == pageData.length - 1) {
					// Element is last single page, so back cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('back-cover', pageTable(cover, hidden), pageData[i_page].pageNum);
				}
				else if (((i_page + 1 < pageData.length) && (pageData[i_page + 1].isDoubleSpread)) || (pageData[i_page].isOrphan)) {
					// This is an orphan page!
					const page1 = buildPageObject('blank');
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum);
				}
				else {
					// these are two normal pages
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page + 1]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum);
					i_page++;
				}
				rd.spreadsArray.push(spreadObject);
				i_page++;
			}

			// Style and structure the spread objects and pages
			rd.spreadsArray.forEach((spreadObject, index) => {

				let pageObjectL = spreadObject.pageObjL;
				let pageObjectR = spreadObject.pageObjR;

				spreadObject.uiThumb.append(
					pageObjectL.uiThumb,
					pageObjectR.uiThumb,
				);

				spreadObject.uiItem.append(
					pageObjectL.uiContainer,
					pageObjectR.uiContainer,
				);

				buildSize2P(spreadObject.uiItem, mb.readerMaxRatio);
				//TODO Ma questo serve???? Farlo uguale a readerViewer?
				spreadObject.uiItem.style.width = `calc(min(200vw, ${100 * mb.readerMaxRatio}vh))`;

				buildSize(pageObjectL.uiContainer, mb.readerMaxRatio * 0.5);
				buildSize(pageObjectR.uiContainer, mb.readerMaxRatio * 0.5);

				pageObjectL.uiPage.style.float = 'right';
				pageObjectR.uiPage.style.float = 'left';
				pageObjectL.uiPage.style.objectFit = 'cover';
				pageObjectR.uiPage.style.objectFit = 'cover';
				pageObjectL.uiPage.style.objectPosition = 'left';
				pageObjectR.uiPage.style.objectPosition = 'right';
				pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
				pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				if ((pageObjectL.isCurrent) || (pageObjectR.isCurrent)) rd.currentSpreadIndex = index;

				if ((spreadObject.spreadKind == 'cover-page') || (spreadObject.spreadKind == 'back-cover')) {
					spreadObject.uiItem.classList.add('cover-page')

					pageObjectL.uiContainer.classList.add('cover-page-RTL');
					pageObjectR.uiContainer.classList.add('cover-page-LTR');
					pageObjectL.uiContainer.style['marginLeft'] = 'auto';
					pageObjectR.uiContainer.style['marginRight'] = 'auto';

					buildSizeCV(pageObjectL.uiPage, mb.readerMaxRatio * 0.5);
					buildSizeCV(pageObjectR.uiPage, mb.readerMaxRatio * 0.5);

					addCoverSpine(pageObjectL, pageObjectR);

				}
				else if (spreadObject.spreadKind == 'two-pages') {
					spreadObject.uiItem.classList.add('two-pages');

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR ?? pageObjectR.AR;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectR.AR ?? pageObjectL.AR;

					pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
					pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				}
				else if (spreadObject.spreadKind == 'double-spread') {
					spreadObject.uiItem.classList.add('two-pages');

					// Crop double spreads thumbnails
					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectL.uiThumb.style.objectFit = 'cover';
					pageObjectR.uiThumb.style.objectFit = 'cover';
					pageObjectL.uiThumb.style.objectPosition = 'left';
					pageObjectR.uiThumb.style.objectPosition = 'right';

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					buildSize(pageObjectL.uiPage, pageObjectL.AR * 0.5);
					buildSize(pageObjectR.uiPage, pageObjectR.AR * 0.5);

				}
				spreadObject.uiItem.append(spreadObject.uiShadowL, spreadObject.uiShadowR);
				spreadObject.uiItem.append(spreadObject.uiLightL, spreadObject.uiLightR);

				readerViewer.append(spreadObject.uiItem);
				spreadHide(index);

				const localSpread = index;

				spreadObject.uiThumb.addEventListener('click', () => {
					jumpToSpread(localSpread);
				});
				thumbStripInner.append(spreadObject.uiThumb);

			});

			//TODO Qui non funziona bene, spostato dopo initviewer, si pu togliere?
			spreadSetFocus(getSpreadFocus(rd.currentSpreadIndex));

			return pageData;
		}

		// Starts timeout for element id of the preload stack
		function startTimeout(id, duration, callback) {
			const timeoutId = setTimeout(() => {
				// Execute the callback when the timeout finishes
				callback();
				delete rd.preloadStack[id];
			}, duration);

			// Add the timeoutId to the stack
			rd.preloadStack[id] = timeoutId;
		}

		// Function to clear all timeouts (optional, if you need this functionality)
		function clearAllTimeouts() {
			Object.values(rd.preloadStack).forEach(timer => {
				clearTimeout(timer);
			});
			rd.preloadStack = {};
		}

		// Calculate stack size for the image loading stack
		function picLoadStackSize() {
			let out = 0;
			rd.picLoadStack.forEach(element => {
				out += element.size;
			});
			return (out);
		}

		function printStack(str_in) {
			return; //XXX Disable debug of preload stack
			let out = str_in + ' *';
			rd.picLoadStack.forEach(element => {
				out = out + ' ' + element;
			})
			out = 'tot:' + rd.picLoadStack.length + ' ' + out + ' *';
			console.log(out);
		}

		// Actually load media in the selected index, isPreload is true if the population action is
		// triggered by a preload, so it doesn't trigger further preloads

		async function populateSpread(spreadIndex, isPreload = false) {
			if (isSectionHidden(readerContainer)) return; //XXX THIS IS PROBABLY THE BEST

			let uiPageArray = [
				rd.spreadsArray[spreadIndex].pageObjL,
				rd.spreadsArray[spreadIndex].pageObjR,
			].filter(el => el != null);

			const promises = uiPageArray.map(async (element, index) => {

				if (rd.picLoadStack.indexOf(element) == -1) {
					if (!element.hasSrc) {
						rd.picLoadStack.push(element); // Add to the stack
						printStack('S');
						element.uiPage.classList.add('loading');
						try {
							// Fetch the image
							const blobUrl = await fetchMedia(element.lazySrc);
							if (isSectionHidden(readerContainer)) return;
							// These lines reduce stuttering
							//TODO Verify if this creates some errors when going back from reader and pages are still loading
							const img = new Image();
							img.src = blobUrl;
							await img.decode();

							element.uiPage.src = blobUrl;
							element.hasSrc = true;
							//rd.uiPages[element].src = rd.pagesDataArray[element].url;
							// Handle successful load
							element.uiPage.addEventListener('load', () => {
								element.uiPage.classList.add('loaded');
								element.uiPage.classList.remove('hidden');
								element.uiPage.classList.remove('loading');
								if (isSectionHidden(readerContainer)) {
									printStack('LX ');
									return;
								}
								const index = rd.picLoadStack.indexOf(element);
								printStack('L ' + index);
								if (index !== -1) {
									rd.picLoadStack.splice(index, 1); // Remove from stack
								};
								if (!isPreload) {
									preloadPages(spreadIndex, rd.preloadCount)
								}
							});
						} catch (error) {
							console.error(`Failed to load image for element ${element}:`, error);
							// Handle error (optional: remove from stack or show fallback)
						}
					}

					// Immediately handle cached images
					else if (element.uiPage.complete) {
						element.uiPage.classList.add('loaded');
						element.uiPage.classList.remove('hidden');
						element.uiPage.classList.remove('loading');
						const index = rd.picLoadStack.indexOf(element);
						if (index !== -1) {
							rd.picLoadStack.splice(index, 1);
						}
						//XXX REMOVED Force preload when landing on a cached image

						if (!isPreload) {
							preloadPages(spreadIndex, rd.preloadCount)
						}
					}
				}
			});

			// Wait for all fetches to complete
			await Promise.all(promises);
		}

		function populateSpreadPreload(spreadIndex) {
			populateSpread(spreadIndex, true)
		}

		function handleArrow(direction) {
			const isDirectionLeft = (direction === 'left');
			const delta = (rd.ltr === isDirectionLeft) ? -1 : 1;
			const newSpread = rd.currentSpreadIndex + delta;

			if (rd.pageTurning === direction) return;
			if (newSpread < 0 || newSpread > spreadsTotal()) return;
			if ((newSpread >= spreadsTotal()) && (rd.spreadsArray[rd.currentSpreadIndex].spreadKind == 'back-cover')) return;

			const edgeFocus = isDirectionLeft ? 'focus-right-page' : 'focus-left-page';
			const targetFocus = isDirectionLeft ? 'focus-left-page' : 'focus-right-page';

			if (!mb.readerHorizontal && newSpread === spreadsTotal() && rd.spreadFocus === edgeFocus) {
				return spreadSetFocusSmooth(targetFocus);
			}

			if ((newSpread === 0 || newSpread === spreadsTotal() - 1) && rd.pageTurning) return;

			const earlyTurnBlock = (isDirectionLeft === rd.ltr) && rd.currentSpreadIndex === spreadsTotal() - 2;
			const lateTurnBlock = (isDirectionLeft !== rd.ltr) && rd.currentSpreadIndex === 1;
			if ((earlyTurnBlock || lateTurnBlock) && rd.pageTurning) return;


			if (mb.readerHorizontal) {
				jumpToSpread(newSpread);
			} else if (rd.spreadFocus === edgeFocus) {
				spreadSetFocusSmooth(targetFocus);
			} else {
				jumpToSpread(newSpread, edgeFocus);
			}
		}

		function handleLeftArrow() {
			handleArrow('left');
		}

		function handleRightArrow() {
			handleArrow('right');
		}

		function handleLeftLimit() {
			jumpToSpread(rd.ltr ? 0 : spreadsTotal() - 1);
		}

		function handleRightLimit() {
			jumpToSpread(rd.ltr ? spreadsTotal() - 1 : 0);
		}

		function handleSmallThumbs() {
			setThumbZoom(false);
		};

		function handleLargeThumbs() {
			setThumbZoom(true);
		};


		function getPageFromSpread(index) {
			const spreadObject = rd.spreadsArray[index];

			//TODO Cosa succede se finisce con uno un orfano?
			const twoPages = (rd.spreadsArray[index].spreadKind == 'two-pages');
			const lastSpread = (twoPages && (index == (spreadsTotal() - 1)));

			//const currentPage = (lastSpread && rd.ltr) ? pageNumber + 1 : pageNumber;
			const currentPage = lastSpread ? spreadObject.spreadRefPage + 1 : spreadObject.spreadRefPage;
			const pageNumText = spreadObject.pageObjL.pageNum + " " + spreadObject.pageObjR.pageNum;

			const out = [currentPage, pageNumText];

			return out;
		}

		//TODO con newpage calcoalto dalla funzione esterna e a ogni bar update, ripulire se serve questa cosa
		function jumpString() {
			const stringOut = `${mb.basePath}#bookread
			?library_id=${rd.libraryId}
			&series_id=${rd.seriesId}
			&book_id=${rd.bookId}
			&dir=${rd.ltr ? 'ltr' : 'rtl'}
			&pag=${rd.currentPage}`;

			if (!rd.incognito) {
				callAPI(`/api/v1/books/${rd.bookId}/read-progress`, 'PATCH', JSON.stringify({ page: rd.currentPage }), false)
					.catch(error => console.error('Error:', error));
			}

			return (stringOut);
		}

		function purgeLoading() {
			for (let i = rd.picLoadStack.length - 1; i >= 0; i--) {
				const item = rd.picLoadStack[i];
				item.hasSrc = false;
				item.uiPage.src = 'transparent.png';
				rd.picLoadStack.splice(i, 1); // Remove the element at index i
				printStack('P');
			}
			clearAllTimeouts();
		}

		// Thumbnail scrolling functions
		function thumbSmoothScroll(container, targetScrollLeft, duration = 500) {
			const start = container.scrollLeft;
			const change = targetScrollLeft - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollLeft = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}
			requestAnimationFrame(animateScroll);
		}

		function centerThumb(fast = false) {
			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInner.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInner.children[rd.currentSpreadIndex]; // n-th element (0-based index)

			if (targetElement) {
				const targetScrollLeft = -thumbStripScrollContent.clientWidth / 2 + targetElement.offsetLeft - thumbStripScrollContent.offsetLeft + targetElement.clientWidth / 2;

				if (!fast) {
					thumbSmoothScroll(thumbStripScrollContent, targetScrollLeft, 300);
				} else {
					thumbStripScrollContent.scrollLeft = targetScrollLeft;
				};

				thumbStripInner.children[rd.currentSpreadIndex].classList.add('current');
			}
		}

		function animShadowFWD(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0', opacity: '0.1' },
				{ [align]: '50%', width: rd.pageShadowWidthFWD, opacity: rd.pageShadowOpacityFWD },
				{ [align]: '100%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function animShadowBWD(align, duration, ease) {
			return ([
				[{ [align]: '100%', width: '0', opacity: '0' },
				{ [align]: '75%', width: rd.pageShadowWidthBWD, opacity: rd.pageShadowOpacityBWD },
				{ [align]: '50%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function animLight(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0%', opacity: '0.5' },
				{ [align]: '25%', width: '20%', opacity: '1' },
				{ [align]: '50%', width: '30%', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function hideOldSpread(index, oldindex) {
			if (oldindex != index) spreadHide(oldindex);
		}

		function pageTurn(index, oldindex, turnDirection, force = false) {
			//Z-index control
			rd.spreadsArray[index].uiItem.style.zIndex = spreadsTotal() + 1;

			if (turnDirection == 'turn-right') {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.ltr ? spreadsTotal() - oldindex : oldindex;
			} else {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.ltr ? oldindex : spreadsTotal() - oldindex;
			}

			rd.dropShadowL.style.zIndex = rd.dropShadowR.style.zIndex = 0;

			const easeFull = 'cubic-bezier(0.42, 0, 0.58, 1)'
			const easeIn = 'cubic-bezier(0.42, 0, 0.71, 1)'
			const easeOut = 'cubic-bezier(0.29, 0.5, 0.58, 1)'

			// Animation preparation
			const turnTime = force ? 0 : rd.turnTime;
			const animData = { duration: turnTime, easing: easeFull, fill: 'forwards' };
			const animInstant = { duration: 0, easing: 'linear', fill: 'forwards' };

			const appearR2L_slideinL2R = [
				{ clipPath: 'inset(0 0 0 100%)', left: '-100%' },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearL2R = [
				{ clipPath: 'inset(0 100% 0 0)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const appearL2R_sildeinR2L = [
				{ clipPath: 'inset(0 100% 0 0)', left: '100%' },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearR2L = [
				{ clipPath: 'inset(0 0 0 100%)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const clipL2R = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 0 0 100%)' }
			];
			const clipR2L = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 100% 0 0)' }
			];
			const unFade = [
				{ filter: 'brightness(90%) sepia(10%)' },
				{ filter: 'brightness(100%) sepia(0%)' }
			];
			const fade = [
				{ filter: 'brightness(100%) sepia(0%)' },
				{ filter: 'brightness(90%) sepia(10%)' }
			];

			if (oldindex != index) rd.spreadsArray[oldindex].uiItem.animate(fade, { duration: rd.turnTime, easing: 'ease-in' });

			const startCover = ((rd.spreadsArray[oldindex].spreadKind == 'cover-page') || (rd.spreadsArray[oldindex].spreadKind == 'back-cover'));
			const stopCover = ((rd.spreadsArray[index].spreadKind == 'cover-page') || (rd.spreadsArray[index].spreadKind == 'back-cover'));

			//turnDirection can be 'turn-right' or 'turn-left'
			rd.foreEdgeL.style.transition = 'clip-path 0.3s';
			rd.foreEdgeR.style.transition = 'clip-path 0.3s';
			rd.dropShadowL.style.transition = 'margin 0.3s, opacity 0.5s';
			rd.dropShadowR.style.transition = 'margin 0.3s, opacity 0.5s';

			clipForeEdge = buildForeEdge(index, spreadsTotal())

			// Margins are defined as percentage of total width, so to have the correct size we divide
			// by mb.readerMaxRatio, then multiply by the drop aspect ratio (0.1) and apply the dropL and dropR proportion
			rd.dropShadowL.style.marginRight = (0.1 * clipForeEdge.dropL * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.marginLeft = (0.1 * clipForeEdge.dropR * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.opacity = 1;
			rd.dropShadowL.style.opacity = 1;

			rd.pageTurning = (turnDirection == 'turn-right' ? 'right' : 'left');

			if (!startCover && !stopCover) {
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer;
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					leftPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));
				} else {
					rightPage.animate(appearR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R_sildeinR2L, animData);
					rightPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));
				}

				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;

			} else if (startCover && stopCover) {
				let startCoverPageL = rd.spreadsArray[oldindex].pageObjL.uiContainer
				let startCoverPageR = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let stopCoverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let stopCoverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.foreEdgeL.style.transition = 'clip-path 0s';
				rd.foreEdgeR.style.transition = 'clip-path 0s';
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;
				rd.dropShadowL.style.transition = 'margin 0s';
				rd.dropShadowR.style.transition = 'margin 0s';
				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;

				if (turnDirection == 'turn-right') {
					startCoverPageR.animate(clipL2R, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageR.animate(appearR2L, animInstant);
					rd.dropShadowR.animate([{ left: '100%' }], animInstant);
					rd.dropShadowL.animate([{ right: '50%' }], animInstant);
				} else {
					startCoverPageL.animate(clipR2L, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageL.animate(appearL2R, animInstant);
					rd.dropShadowL.animate([{ right: '100%' }], animInstant);
					rd.dropShadowR.animate([{ left: '50%' }], animInstant);
				}
			} else if (startCover) {
				// Start Page (cover or back cover)
				//let coverPage = rd.spreadsArray[oldindex].pageObj.uiContainer
				// Stop Page (mid spread)
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeR.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowR.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					rd.dropShadowR.animate(
						[{ left: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: "forwards", delay: turnTime * 0.5 }
					);
				} else {
					rd.foreEdgeL.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowL.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					rightPage.animate(appearR2L, animData);
					leftPage.animate(appearL2R_sildeinR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					rd.dropShadowL.animate(
						[{ right: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: "forwards", delay: turnTime * 0.5 }
					);
				}
				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;
			} else if (stopCover) {
				// Start Page (mid spread)
				let rightPage = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[oldindex].pageObjL.uiContainer
				// Stop Page (cover or back cover)
				let coverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let coverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeL.style.transition = 'clip-path 0s';
					leftPage.animate(clipL2R, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					coverPageR.animate(appearR2L_slideinL2R, animData);
					coverPageL.animate(appearL2R, animData);
					rd.dropShadowL.animate(
						[{ right: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: "forwards" }
					);
				} else {
					rd.foreEdgeR.style.transition = 'clip-path 0s';
					rightPage.animate(clipR2L, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					coverPageL.animate(appearL2R_sildeinR2L, animData);
					coverPageR.animate(appearR2L, animData);
					rd.dropShadowR.animate(
						[{ left: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: "forwards" }
					);
				}
			}

			clearTimeout(rd.turnTimeout);
			rd.turnTimeout = setTimeout(() => {
				rd.pageTurning = null;
			}, turnTime);
		}

		// Generic spread class definition, not valid for arrowleft and right in portrait mode!
		function getSpreadFocus(spreadIndex) {
			const spreadKind = rd.spreadsArray[spreadIndex].spreadKind;
			if (spreadKind === 'cover-page') {
				return rd.ltr ? 'focus-right-page' : 'focus-left-page';
			}
			if (spreadKind === 'back-cover') {
				return rd.ltr ? 'focus-left-page' : 'focus-right-page';
			}
			if (mb.readerHorizontal) {
				return 'focus-center';
			}
			return rd.ltr ? 'focus-left-page' : 'focus-right-page';
		}

		function jumpToSpread(targetSpreadIndex, targetSpreadFocus = null, skipHistory = false) {

			if (rd.isDraggingProgressBar) {
				updateProgressBar(targetSpreadIndex);
				return;
			}

			const localOldSpreadIndex = skipHistory ? 0 : rd.currentSpreadIndex;
			const localNewSpreadIndex = targetSpreadIndex;

			if ((targetSpreadIndex < 0) || (targetSpreadIndex >= spreadsTotal()) || (!skipHistory && (localOldSpreadIndex == localNewSpreadIndex))) return;

			if (targetSpreadFocus == null) {
				targetSpreadFocus = getSpreadFocus(localNewSpreadIndex);
			}

			purgeLoading();

			rd.oldSpreadIndex = localOldSpreadIndex;
			rd.currentSpreadIndex = localNewSpreadIndex;

			if (isSectionHidden(readerContainer)) return;


			populateSpread(localNewSpreadIndex);

			// TODO
			// It always call spreadSetFocusSmoothDelay, because when in horiontal mode the target is 
			// center and there's no scrolling happening in that case, page turn is treated separately 
			// This adds a slight delay when jumping cover to cover
			spreadSetFocusSmoothDelay(targetSpreadFocus);

			spreadShow(localNewSpreadIndex);

			const turnDirectionCalc = (localNewSpreadIndex > localOldSpreadIndex) === rd.ltr ? 'turn-left' : 'turn-right';
			pageTurn(localNewSpreadIndex, localOldSpreadIndex, turnDirectionCalc, skipHistory)

			centerThumb();
			updateProgressBar();

			if (!skipHistory) history.replaceState(null, '', jumpString());
		}

		function jumpToSpreadSkipHistory(targetSpreadIndex) {
			jumpToSpread(targetSpreadIndex, null, true)
		}

		// Reader UI Control Buttons
		function toggleMenu() {
			sectionToggle(controlPanel);
			touchPanel.classList.toggle('shrink');
		}

		function hideMenu() {
			sectionHide(controlPanel);
			touchPanel.classList.remove('shrink');
		}

		leftArrow.addEventListener('click', handleLeftArrow);
		rightArrow.addEventListener('click', handleRightArrow);
		leftLimit.addEventListener('click', handleLeftLimit);
		rightLimit.addEventListener('click', handleRightLimit);

		toLeftPage.addEventListener('click', handleLeftArrow);
		toRightPage.addEventListener('click', handleRightArrow);
		openMenu.addEventListener('click', toggleMenu);

		// Seek function to move to specific spread based on click or drag
		function seek(event) {

			const progressBarWidth = readerProgressBar.offsetWidth;
			const clickX = event.clientX - readerProgressBar.getBoundingClientRect().left;
			const newProgressPercent = Math.min(1, Math.max(0, rd.ltr ? clickX / progressBarWidth : (progressBarWidth - clickX) / progressBarWidth));

			jumpToSpread(Math.floor(newProgressPercent * (spreadsTotal() - 1)));
		}

		// Dragging the progress bar
		readerProgressBar.addEventListener('mousedown', (event) => {
			rd.isDraggingProgressBar = true;
			event.preventDefault();
			seek(event);
		});

		readerProgressBar.addEventListener('touchstart', (event) => {
			rd.isDraggingProgressBar = true;
			seek(event.touches[0]); // Use the first touch point
		});


		mainContainer.addEventListener('scroll', function () {

			if (!isSectionHidden(seriesMiniHeader)) {
				if ((mainContainer.scrollTop > 180) && (seriesMiniHeader.classList.contains('collapse'))) {
					seriesMiniHeader.classList.remove('collapse');
				} else if ((mainContainer.scrollTop < 200) && !seriesMiniHeader.classList.contains('collapse')) {
					seriesMiniHeader.classList.add('collapse');
				}
			}

			if (!isSectionHidden(stripGridContainer)) {
				if ((mainContainer.scrollTop < 5) && (stripGridHeaderContainer.classList.contains('collapse'))) {
					stripGridHeaderContainer.classList.remove('collapse');
				} else if ((mainContainer.scrollTop > 10) && !stripGridHeaderContainer.classList.contains('collapse')) {
					stripGridHeaderContainer.classList.add('collapse');
				}
			}
		});

		seriesMiniHeader.addEventListener('click', () => {
			mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
		});

		document.addEventListener('mousemove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event);
			}
		});
		document.addEventListener('touchmove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event.touches[0]);
			}
		});

		document.addEventListener('mouseup', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		document.addEventListener('touchend', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event.changedTouches[0]);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		document.addEventListener('keydown', (event) => {
			const readerVisible = !isSectionHidden(readerContainer);

			switch (event.key) {
				case 'ArrowLeft':
					if (readerVisible) handleLeftArrow();
					break;
				case 'ArrowRight':
					if (readerVisible) handleRightArrow();
					break;
				case 'Escape':
				case 'ArrowDown':
					if (readerVisible) handleCloseReader();
					break;
				case ' ':
					if (readerVisible) toggleMenu();
					break;
				default:
					break;
			}
		});

		document.addEventListener('pointerup', (event) => {
			if (mb.currentlyScaled && !mb.currentlyScaled.contains(event.target)) {
				mb.currentlyScaled.classList.remove('scaled');
				mb.currentlyScaled.parentElement.classList.remove('top-pop');

				mb.currentlyScaled = null;
			}
		});

		document.addEventListener('click', (event) => {
			if ((mb.libMenuVisible != null) && (!filtersBar.contains(event.target))) {
				libMenuDown(mb.libraryMenuButtons[mb.libMenuVisible]);
				sectionToggle(filtersBar);
				mb.libMenuVisible = null;
			}

			if ((mb.swatchMenuVisible) && (!colorSwatchBar.contains(event.target)) && (!colorChanger.contains(event.target))) {
				mb.swatchMenuVisible = false;
				sectionHide(colorSwatchBar);
			}

		});

		//MB URL Parsing and LoadContent Function 
		function getHashAndParams() {
			const fullHash = window.location.hash.substring(1); // Remove leading '#'
			const [path, paramString] = fullHash.split('?'); // Separate path and parameters
			const params = paramString == undefined ? null : new URLSearchParams(paramString ?? '');
			return { path, params };
		}

		async function loadContent() {
			const { path, params } = getHashAndParams();

			await executeFade(1);
			dragbarOffReader();
			document.querySelectorAll('.section').forEach(section => sectionHide(section));

			//In part useless because of the click outside events, but useful when loading an url
			sectionHide(filtersBar);
			sectionHide(colorSwatchBar);

			clearLibrariesMenus();

			closeBookDetails();
			mb.screenAR = getScreenAR();

			switch (path) {
				case '':
				case 'dashboard':
					searchInput.value = '';
					setIncognito(false);
					if ((params == null) || (params.size == 0)) {
						await selectHome();
						if (mb.dashboardBin) {
							const y = dashboardElements[mb.dashboardBin].element.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop - 10;

							mainContainer.scrollTo({ top: y });
							mb.dashboardBin = '';
						}
					} else {
						dashboardAll(params.get('all'), params.get('page'));
					}
					break;
				case 'library':
					mb.dashboardBin = '';
					searchInput.value = '';
					setIncognito(false);
					await openLibrary(params.get('library_id'), params.get('series_id'));
					break;
				case 'series':
					searchInput.value = '';
					setIncognito(false);
					await openSeries(params.get('library_id'), params.get('series_id'), params.get('book_id'));
					break;
				case 'search':
					setIncognito(false);
					searchInput.value = params.get('search_string');
					await performSearch(params.get('search_string'));
					break;
				case 'bookread':
					await openBookReader(params.get('library_id'), params.get('series_id'), params.get('book_id'), params.get('dir'), params.get('pag'));
					break;
				default:
					console.log('no selection');
			}
			await executeFade(0);
		}

		// This is the most important function, it updates the history and then passes the path to the loadContent function that does all the work
		// In MB the navigateTo function with a proper path form will open the different sections and activate various states.
		function navigateTo(path) {
			history.pushState(null, '', mb.basePath + path);
			loadContent();
		}

		// Lazy-loading setup with Intersection Observer
		const lazyLoadingObserver = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				if (entry.isIntersecting) {
					const img = entry.target;
					img.classList.add('loading');

					// TODO Set the actual src from lazySrc, check if needed
					const imageUrl = await fetchMedia(img.lazySrc);
					img.src = imageUrl;

					// Remove lazySrc to clean up
					delete img.lazySrc;

					img.addEventListener('load', () => {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
						setTimeout(() => {
							img.classList.remove('loaded');
							img.classList.add('finished');
						}, 1000);
					});
					if (img.complete) {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
					}
					// Stop observing this image
					observer.unobserve(img);
				}
			});
		});

		// Function to add lazy loading to an image
		function addLazyLoading(img) {
			lazyLoadingObserver.observe(img);
		}

		window.addEventListener('hashchange', loadContent);
		document.addEventListener('popstate', loadContent);

		document.querySelectorAll('.press-button').forEach(item => addPressEvents(item, pressDown, pressUp));

		if (loginScreen.classList.contains('auth-hidden')) bootSequence();


		//MB Reader touch response fucntions
		function getTrueScale() {
			return window.innerWidth / window.visualViewport.width;
		}
		function getDerivedScale() {
			return document.documentElement.clientWidth / window.visualViewport.width;
		}

		function enableTouchResponse(item, threshold, onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown) {
			item.SingleTouch = true;
			item.TouchStartX = 0;
			item.TouchStartY = 0;

			function handleTouchStart(event) {
				if (getDerivedScale() > 1.01) return;

				if (event.touches.length > 1) {
					item.SingleTouch = false; // Multiple touches: ignore for swipe
					return;
				}
				item.SingleTouch = true;
				item.TouchStartX = event.touches[0].clientX;
				item.TouchStartY = event.touches[0].clientY;
			}

			function handleTouchMove(event) {
				if (getDerivedScale() > 1.01 || !item.SingleTouch) return;

				const touchEndX = event.touches[0].clientX;
				const touchEndY = event.touches[0].clientY;

				const diffX = touchEndX - item.TouchStartX;
				const diffY = touchEndY - item.TouchStartY;


				if (Math.abs(diffX) > threshold && Math.abs(diffY) < threshold) {
					if (diffX > 0) {
						onSwipeRight?.(); // Call custom right swipe function
					} else {
						onSwipeLeft?.(); // Call custom left swipe function
					}
					item.SingleTouch = false; // Prevent repeat action on the same swipe
				} else if (Math.abs(diffY) > threshold && Math.abs(diffX) < threshold) {
					if (diffY > 0) {
						onSwipeDown?.(); // Call custom down swipe function
					} else {
						onSwipeUp?.(); // Call custom up swipe function
					}
					item.SingleTouch = false;
				}
			}

			item.addEventListener('touchstart', handleTouchStart);
			item.addEventListener('touchmove', handleTouchMove);
		}

		enableTouchResponse(touchPanel, 30, handleRightArrow, handleLeftArrow, null, handleCloseReader);
		enableTouchResponse(thumbStrip, 20, null, null, handleLargeThumbs, handleSmallThumbs);

	</script>
</body>

</html>