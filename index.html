<!DOCTYPE html>
<html lang="en">

<head>
	<title>MangaBox</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">

	<meta name="theme-color" content="black">

	<!--<link rel="icon" href="ab_16_alpha.png" type="image/png">-->
	<link rel="icon" href="logo/mangabox-logo-new-favicon.svg" type="image/svg+xml">
	<link rel="apple-touch-icon" href="logo/mangabox-logo-new-red.png">


	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap" rel="stylesheet">


	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="manifest" href="manifest.json">
	<link rel="stylesheet" type="text/css" href="style-auth.css">

	<link rel="stylesheet" href="fontawesome/all.min.css">

	<link rel="stylesheet" href="style-mangabox-blankstart.css">
	<link rel="stylesheet" href="style-mangabox-main.css">
	<link rel="stylesheet" href="style-mangabox-reader.css">

</head>

<body>
	<div id="mainUI">
		<div id="menuBars">
			<div id="stickyContainer" class="hidden">
				<ul id="librariesList"></ul>
				<ul id="librariesRightBlock">
					<li id="fullscreenChanger" title="Toggle Fullscreen" class="library-item press-button">
						<div class="button-wrapper">
							<span id="fullscreenLabel" class="fa-expand fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="themeChanger" title="Light/Dark Theme" class="library-item press-button">
						<div class="button-wrapper">
							<span id="themeLabel" class="theme-label fa-solid glyph-dark"></span>
						</div>
					</li>
					<li id="colorChanger" title="Theme Color" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-paint-roller glyph-dark mb-accent"></span>
						</div>
					</li>
					<li id="offlineLibrary" title="Offline Books" class="library-item no-grow press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-download glyph-dark"></span>
						</div>
						<div id="downloadSpinner" class="download-overlay"></div>
					</li>
					<li id="searchField" title="Search" class="library-item search-field no-grow press-button">
						<div id="searchIcon" class="button-wrapper">
							<span class="fa-solid fa-magnifying-glass glyph-dark"></span>
						</div>
						<input id="searchInput" type="text" class="search-input" placeholder="Search...">
					</li>
					<li id="logOut" title="Logout" class="library-item press-button">
						<div class="button-wrapper">
							<span class="fa-solid fa-arrow-right-from-bracket glyph-dark"></span>
						</div>
					</li>
				</ul>
				<div id="offlineLed">OFFLINE</div>
			</div>

			<div id="filtersBar" class="extra-bar hidden blankstart">
				<ul id="extraButtons" class="filters-list buttons"></ul>
			</div>

			<div id="colorSwatchBar" class="extra-bar hidden blankstart">
			</div>

		</div>
		<div id="mainScrollBox" class="scrollbox" data-scroll-direction="vertical">
			<div id="mainContainer" class="scrollbox-content">
				<div id="seriesHeader" class="section hidden"></div>

				<div id="seriesGrid" class="section hidden"></div>

				<div id="booksGrid" class="section hidden"></div>

				<div id="offlineGrid" class="section hidden"></div>

				<div id="stripGridContainer" class="section hidden">
					<div id="stripGrid" class="strip-grid"></div>
					<div id="stripGridHeaderContainer" class="stripgrid-header-container">
						<div id="stripGridHeader" class="strip-header">
							<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading
						</div>
						<div id="stripGridRight" class="stripgrid-all">
							<span id="stripPrevPage" title="Previous Page" class="disabled fa-solid fa-play flip-horizontal glyph-dark strip-button press-flat-button"></span>
							<span id="stripNextPage" title="Next Page" class="disabled fa-solid fa-play glyph-dark strip-button press-flat-button"></span>
						</div>
					</div>
				</div>

				<div id="seriesMiniHeader" class="section hidden collapse"></div>

				<div id="homeStripsContainer" class="section hidden"></div>

				<div id="searchStripsContainer" class="section hidden">

					<div class="home-strip-parent">
						<div id="homeStripSeriesResults" class="series-results search-results"></div>
						<div class="strip-header-container">
							<div class="strip-header"><span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Series Results</div>
						</div>
					</div>

					<div class="home-strip-parent">
						<div id="homeStripBooksResults" class="books-results search-results"></div>
						<div class="strip-header-container">
							<div class="strip-header"><span class="fa-solid fa-book glyph-dark"></span>&nbsp;Books Results</div>
						</div>
					</div>
				</div>

				<!--
					<div id="offlineBooksGrid" class="section hidden"></div>
				-->

				<div id="bookDetailsContainer" class="section hidden blankstart">
					<div class="book-details-pic-container">
						<div class="mini-controls">
							<div class="mini-buttons-2 press-flat-button" title="Previous book" onclick="jumpBookDetailsPrev()">
								<span class="fa-solid fa-chevron-left"></span>
							</div>
							<div class="mini-buttons-2 press-flat-button" title="Go to library" onclick="jumpBookLibrary()">
								<span class="fa-solid fa-layer-group"></span>
							</div>
							<div class="mini-buttons-2 press-flat-button" title="Next book" onclick="jumpBookDetailsNext()">
								<span class="fa-solid fa-chevron-right"></span>
							</div>
						</div>
						<div id="bookDetailsContainerThumbnailWrapper" class="book-details-thumbnail-wrapper" title="Open Book" onclick="navigateToReadBook(mb.currentBook, mb.seriesData.metadata.readingDirection)">
							<img id="bookDetailCover" class="book-thumbnail hidden" src="transparent.png">
						</div>
					</div>
					<div>
						<div id="bookDetailsTitle" class="book-details-title"></div>
						<div class="ul-container">
							<ul id="bookDetailsSummary">
							</ul>
						</div>
					</div>
					<div class="close-details dialog-button press-button" onclick="closeBookDetails()">
						<span class="fa-solid fa-xmark"></span>
					</div>
				</div>

				<div id="blanker" style="opacity:1"></div>
			</div>
			<div class="scrollbox-scrollbar">
				<div class="scrollbox-thumb"></div>
			</div>
		</div>
	</div>

	<div id="readerContainer" class="section hidden">
		<div id="readerBackground" class="hidden"></div>

		<div id="readerViewer">
		</div>

		<div id="readerViewerWebtoon">
			<div id="webtoonContainer" class="hide-scrollbar"></div>
		</div>
	</div>

	<div id="readerOverlay" class="section hidden">
		<div id="incognitoMark" class="blankstart"></div>

		<div id="controlPanel" class="hidden">

			<div id="thumbStrip" class="scrollbox" data-scroll-direction="horizontal">
				<div id="thumbStripScrollContent" class="scrollbox-content">
					<div id="thumbStripInner"></div>
				</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			<div id="thumbStripButton">
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
			</div>

			<div id="thumbStripWT" class="scrollbox" data-scroll-direction="vertical">
				<div id="thumbStripScrollContentWT" class="scrollbox-content">
					<div id="thumbStripInnerWT"></div>
				</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			<div id="thumbStripButtonWT">
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
				<span class="thumb-arrow fa-solid fa-circle glyph-dark"></span>
			</div>

			<div id="topControls">
				<span id="readerClose" title="Close Reader" class="reader-buttons press-button corner-circle fa-solid fa-xmark"></span>
				<span></span>
				<span id="bookName"></span>
				<span id="readerTheme" title="Reader Theme" class="reader-buttons press-button corner-left fa-solid"></span>
				<span id="readerIncognito" title="Incognito Reading" class="reader-buttons press-button corner-right fa-solid fa-ghost"></span>
			</div>

			<div id="zoomControls">
				<span id="scaleDown" title="Scale Down" class="reader-buttons press-button corner-left fa-solid fa-minus" onclick="scaleWebtoon(-20)"></span>
				<span id="scaleVal" class="reader-buttons">100%</span>
				<span id="scaleUp" title="Scale Up" class="reader-buttons press-button corner-right fa-solid fa-plus" onclick="scaleWebtoon(20)"></span>
			</div>


			<div id="bottomControls">
				<span id="leftArrow" class="reader-buttons press-button corner-left fa-solid fa-caret-left"></span>
				<span id="leftLimit" class="bar-note press-button corner-right"></span>
				<div id="readerProgressBar" onclick="seek(event)">
					<div id="readerProgress"></div>
					<div id="readerPage"></div>
				</div>
				<span id="rightLimit" class="bar-note press-button corner-left"></span>
				<span id="rightArrow" class="reader-buttons press-button corner-right fa-solid fa-caret-right"></span>
			</div>

			<div id="nextBookPanel" class="modal-content hidden blankstart">
				<button id="nextBookButton" class="ok dialog-button press-button" onclick="handleCloseReader(); setTimeout(()=>{navigateToReadBook(rd.nextBook, rd.direction, true)},500)">GO TO NEXT BOOK</button>
			</div>

			<div id="prevBookPanel" class="modal-content hidden blankstart">
				<button id="prevBookButton" class="ok dialog-button press-button" onclick="handleCloseReader();setTimeout(()=>{navigateToReadBook(rd.prevBook, rd.direction, true)},500)">GO TO PREV BOOK</button>
			</div>

		</div>
	</div>

	<div id="touchPanel" class="section hidden">
		<div id="toLeftPage"></div>
		<div id="openMenu"></div>
		<div id="toRightPage"></div>
	</div>

	<div id="dragbar" class="draggable">
		<img id="barLogo" src="logo/mangabox-logo-new-favicon.svg">

		<!--<img id="barLogo" src="logo/mangabox-logo-new.svg">-->
		<span id="dragbarAppTitle">MangaBox</span>
		<div id="windowControls" , class="window-controls no-drag">
			<span class="fa-solid fa-window-minimize glyph-dark" id="dragbarMinBtn"></span>
			<span class="fa-regular fa-window-maximize glyph-dark" id="dragbarMaxBtn"></span>
			<span class="fa-solid fa-xmark glyph-dark" id="dragbarCloseBtn"></span>
		</div>
	</div>

	<div id="loginScreen" class="auth-hidden">
		<div id="loginDialog" class="dialog">
			<img src="logo/mangabox-logo-new.svg" width="90px" height="90px">
			<img src="logo/mangabox-logoname.svg" width="300px" style="opacity:0.7; margin-bottom:5px;">
			<div class="version-note">v0.2.8</div>
			<div class="input-wrapper" title="Server Address">
				<i class="fas fa-link"></i> <!-- Example icon for the base URL -->
				<input type="text" class="login-input" id="loginBaseUrl" placeholder="Komga Server URL" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="url">
			</div>

			<div class="input-wrapper" title="Username">
				<i class="fas fa-user"></i> <!-- Icon for username -->
				<input type="email" class="login-input" id="loginUsername" placeholder="Username" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="email">
			</div>

			<div class="input-wrapper" title="Password">
				<i class="fas fa-lock"></i> <!-- Icon for password -->
				<input type="password" class="login-input" id="loginPassword" placeholder="Password" autocorrect="off" autocapitalize="none" spellcheck="false" autocomplete="current-password">
			</div>

			<div class="login-buttons">
				<div class="remember-me-container">
					<input type="checkbox" id="loginRememberMe" class="remember-me-checkbox">
					<label for="rememberMe" class="remember-me-label">Remember Me</label>
				</div>
				<button class="login-button" onclick="login()">Login</button>
			</div>

			<p id="loginError" class="error-message auth-hidden">Invalid credentials or server URL, please try again.</p>
		</div>
	</div>

	<div id="myModal" class="modal">
		<div id="modalContent" class="modal-content">
			<div id="modalWrapper"><img id="modalImage"></div>
			<p id="modalMessage">This is the message content.</p>

		</div>
	</div>

	<div id="debuggerObj"></div>

	<script>
		const fullDebugMode = false;

		function debugPrint(text) {
			debuggerObj.innerText = debuggerObj.innerText + text + "\n";
		}

		const isElectron = !!window.electronAPI;
		const isCapacitor = !!window.Capacitor && window.Capacitor.isNativePlatform && window.Capacitor.isNativePlatform();

		const isStatusBar = isCapacitor && !!Capacitor.Plugins.StatusBar;
		let capacitorPlatform = null;

		let enableFullscreen = true;
		let enableDownload = true;

		let filesFolder = 'DOCUMENTS';

		if (isCapacitor) {
			capacitorPlatform = Capacitor.getPlatform();
			fullscreenChanger.remove();
			enableFullscreen = false;
			if (capacitorPlatform == 'android'){
				filesFolder = 'DATA';
			}
		}

		if (!isElectron && !isCapacitor && !fullDebugMode) {
			offlineLibrary.remove();
			enableDownload = false;
		}

		debugPrint("enabledownload" + enableDownload)
	</script>

	<script src="script-auth.js"></script>

	<script>
		if ("serviceWorker" in navigator) {
			window.addEventListener("load", () => {
				navigator.serviceWorker.register("/script-sw.js")
					.then(reg => console.log("Service Worker registered:", reg.scope))
					.catch(err => console.error("Service Worker registration failed:", err));
			});
		}

		executeFade(1);

		function isOrientationLandscape() {
			return window.matchMedia("(orientation: landscape)").matches;
		}

		function getSharpCornerIphone() {
			if (!/iPhone/.test(navigator.userAgent)) return false;

			const ratio = window.devicePixelRatio || 1;
			const width = Math.min(screen.width, screen.height) * ratio;
			const height = Math.max(screen.width, screen.height) * ratio;

			// List of iPhones with sharp corners (non-notch models)
			const sharpCornerModels = [
				// iPhone SE 2020 / SE 2022 / 8 / 7 / 6s / 6
				{ w: 750, h: 1334 },
				// iPhone SE (1st gen)
				{ w: 640, h: 1136 },
				// iPhone 8 Plus / 7 Plus / 6s Plus / 6 Plus
				{ w: 1242, h: 2208 },
			];

			return sharpCornerModels.some(m =>
				(m.w === width && m.h === height) || (m.h === width && m.w === height)
			);
		}

		/*
		const isPWA = window.matchMedia('(display-mode: standalone)').matches
			|| window.navigator.standalone === true;
		*/

		const isSharpCornerIphone = getSharpCornerIphone();

		if (isStatusBar) {
			if (isSharpCornerIphone || (capacitorPlatform == 'android' && isOrientationLandscape())) {
				Capacitor.Plugins.StatusBar.hide();
			} else {
				Capacitor.Plugins.StatusBar.show();
			}
		}

		//MB Pinch To Zoom

		const page = document.getElementById("touchPanel");
		const pageTarget = document.getElementById("readerContainer");

		function getDistance(touches) {
			const dx = touches[0].clientX - touches[1].clientX;
			const dy = touches[0].clientY - touches[1].clientY;
			return Math.sqrt(dx * dx + dy * dy);
		}

		function getMidpoint(touches) {
			return {
				x: (touches[0].clientX + touches[1].clientX) / 2,
				y: (touches[0].clientY + touches[1].clientY) / 2,
			};
		}

		function createPanResponse(page, pageTarget) {
			let isDragging = false;
			let lastX = 0, lastY = 0;
			let offsetX = 0, offsetY = 0; // accumulated pan

			page.addEventListener("touchstart", (e) => {
				if (rd.scale > 1 && e.touches.length === 1) {
					isDragging = true;
					lastX = e.touches[0].clientX;
					lastY = e.touches[0].clientY;
				}
			});

			page.addEventListener("touchmove", (e) => {
				if (isDragging && e.touches.length === 1) {
					e.preventDefault(); // stop native scrolling
					const dx = e.touches[0].clientX - lastX;
					const dy = e.touches[0].clientY - lastY;

					offsetX += dx;
					offsetY += dy;

					lastX = e.touches[0].clientX;
					lastY = e.touches[0].clientY;

					updateTransform();
				}
			});

			page.addEventListener("touchend", (e) => {
				if (e.touches.length === 0) {
					isDragging = false;
				}
			});

			function updateTransform() {
				// clamp offsets so you can’t drag past edges
				const maxX = (rd.scale - 1) * page.clientWidth / 2;
				const maxY = (rd.scale - 1) * page.clientHeight / 2;

				offsetX = Math.min(maxX, Math.max(-maxX, offsetX));
				offsetY = Math.min(maxY, Math.max(-maxY, offsetY));

				pageTarget.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${rd.scale})`;
			}

		}
		function createPinchResponse(page, pageTarget) {

			page.addEventListener("touchstart", e => {
				if (e.touches.length === 2) {
					rd.touchLock = false;

					rd.startDist = getDistance(e.touches);
					const mid = getMidpoint(e.touches);

					// convert screen coords into element coords
					const rect = page.getBoundingClientRect();
					rd.originX = ((mid.x - rect.left) / rect.width) * 100;
					rd.originY = ((mid.y - rect.top) / rect.height) * 100;

					pageTarget.style.transformOrigin = `${rd.originX}% ${rd.originY}%`;
				}
			}, { passive: true });

			page.addEventListener("touchmove", e => {
				rd.touchLock = false;
				if (e.touches.length === 2) {
					const newDist = getDistance(e.touches);
					const factor = newDist / rd.startDist;
					const newScale = Math.min(Math.max(1, rd.scale * factor), 4);
					pageTarget.style.transform = `scale(${newScale})`;
				}
			}, { passive: true });

			page.addEventListener("touchend", e => {
				rd.touchLock = false;
				if (e.touches.length < 2) {
					const matrix = new WebKitCSSMatrix(getComputedStyle(pageTarget).transform);
					rd.scale = matrix.a;
				}
			});
		}

		createPinchResponse(touchPanel, readerContainer);
		createPinchResponse(webtoonContainer, readerContainer);

		createPanResponse(touchPanel, readerContainer);
		createPanResponse(webtoonContainer, readerContainer);

		//MB Manage Electron titlebar

		function enableDragbar(enabled) {
			if (!enabled) {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '0px');
				document.getElementById('dragbar').style.display = 'none';
			} else {
				document.documentElement.style.setProperty('--mb-drag-bar-height', '22px');
				document.getElementById('dragbar').style.display = '';
			}
		}


		if (isElectron) {
			dragbarMinBtn.addEventListener('click', () => {
				window.electronAPI.minimize();
			});

			dragbarMaxBtn.addEventListener('click', () => {
				window.electronAPI.maximize();
			});

			dragbarCloseBtn.addEventListener('click', () => {
				window.electronAPI.close();
			});

			window.electronAPI.onFullscreenChange((isFullscreen) => {
				enableDragbar(!isFullscreen);
			});

			window.electronAPI.onMaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-maximize');
				dragbarMaxBtn.classList.add('fa-window-restore');
			});

			window.electronAPI.onUnmaximize(() => {
				dragbarMaxBtn.classList.remove('fa-window-restore');
				dragbarMaxBtn.classList.add('fa-window-maximize');
			});

			window.electronAPI.getAppVersion().then(version => {
				dragbarAppTitle.textContent = 'MangaBox v' + version;
			});
		}

		// Hide dragbar in PWA mode
		(function () {
			enableDragbar(isElectron);
		})();

		//MB Offline Events Response

		function obUpdateProgressResponse(bookId, completed, total) {
			const percent = Math.round((completed / total) * 100);

			obSetBookProgress(bookId, percent);
			obSetSpinner(true);

			let tempDiv = document.getElementById(bookId);
			let tempDivChild = tempDiv.querySelector('.book-downloader');
			tempDivChild.style.bottom = percent + '%';
			tempDivChild.innerText = percent + '%';

			let tempDivChild2 = tempDiv.querySelector('.download-book');
			tempDivChild2.innerHTML = obRedrawDownloadButton(bookId);
		}

		function obDownloaDcompleteResponse(bookId, completed, total) {
			let tempDiv = document.getElementById(bookId);

			let tempDivChild = tempDiv.querySelector('.book-downloader');
			tempDivChild.innerText = '';
			tempDivChild.classList.add('done');

			obSetBookCompleted(bookId);
			obSetSpinner(false);

			let tempDivChild2 = tempDiv.querySelector('.download-book');
			tempDivChild2.innerHTML = obRedrawDownloadButton(bookId);
		}

		//TODO Is it possible to generate download-progress events in electron too
		//TODO instead of using the other layer for functions?

		if (isCapacitor || isElectron) {
			window.addEventListener('download-progress', (event) => {
				const { bookId, completed, total } = event.detail;
				obUpdateProgressResponse(bookId, completed, total);
			});

			window.addEventListener('download-complete', (event) => {
				const { bookId, completed, total } = event.detail;
				obDownloaDcompleteResponse(bookId, completed, total)
			});
		}


		//MB General Functions 

		function addItem(itemkind, properties) {
			const { style, ...rest } = properties;
			const element = Object.assign(document.createElement(itemkind), rest);
			if (style) Object.assign(element.style, style);
			return element;
		}

		function getScreenAR() {
			return (window.innerWidth / window.innerHeight);
		}

		function toggleFullscreen() {
			if (!document.fullscreenElement) {
				document.documentElement.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		}

		document.addEventListener('fullscreenchange', updateFullscreenLabel);

		function updateFullscreenLabel() {
			fullscreenLabel.classList.remove('fa-expand', 'fa-compress');
			if (document.fullscreenElement) {
				fullscreenLabel.classList.add('fa-compress');
			} else {
				fullscreenLabel.classList.add('fa-expand');
			}
		}

		//MB Main Variable Setup 

		// Main MangaBox data structure, for variables that are common to the whole app
		let mb = {

			libMenuVisible: null,
			swatchMenuVisible: false,

			baseUrl: localStorage.getItem('mbBaseUrl'),
			authToken: false,

			basePath: '', //'/mangabox/'
			darkTheme: false,

			// Scaling of selected item control
			currentlyScaled: null,

			// Current book references for book details
			currentBook: null,
			seriesData: null,
			prevBook: null,
			nextBook: null,

			// Screen aspect ratio functions
			screenAR: getScreenAR(),
			readerMaxRatio: 1,
			readerHorizontal: true,
			resizeTimeout: null,

			// Filter table placeholders
			filterTable: null,
			filterButtons: null,
			filterSizer: null,

			libraryMenuButtons: {},

			libSizer: {}, // Used to calculate libraries button size
			dashboardBin: '',
			/*
				When an item from a bin is opened, the mb.dashboardBin is set, so when the dashboard is reloaded
				it reads this variable, if it is not "" the focus is shifted to the bin, and the variable is cleared.
				In this way subsequent clicks on dashboard button will load the top position.
				This variable is cleared whenever a new "Navigate To" is called that is not to dashboard
			*/

			// Theme management variables
			themeControl: [
				{
					label: 'Light theme',
					icon: 'fa-sun',
					isDark: 0
				}, {
					label: 'Dark theme',
					icon: 'fa-moon',
					isDark: 1
				}, {
					label: 'System theme',
					icon: 'fa-wand-magic-sparkles',
					isDark: 2
				}
			],

			readerThemeControl: [
				{
					label: 'Classic theme',
					icon: 'fa-palette',
					style: 'classic'
				}, {
					label: 'Dark accent',
					icon: 'fa-moon',
					style: 'dark-accent'
				}, {
					label: 'Light accent',
					icon: 'fa-sun',
					style: 'light-accent'
				}, {
					label: 'Transparent',
					icon: 'fa-square',
					style: 'transparent'
				}, {
					label: 'White',
					icon: 'fa-w',
					style: 'white'
				}, {
					label: 'Black',
					icon: 'fa-b',
					style: 'black'
				}
			],

			swatchesHi: getComputedStyle(document.documentElement)
				.getPropertyValue('--mb-swatches-hi')
				.match(/hsl\([^)]*\)/g)
				.map(swatch => swatch.match(/(\d+%?)/g)),

			swatchesLo: getComputedStyle(document.documentElement)
				.getPropertyValue('--mb-swatches-lo')
				.match(/hsl\([^)]*\)/g)
				.map(swatch => swatch.match(/(\d+%?)/g)),

			// Media Cache
			mediaCacheRAM: new Map(), 	//Media cache table structure
			cacheLimitRAM: 250,			//Limit of items in media cache

			prefersDarkMode: window.matchMedia('(prefers-color-scheme: dark)'),

			clickingTile: null,
			pointerItem: null,

			webtoonScale: 100,

			offlineBooks: JSON.parse(localStorage.getItem('mbOfflineBooks') ?? '{}')

		}

		//TODO: make this a function that repsonds to theme changes and create/colorizes the blocks? and maybe use it at bootsequence
		const colorValues = getComputedStyle(document.documentElement)
			.getPropertyValue('--mb-swatches-hi')
			.match(/hsl\([^)]*\)/g);

		colorValues.forEach((value, index) => {
			const appleColor = [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1];
			const colorSwatch = addItem('span', {
				className: 'color-swatch press-flat-button', //TODO tornare ai vecchi modi?
				innerHTML: appleColor[index] == 1 ? '<i class="fa-brands fa-apple"></i>' : '',
				style: {
					backgroundColor: value,
				},
			});
			addPressEvents(colorSwatch, scaleDownShallow, scaleUp);
			colorSwatch.addEventListener('click', (event) => {
				event.stopPropagation();
				mb.accentColor = index;
				applyAccent();
			});
			colorSwatchBar.append(colorSwatch);
		});

		function buildRequest(authToken, method, body) {
			const requestTable = {
				method: method,
				...(!isElectron && { credentials: 'include' }),
				headers: {
					'Content-Type': 'application/json',
					'X-Requested-With': 'XMLHttpRequest',
					'skip_zrok_interstitial': '1',
					...(isElectron && { 'X-Auth-Token': authToken })
				},
				...(body && { body }),
			}
			return requestTable
		}

		function cacheKeyFromUrl(url) {
			return 'cache_' + url.replace(/[^a-z0-9]/gi, '_');
		}

		async function onlineCheck() {
			try {
				const ping = await fetch(`${mb.baseUrl}/api/v1/client-settings/global/list`, { method: 'HEAD', cache: 'no-store' });
				if (ping.ok) {
					setNetworkStatus('online');
				}
			} catch {
				// still offline, ignore
			}
		}


		//MB API Call Function 

		async function callAPI(cacheKey, API_url, method = 'GET', body = null, returnval = true) {
			console.log(cacheKey + " " + API_url)
			const db = await openIndexedDB();

			if (offlineSession) {
				await onlineCheck() //TODO forse qui await?
			};

			if (offlineSession) {
				console.log(`Offline mode: using cache for ${API_url}`);
				if (cacheKey != null) {
					const cached = await getCachedData(db, cacheKey);
					if (cached) return cached;
				}
				console.warn(`No cached data for ${API_url} while offline`);
				return null; // or throw if needed
			}

			if (!offlineSession) {
				await obRefreshReadStatus();
			}

			try {
				const response = await fetch(`${mb.baseUrl}${API_url}`, buildRequest(mb.authToken, method, body));
				if (response.status === 404 || response.status === 204) {
					console.warn(`API ${API_url} ${body} returned ${response.status}`);
					return null;
				}

				if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);

				setNetworkStatus('online');

				if (returnval) {
					const output = await response.json();
					if (cacheKey != null) await cacheData(db, cacheKey, output);
					return output;
				}
			} catch (error) {
				console.error(`Fetch error for ${API_url}:`, error);
				setNetworkStatus('offline');

				return (callAPI(cacheKey, API_url, method, body, returnval));

				throw error;
			}
		}
		/*
		async function fetchWithFallback(url, key) {
		  try {
			 const res = await fetch(url);
			 if (!res.ok) throw new Error('HTTP error');
			 const data = await res.json();
		
			 // cache for offline use
			 localStorage.setItem(key, JSON.stringify(data));
		
			 return data;
		  } catch (err) {
			 console.warn('Fetch failed, using cached data:', err);
			 const cached = localStorage.getItem(key);
			 if (cached) return JSON.parse(cached);
			 throw err; // nothing cached → still fail
		  }
		}
		*/

		async function getUserSettings() {
			let mangaboxFlat = null;
			//try{
			const settings = await callAPI('c_usersettings', '/api/v1/client-settings/user/list', 'GET');

			mangaboxFlat = Object.fromEntries(
				Object.entries(settings)
					.filter(([key]) => key.startsWith('mangabox'))
					.map(([key, obj]) => [key, obj.value])
			);
			//} catch (error) {
			//	console.log("Error in fetch, getting from cache")
			//	mangaboxFlat = JSON.parse(localStorage.getItem('cache_userSettings'));
			//}
			return mangaboxFlat
		}

		async function setUserSettings(key, value) {

			const db = await openIndexedDB();

			const payload = {
				[key]: { value: value },
			};
			userSettings[key] = value;

			// Ensure local cache mirrors the API structure
			const cached = await getCachedData(db, 'c_usersettings') || '{}';

			cached[key] = { value }; // keep the nested shape
			cacheData(db, 'c_usersettings', cached);

			await callAPI(null, '/api/v1/client-settings/user', 'PATCH', JSON.stringify(payload), false);
		}

		async function delUserSettings() {
			await callAPI(null, '/api/v1/client-settings/user', 'DELETE', JSON.stringify([
				'mangabox.ui.accentcolor',
				'mangabox.ui.themeprefs',
				'mangabox.ui.readerthemeprefs',
				'mangabox.ui.libraryfilters',
				'mangabox.ui.libraryicons',
			]), false);
		}

		let userSettings;

		//delUserSettings()

		function applyUserSettings() {
			// Local storage variable setup
			mb.accentColor = Number(userSettings['mangabox.ui.accentcolor'] ?? 0);
			mb.themePrefs = Number(userSettings['mangabox.ui.themeprefs'] ?? 0);
			mb.readerThemePrefs = Number(userSettings['mangabox.ui.readerthemeprefs'] ?? 0);
			mb.libraryFilters = JSON.parse(userSettings['mangabox.ui.libraryfilters'] || '{}');
			mb.libraryIcons = JSON.parse(userSettings['mangabox.ui.libraryicons'] || '{}');
			mb.webtoonScale = Number(userSettings['mangabox.ui.webtoonscale'] ?? 100);
		}


		//MB Theme Management 

		function warmth(hue) {
			const warmth = (Math.cos((hue - 50) * Math.PI / 180) + 1) / 2;
			return warmth;
		}

		function applyAccent() {
			const swatches = mb.darkTheme ? mb.swatchesLo : mb.swatchesHi;

			['--mb-h', '--mb-s', '--mb-l'].forEach((varName, index) => {
				document.documentElement.style.setProperty(varName, swatches[mb.accentColor][index]);
			});
			document.documentElement.style.setProperty('--mb-h-deg', swatches[mb.accentColor][0] + 'deg');

			document.documentElement.style.setProperty('--mb-gradient-1', Number(swatches[mb.accentColor][0]));
			document.documentElement.style.setProperty('--mb-gradient-2', Number(swatches[mb.accentColor][0]) - 10);

			setUserSettings('mangabox.ui.accentcolor', mb.accentColor);
		}

		function swapThemeClass(classSelector, lightClass, darkClass, toDark) {
			Array.from(document.getElementsByClassName(classSelector)).forEach((item) => {
				if (!item.classList.contains('no-theme-icon')) {
					item.classList.remove(toDark ? lightClass : darkClass);
					item.classList.add(toDark ? darkClass : lightClass);
				}
			});
		}

		function updatePWABar(color = null) {
			document.querySelector('meta[name="theme-color"]')
				.setAttribute('content', color ?? (mb.darkTheme ? '#353535' : '#ffffff'));
		}

		function changeTheme() {
			let toDark = false;

			if (mb.themePrefs != 2) {
				toDark = (mb.themePrefs == 1)
			} else {
				toDark = mb.prefersDarkMode.matches ? true : false
			}

			// Set css theme to dark or light
			document.documentElement.setAttribute('data-theme', toDark ? 'dark' : 'light');

			mb.themeControl.forEach(item => {
				themeLabel.classList.remove(item.icon);
			});

			themeLabel.classList.add(mb.themeControl[mb.themePrefs].icon);
			themeLabel.title = mb.themeControl[mb.themePrefs].label;
			// Change fa icons for light or dark theme
			swapThemeClass('fa-file', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-calendar', 'fa-regular', 'fa-solid', toDark);
			swapThemeClass('fa-clock', 'fa-regular', 'fa-solid', toDark);

			// Save theme setting in local storage
			setUserSettings('mangabox.ui.themeprefs', mb.themePrefs);

			mb.darkTheme = toDark;

			//Ttheme based top bar
			updatePWABar();

			applyAccent(); //TODO Maybe this substitutes other accent color changes?
		}

		mb.prefersDarkMode.addEventListener('change', changeTheme);

		// Show/Hide section functions
		function sectionHide(item) {
			if (!item.classList.contains('hidden')) item.classList.add('hidden');
		}
		function sectionShow(item) {
			item.classList.remove('hidden');
		}
		function sectionToggle(item) {
			item.classList.toggle('hidden');
		}
		function isSectionHidden(item) {
			return (item.classList.contains('hidden'));
		}

		// Show/Hide reader pages/spreads
		function spreadHide(index) {
			rd.spreadsArray[index].uiItem.classList.add('hidden-spread');
		}
		function spreadShow(index) {
			rd.spreadsArray[index].uiItem.classList.remove('hidden-spread');
		}
		function isSpreadHidden(index) {
			return (rd.spreadsArray[index].uiItem.classList.contains('hidden-spread'));
		}

		colorChanger.addEventListener('click', () => {

			const unrollTimeout = isSectionHidden(filtersBar) ? 0 : 200

			if ((mb.libMenuVisible != null)) {
				libMenuDown(mb.libraryMenuButtons[mb.libMenuVisible]);
				sectionToggle(filtersBar);
				mb.libMenuVisible = null;
			}

			setTimeout(() => {
				sectionToggle(colorSwatchBar);
			}, unrollTimeout);

			mb.swatchMenuVisible = !mb.swatchMenuVisible

		});

		themeChanger.addEventListener('click', () => {
			mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
			changeTheme();
		});

		if (enableFullscreen) {
			fullscreenChanger.addEventListener('click', () => {
				// mb.themePrefs = (mb.themePrefs + 1) % mb.themeControl.length;
				//changeTheme();
				toggleFullscreen();
			});
		}

		if (enableDownload) {
			offlineLibrary.addEventListener('click', () => {
				navigateTo(`#offlinebooks`);
			});
		}

		logOut.addEventListener('click', async () => {

			try {
				if (mb.baseUrl) {
					await fetch(`${mb.baseUrl}/api/logout`, {
						method: 'POST',
						credentials: 'include',
						headers: {
							'X-Requested-With': 'XMLHttpRequest',
							'skip_zrok_interstitial': '1',
						},
					});
				}
			} catch (error) {
				console.warn('Logout API call failed:', error);
				// We continue cleanup anyway
			}

			if (isElectron) await deleteToken();

			sectionHide(stickyContainer);
			sectionShow(blanker);

			history.pushState(null, '', mb.basePath);

			Object.keys(localStorage).forEach(key => {
				if (key.startsWith("c_")) {
					localStorage.removeItem(key);
				}
			});

			await clearIndexedDB();

			location.reload(true);
		});

		searchInput.addEventListener('keydown', (event) => {
			if (event.key === 'Enter') {
				mb.dashboardBin = '';
				if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
			}
		});

		searchIcon.addEventListener('click', () => {
			if (searchInput.value != '') navigateTo(`#search?search_string=${searchInput.value.toLowerCase()}`);
		})

		//MB Scroll Bars

		function createCustomScrollbar(scrollbox) {
			if (scrollbox.dataset.scrollbarInitialized) return;
			scrollbox.dataset.scrollbarInitialized = 'true';

			// Get direction dynamically
			function isHorizontal() {
				return (scrollbox.dataset.scrollDirection || 'vertical') === 'horizontal';
			}

			const content = scrollbox.querySelector('.scrollbox-content');
			const scrollbar = scrollbox.querySelector('.scrollbox-scrollbar');
			const thumb = scrollbar.querySelector('.scrollbox-thumb');

			let fadeTimeout;

			function showScrollbarTemporarily() {
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
				fadeTimeout = setTimeout(() => {
					scrollbar.classList.remove('visible');
				}, 1000);
			}

			function updateScrollbarThumb() {
				const horizontal = isHorizontal();
				const total = horizontal ? content.scrollWidth : content.scrollHeight;
				const visible = horizontal ? content.clientWidth : content.clientHeight;
				const scroll = horizontal ? content.scrollLeft : content.scrollTop;

				const scrollable = total > visible;

				if (!scrollable) {
					scrollbar.classList.remove('visible');
					thumb.style.display = 'none';
					return;
				}

				thumb.style.display = 'block';

				const margin = 10;

				let thumbSize = Math.max((visible / total) * visible, 30);
				let midBoxRate = (scroll / (total - visible));
				let thumbPos = margin + midBoxRate * (visible - 2 * margin - thumbSize);

				if (horizontal) {
					thumb.style.width = thumbSize + 'px';
					thumb.style.left = thumbPos + 'px';
					thumb.style.height = ''; // reset opposite axis
					thumb.style.top = '';
				} else {
					thumb.style.height = thumbSize + 'px';
					thumb.style.top = thumbPos + 'px';
					thumb.style.width = ''; // reset opposite axis
					thumb.style.left = '';
				}
			}

			content.addEventListener('scroll', () => {
				updateScrollbarThumb();
				showScrollbarTemporarily();
			});

			scrollbox.addEventListener('mouseenter', () => {
				updateScrollbarThumb();
				showScrollbarTemporarily();
			});

			// Drag support
			let isDragging = false;
			let startPos, startThumbPos;

			thumb.addEventListener('mousedown', (e) => {
				isDragging = true;
				const horizontal = isHorizontal();
				startPos = horizontal ? e.clientX : e.clientY;
				startThumbPos = parseInt(thumb.style[horizontal ? 'left' : 'top']) || 0;
				document.body.style.userSelect = 'none';
				scrollbar.classList.add('visible');
				clearTimeout(fadeTimeout);
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				const horizontal = isHorizontal();
				const delta = (horizontal ? e.clientX : e.clientY) - startPos;
				const trackSize = horizontal ? content.clientWidth : content.clientHeight;
				const newThumbPos = Math.min(trackSize - (horizontal ? thumb.offsetWidth : thumb.offsetHeight), Math.max(0, startThumbPos + delta));
				const scrollRatio = newThumbPos / trackSize;
				if (horizontal) {
					content.scrollLeft = scrollRatio * content.scrollWidth;
				} else {
					content.scrollTop = scrollRatio * content.scrollHeight;
				}
			});

			document.addEventListener('mouseup', () => {
				if (isDragging) {
					isDragging = false;
					document.body.style.userSelect = '';
					showScrollbarTemporarily();
				}
			});

			const observer = new MutationObserver(updateScrollbarThumb);
			observer.observe(content, {
				childList: true,
				subtree: true,
				characterData: true,
				attributes: true,
			});

			scrollbox.refreshScrollbar = updateScrollbarThumb;
			updateScrollbarThumb();
		}


		document.querySelectorAll('.scrollbox').forEach(createCustomScrollbar);

		//MB Modal Dialog
		let modalGlobal = [];

		function showModal(image, bg, message, itemsArray) {
			document.querySelectorAll('.modal-button').forEach(el => {
				el.remove();
			});			//modalFunctionsGlobal = functionArray;
			modalWrapper.style.backgroundImage = bg ? '' : 'none';
			modalImage.src = image;
			modalMessage.textContent = message;
			//myModal.style.display = 'flex';

			itemsArray.forEach(item => {
				let uiButton = addItem('button', {
					innerText: item.label,
					className: (item.high ? 'ok' : 'cancel') + ' dialog-button press-button modal-button',
				})
				addPressEvents(uiButton, pressDown, pressUp);
				uiButton.addEventListener('click', item.runfunction);
				modalContent.append(uiButton);
			});

			myModal.classList.add('visible');
		}

		function closeModal() {
			myModal.classList.add('unfade');
			modalImage.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

			setTimeout(() => {
				// Optional: if you still want to hide it completely from screen readers / tab order
				myModal.classList.remove('visible');
				myModal.classList.remove('unfade');
				document.querySelectorAll('.modal-button').forEach(el => {
					el.remove();
				});
			}, 300);
		}

		//MB Search Functions 

		function timeSplit(inTime) {
			let outTime = inTime ?? '1111';
			outTime = outTime.replace('TBD', '9999').split('-');
			if (outTime.length == 1) outTime.push(outTime[0]);
			return outTime
		}

		async function performSearch(searchString) {
			libraryHighlight('searchField', false);

			/*
			if (searchString.includes('d:')) {

				const unFilteredBooks = await callAPI('c_bookslistall',
					`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
					'POST', `{"condition": {"allOf": []}}`
				);
				unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

				const filteredBooks = unFilteredBooks.content.filter(item =>
					obIsBookDownloading(item.id) || obIsBookCompleted(item.id)
				);
				displayBooks(filteredBooks, homeStripBooksResults, 'compact', 'top');

				focusItem('top');
				setTimeout(updateSliderProperties, 10);
				sectionShow(searchStripsContainer);

				return
			}
			*/

			if (searchString.includes('y:')) {

				const unFilteredSeries = await callAPI('c_serieslistall',
					`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
					'POST', `{"condition": {"allOf": []}}`
				);
				const dataArray = unFilteredSeries.content;
				const searchYear = timeSplit(searchString.split('y:')[1].split(' ')[0]);

				let start = 0;
				let stop = 0;
				let filterArray = [];

				for (let i = 0; i < dataArray.length; i++) {
					if (dataArray[i].metadata.alternateTitles.length == 0) {
						filterArray.push(false);
						continue;
					}
					const dateArray = dataArray[i].metadata.alternateTitles.find(item => item.label === 'Time').title.replace('TBD', '5000').split('-');
					start = (Number(dateArray[0]));
					stop = (Number(dateArray[1] ?? dateArray[0]));

					filterArray.push(!((start > Number(searchYear[1])) || (stop < Number(searchYear[0]))));
				}

				const filteredSeries = dataArray.filter((item, index) =>
					filterArray[index]
				);
				displaySeries(filteredSeries, homeStripSeriesResults);

				// Reset book results strip
				//TODO Need to check also books for year?
				displayBooks([], homeStripBooksResults, 'compact', 'top');

				focusItem('top');
				setTimeout(updateSliderProperties, 10);
				sectionShow(searchStripsContainer);

				return
			}

			const unFilteredSeries = await callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredSeries = unFilteredSeries.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.titleSort.toLowerCase().includes(searchString) ||
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title.toLowerCase().includes(searchString)
				)
			);
			displaySeries(filteredSeries, homeStripSeriesResults);
			focusItem('top');

			const unFilteredBooks = await callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`, //TODO sort by relevance with new filtering search?
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				item.metadata.title.toLowerCase().includes(searchString) ||
				item.metadata.summary.toLowerCase().includes(searchString) ||
				item.metadata.tags.some(
					tagIn => tagIn.toLowerCase().includes(searchString)
				)
			);
			displayBooks(filteredBooks, homeStripBooksResults, 'compact', 'top');

			setTimeout(updateSliderProperties, 10);
			sectionShow(searchStripsContainer);
		}

		//MB Library Filtering 

		mb.filterTable = {
			sorting: {
				name: 'sorting',
				selected: 0,
				iconClass: 'fa-solid fa-heading glyph-dark',
				item: null,
				icon: null,
				caption: null,
				title: 'Sort items',
				switches: [
					{
						name: 'a_to_z',
						caption: 'by Title',
						iconClass: 'fa-solid fa-arrow-down-a-z glyph-dark',
						sortFunction: (a, b) => a.mbSeriesTitle.localeCompare(b.mbSeriesTitle)
					}, {
						name: 'z_to_a',
						caption: 'by Title',
						iconClass: 'fa-solid fa-arrow-down-z-a glyph-dark',
						sortFunction: (a, b) => b.mbSeriesTitle.localeCompare(a.mbSeriesTitle)
					}, {
						name: '9_to_1',
						caption: 'by Start',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)) - (Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)))
					}, {
						name: '1_to_9',
						caption: 'by Start',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStart) * 10000 + Number(b.mbSeriesStop)) - (Number(a.mbSeriesStart) * 10000 + Number(a.mbSeriesStop)))
					}, {
						name: '9_to_1',
						caption: 'by End',
						iconClass: 'fa-solid fa-arrow-down-1-9 glyph-dark',
						sortFunction: (a, b) => ((Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)) - (Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)))
					}, {
						name: '1_to_9',
						caption: 'by End',
						iconClass: 'fa-solid fa-arrow-down-9-1 glyph-dark',
						sortFunction: (a, b) => ((Number(b.mbSeriesStop) * 10000 + Number(b.mbSeriesStart)) - (Number(a.mbSeriesStop) * 10000 + Number(a.mbSeriesStart)))
					}, {
						name: '1_to_9',
						caption: 'Books',
						iconClass: 'fa-solid fa-cubes-stacked fa-flip-vertical glyph-dark',
						sortFunction: (a, b) => (Number(b.mbBooksCount) - Number(a.mbBooksCount))
					}, {
						name: '9_to_1',
						caption: 'Books',
						iconClass: 'fa-solid fa-cubes-stacked glyph-dark',
						sortFunction: (a, b) => (Number(a.mbBooksCount) - Number(b.mbBooksCount))
					}
				],
			},
			filter_by_read: {
				name: 'filter_by_read',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by read status',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-circle-half-stroke glyph-dark',
						filterFunction: (a) => true
					}, {
						name: 'unread',
						caption: 'Unread',
						iconClass: 'fa-regular fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == false)
					}, {
						name: 'read',
						caption: 'Read',
						iconClass: 'fa-solid fa-circle glyph-dark',
						filterFunction: (a) => (a.mbSeriesRead == true)
					}
				],
			},
			filter_by_direction: {
				name: 'filter_by_direction',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by reading direction',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-arrow-right-arrow-left glyph-dark',
						filterFunction: (a) => true

					}, {
						name: 'l_to_r',
						caption: 'L to R',
						iconClass: 'fa-solid fa-arrow-right glyph-dark',
						filterFunction: (a) => (a.mbSeriesDirection == 'LEFT_TO_RIGHT')

					}, {
						name: 'r_to_l',
						caption: 'R to L',
						iconClass: 'fa-solid fa-arrow-left glyph-dark',
						filterFunction: (a) => (a.mbSeriesDirection == 'RIGHT_TO_LEFT')
					}, {
						name: 'webtoon',
						caption: 'WToon',
						iconClass: 'fa-solid fa-arrow-down glyph-dark',
						filterFunction: (a) => (a.mbSeriesDirection == 'WEBTOON')
					}
				],
			},
			filter_by_language: {
				name: 'filter_by_language',
				selected: 0,
				iconClass: 'fa-regular fa-circle-check glyph-dark no-theme-icon',
				item: null,
				icon: null,
				caption: null,
				title: 'Filter by language',
				switches: [
					{
						name: 'all',
						caption: 'All',
						iconClass: 'fa-solid fa-earth-europe glyph-dark',
						filterFunction: (a) => true
					}
				],
			},
		};

		async function buildLanguageList() {
			const languageList = await callAPI('c_languages', `/api/v1/languages`);
			languageList.forEach(item => {
				mb.filterTable.filter_by_language.switches.push({
					name: item,
					caption: item.toUpperCase(),
					iconClass: 'fa-solid fa-square glyph-dark glyph-flag-button',
					iconStyle: `background-image:url('flags/${item}.svg')`,
					filterFunction: (a) => a.mbSeriesLanguage == item
				})
			});
		};

		mb.filterButtons = [
			mb.filterTable.sorting,
			mb.filterTable.filter_by_read,
			mb.filterTable.filter_by_direction,
			mb.filterTable.filter_by_language
		];

		function saveLibraryFilters() {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');
			let filterOut = {};
			mb.filterButtons.forEach(button => {
				filterOut[button.name] = button.selected;
			});
			mb.libraryFilters[libraryId] = filterOut;
			setUserSettings('mangabox.ui.libraryfilters', JSON.stringify(mb.libraryFilters));
		}

		function fetchLibraryFilters(libraryId) {
			filterValues = mb.libraryFilters[libraryId];
			if (filterValues) {
				mb.filterButtons.forEach(button => {
					mb.filterTable[button.name].selected = filterValues[button.name];
				});
				applyLibraryFilters()
			}
		}

		async function applyLibraryFilters() {
			const { path, params } = getHashAndParams();
			const libraryId = params.get('library_id');

			const divs = Array.from(seriesGrid.children);
			divs.forEach(div => {
				div.infilter = true;
			});

			const isFiltered = Object.values(mb.filterButtons).reduce((sum, item) => sum + (item.selected || 0), 0);

			mb.libraryMenuButtons[libraryId].classList.remove('filtered');
			if (isFiltered != 0) mb.libraryMenuButtons[libraryId].classList.add('filtered');

			mb.filterButtons.forEach(button => {
				button.icon.innerHTML = `<span style="${button.switches[button.selected].iconStyle}" class="${button.switches[button.selected].iconClass}${button.selected != 0 ? ' mb-accent' : ''}"></span>`;
				button.caption.innerHTML = `${button.switches[button.selected].caption}`;

				if (button.switches[button.selected].sortFunction) {
					divs.sort((a, b) => {
						return button.switches[button.selected].sortFunction(a, b);
					});
					divs.forEach((item, index) => {
						item.style.order = index;
					});
				} else {
					divs.forEach((div) => {
						div.infilter = div.infilter && button.switches[button.selected].filterFunction(div);
					});
				}
			});
			divs.forEach((div) => {
				div.style.display = div.infilter ? '' : 'none';
			});
		}

		// Build filter buttons items

		mb.filterButtons.forEach(button => {
			button.item = addItem('li', {
				className: `filter-item press-button`,
				title: button.title,
			});
			button.icon = addItem('div', {
				className: `smallbutton-wrapper`,
				innerHTML: `<span style="${button.switches[0].iconStyle}" class="${button.switches[0].iconClass}"></span>`
			});
			button.caption = addItem('div', {
				className: `library-name`,
				innerHTML: `${button.switches[0].caption}`
			});
			button.item.append(
				button.icon,
				button.caption
			);
			extraButtons.append(button.item);
			button.item.addEventListener('click', async () => {
				button.selected = ((button.selected + 1) % button.switches.length);
				await executeFade(1);
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			})
		});

		extraButtons.append(addItem('li', {
			title: 'Reset filters and sorting',
			className: `filter-item press-button`,
			innerHTML: `<div class="smallbutton-wrapper">
								<span class="fa-solid fa-arrows-rotate fa-flip-horizontal glyph-dark"></span>
							</div>`,
			onclick: async () => {
				await executeFade(1);
				mb.filterButtons.forEach(button => {
					button.selected = 0;
				});
				applyLibraryFilters();
				await executeFade(0);
				saveLibraryFilters();
			}
		}));

		function isReaderHorizontal(screenAR) {
			return (screenAR / mb.readerMaxRatio > rd.orientationThresholdRatio);
		}

		function updateReaderOrientation() {
			let newScreenAR = getScreenAR();

			if (isSectionHidden(readerContainer)) {
				mb.screenAR = newScreenAR;
				mb.readerHorizontal = isReaderHorizontal(newScreenAR);
			} else {
				let newReaderHorizontal = isReaderHorizontal(newScreenAR);
				if (newReaderHorizontal != mb.readerHorizontal) {
					mb.screenAR = newScreenAR;
					mb.readerHorizontal = newReaderHorizontal;
					spreadSetFocusSmooth(getSpreadFocus(rd.currentSpreadIndex));
				}
			}
		}

		// Set the slider max value and grpahics properties based on the scroll width
		function updateSliderProperties() {
			if (isSectionHidden(homeStripsContainer)) return;

			Object.entries(dashboardElements).forEach(([name, item]) => {

				item.scrollInput.max = item.homeStrip.scrollWidth - item.homeStrip.clientWidth;
				const isOverflowing = item.homeStrip.scrollWidth > item.homeStrip.clientWidth;

				item.scrollInput.style.display = isOverflowing ? 'block' : 'none';

				const visibleRatio = item.homeStrip.clientWidth / item.homeStrip.scrollWidth;
				const sliderThumbWidth = (100 * visibleRatio);

				item.scrollInput.style.setProperty('--thumb-width', `${sliderThumbWidth}%`);
			});
		};

		function stepPageChange(increment) {
			const { path, params } = getHashAndParams();
			navigateTo('#dashboard?all=' + params.get('all') + '&page=' + (parseInt(params.get('page')) + increment));
		}

		addClickPointerEvents(stripPrevPage, () => stepPageChange(-1));
		addClickPointerEvents(stripNextPage, () => stepPageChange(1));

		addPressEvents(stripPrevPage, scaleDown, scaleUp);
		addPressEvents(stripNextPage, scaleDown, scaleUp);

		function updateStickyMenu() {
			const containerWidth = mainUI.getBoundingClientRect().width;

			if (containerWidth - mb.libSizer.rightmin - mb.libSizer.large >= 60) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');

			} else if (containerWidth - mb.libSizer.rightmin - mb.libSizer.medium >= 60) {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-medium');
			} else {
				document.body.classList.remove('sticky-medium');
				document.body.classList.remove('sticky-hybrid');
				document.body.classList.remove('sticky-small');
				document.body.classList.add('sticky-small');

				if (containerWidth - mb.libSizer.large >= 9) {
					document.body.classList.add('sticky-hybrid');
				}
			};

			if (containerWidth - mb.filterSizer >= 0) {
				extraButtons.classList.remove('filter-small')
			} else {
				extraButtons.classList.add('filter-small')
			}

		}

		window.addEventListener('resize', () => {
			clearTimeout(mb.resizeTimeout);
			mb.resizeTimeout = setTimeout(() => {
				updateStickyMenu();
				updateSliderProperties();
				updateReaderOrientation();
			}, 250);
		});

		function fixZoomOnPWA() {
			let metaViewport = document.querySelector('meta[name="viewport"]');
			if (!metaViewport) return;

			// Disable zoom temporarily
			metaViewport.content = `width=device-width, ${isSharpCornerIphone ? '' : 'viewport-fit=cover, '}initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no`;

			// Wait for two animation frames to ensure the change takes effect
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					// Now restore zoom capability
					metaViewport.content = `width=device-width, ${isSharpCornerIphone ? '' : 'viewport-fit=cover, '}initial-scale=1.0, user-scalable=no`;
				});
			});
		}

		fixZoomOnPWA()

		window.addEventListener('orientationchange', () => {
			if (isCapacitor && (capacitorPlatform == 'android')) {
				setTimeout(() => {
					if (isOrientationLandscape()) {
						Capacitor.Plugins.StatusBar.hide();
					} else {
						Capacitor.Plugins.StatusBar.show();
					}
				}, 100)
			}
			fixZoomOnPWA();
		});
		document.addEventListener('visibilitychange', fixZoomOnPWA);
		window.addEventListener('pageshow', (event) => {
			if (event.persisted) fixZoomOnPWA();
		});
		// Fade in and Fade out routines
		function wait(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		async function executeFade(val) {
			blanker.style.opacity = val;
			await wait(100);
		}

		//MB Offline Download Functions
		function arrayBufferToBase64(buffer) {
			let binary = '';
			const bytes = new Uint8Array(buffer);
			const chunkSize = 0x8000; // 32 KB chunks
			for (let i = 0; i < bytes.length; i += chunkSize) {
				const chunk = bytes.subarray(i, i + chunkSize);
				binary += String.fromCharCode.apply(null, chunk);
			}
			return btoa(binary);
		}

		async function capacitorGetOfflineBookData(bookId) {
			const baseFolder = `offline-books/${bookId}`;
			try {
				console.log(`📖 Reading offline book data for ${bookId}`);
				// Read and parse each metadata file
				const bookFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-book.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const pagesFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-pages.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const seriesFile = await Capacitor.Plugins.Filesystem.readFile({
					path: `${baseFolder}/metadata-series.json`,
					directory: filesFolder,
					encoding: 'utf8'
				});

				const bookMetadata = JSON.parse(bookFile.data);
				const pagesMetadata = JSON.parse(pagesFile.data);
				const seriesMetadata = JSON.parse(seriesFile.data);


				// Convert base folder to a WebView-friendly URL
				const uriResult = await Capacitor.Plugins.Filesystem.getUri({
					path: baseFolder,
					directory: filesFolder
				});
				const baseUrl = Capacitor.convertFileSrc(uriResult.uri);
				const bookPath = baseUrl;

				debugPrint(`✅ Successfully loaded offline book data for ${bookId}`)
				console.log(`✅ Successfully loaded offline book data for ${bookId}`);
				return { bookMetadata, pagesMetadata, seriesMetadata, bookPath };

			} catch (err) {
				debugPrint('❌ Failed to read offline book data:', err);
				console.error('❌ Failed to read offline book data:', err);
				throw err;
			}
		}

		async function capacitorDeleteBookData(bookId) {
			try {
				const baseFolder = `offline-books/${bookId}`;

				debugPrint(`🗑️ Deleting offline book data for ${bookId}...`);
				console.log(`🗑️ Deleting offline book data for ${bookId}...`);

				await Capacitor.Plugins.Filesystem.rmdir({
					path: baseFolder,
					directory: filesFolder,
					recursive: true
				});

				debugPrint(`✅ Deleted offline book ${bookId} successfully.`);
				console.log(`✅ Deleted offline book ${bookId} successfully.`);
				return { success: true };
			} catch (err) {
				debugPrint(`❌ Failed to delete offline book ${bookId}:`, err);
				console.error(`❌ Failed to delete offline book ${bookId}:`, err);
				return { success: false, message: err.message };
			}
		}


		async function capacitorDownloadBook({ bookId, bookTitle, baseUrl, requestData }) {
			const mimeToExt = {
				'image/jpeg': '.jpg',
				'image/png': '.png',
				'image/webp': '.webp',
				'image/gif': '.gif',
			};

			const baseDir = 'offline-books';
			const bookFolder = `${baseDir}/${bookId}`;
			const pagesFolder = `${bookFolder}/pages`;
			const thumbsFolder = `${bookFolder}/thumbs`;

			// Helper to make directories recursively
			async function ensureDir(path) {
				try {
					await Capacitor.Plugins.Filesystem.mkdir({
						path,
						directory: filesFolder,
						recursive: true
					});
				} catch (err) {
					debugPrint("Error creating " + path);
					//if (!String(err.message).includes('exists')) throw err;
				}
			}


			await ensureDir(baseDir);
			await ensureDir(bookFolder);
			await ensureDir(pagesFolder);
			await ensureDir(thumbsFolder);

			let completed = 0;

			try {
				debugPrint(`🌐 Downloading metadata for ${bookId}`);

				debugPrint("Get Book Data")
				// Book metadata
				let res = await fetch(`${baseUrl}/api/v1/books/${bookId}`, requestData);
				if (!res.ok) debugPrint(res.status)
				if (!res.ok) throw new Error(`Book metadata failed: ${res.status}`);
				const bookMeta = await res.json();
				debugPrint("bookMeta");
				debugPrint(bookMeta);
				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-book.json`,
					data: JSON.stringify(bookMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});


				debugPrint("Get Series Data")
				// Series metadata
				res = await fetch(`${baseUrl}/api/v1/series/${bookMeta.seriesId}`, requestData);
				if (!res.ok) throw new Error(`Series metadata failed: ${res.status}`);
				const seriesMeta = await res.json();
				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-series.json`,
					data: JSON.stringify(seriesMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});

				debugPrint("Get Pages Data")
				// Pages metadata
				res = await fetch(`${baseUrl}/api/v1/books/${bookId}/pages`, requestData);
				if (!res.ok) throw new Error(`Pages metadata failed: ${res.status}`);
				const pagesMeta = await res.json();
				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/metadata-pages.json`,
					data: JSON.stringify(pagesMeta, null, 2),
					directory: filesFolder,
					encoding: 'utf8'
				});

				// Book thumbnail
				const thumbUrl = `${baseUrl}/api/v1/books/${bookId}/thumbnail`;
				res = await fetch(thumbUrl, requestData);
				if (!res.ok) throw new Error(`Failed to fetch thumbnail: ${res.status}`);

				const thumbBuffer = await res.arrayBuffer();
				const base64Thumb = arrayBufferToBase64(thumbBuffer);

				await Capacitor.Plugins.Filesystem.writeFile({
					path: `${bookFolder}/thumbnail.jpg`,
					data: base64Thumb,
					directory: filesFolder
				});

				// Download all pages
				for (const page of pagesMeta) {
					const pageFile = `${pagesFolder}/${page.number}${mimeToExt[page.mediaType]}`;
					const thumbFile = `${thumbsFolder}/t_${page.number}.jpg`;

					let pageExists = false;
					try {
						await Capacitor.Plugins.Filesystem.stat({
							path: pageFile,
							directory: filesFolder,
						});
						pageExists = true;
					} catch { }

					if (!pageExists) {
						const pageUrl = `${baseUrl}/api/v1/books/${bookId}/pages/${page.number}`;
						const pageRes = await fetch(pageUrl, requestData);
						if (!pageRes.ok) throw new Error(`Page ${page.number} failed: ${pageRes.status}`);
						const pageBuffer = await pageRes.arrayBuffer();
						await Capacitor.Plugins.Filesystem.writeFile({
							path: pageFile,
							data: arrayBufferToBase64(pageBuffer),
							directory: filesFolder
						});
					} else {
						console.log(`✅ Page ${page.number} already exists, skipping.`);
					}

					let thumbExists = false;
					try {
						await Capacitor.Plugins.Filesystem.stat({
							path: thumbFile,
							directory: filesFolder,
						});
						thumbExists = true;
					} catch { }

					if (!thumbExists) {
						const thumbPageUrl = `${baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`;
						const thumbRes = await fetch(thumbPageUrl, requestData);
						if (!thumbRes.ok) throw new Error(`Thumb ${page.number} failed: ${thumbRes.status}`);
						const thumbPageBuffer = await thumbRes.arrayBuffer();
						await Capacitor.Plugins.Filesystem.writeFile({
							path: thumbFile,
							data: arrayBufferToBase64(thumbPageBuffer),
							directory: filesFolder
						});
					} else {
						console.log(`✅ Thumb ${page.number} already exists, skipping.`);
					}
					completed++;
					// You can dispatch a custom event to your UI
					window.dispatchEvent(new CustomEvent('download-progress', {
						detail: { bookId, completed, total: bookMeta.media.pagesCount }
					}));
				}

				debugPrint(`📕 Downloaded book "${bookTitle}" (${bookId})`);
				window.dispatchEvent(new CustomEvent('download-complete', {
					detail: { bookId, completed, total: bookMeta.media.pagesCount }
				}));

				return { ok: true, path: bookFolder };
			} catch (err) {
				debugPrint('❌ Error in safeWriteFile:');
				debugPrint(err);
				console.error('❌ Download failed:', err);
				return { ok: false, error: err.message };
			}
		}

		function obSaveTable() {
			localStorage.setItem('mbOfflineBooks', JSON.stringify(mb.offlineBooks));
		}

		function obSetSpinner(status) {
			let oldStatus = downloadSpinner.classList.contains('spin');
			if (oldStatus == status) return;
			downloadSpinner.classList.remove('spin');
			if (status) downloadSpinner.classList.add('spin')
		}

		function obAddBookToTable(book) {
			mb.offlineBooks[book.id] = {
				status: 'downloading',
				percent: 0,

				updated: false,
				page: book.readProgress.page,
				pages: book.media.pagesCount,
			};
			obSaveTable();
		}

		function obRemoveBookFromTable(bookId) {
			delete mb.offlineBooks[bookId];
			obSaveTable();
		}

		function obSetBookCompleted(bookId) {
			mb.offlineBooks[bookId].status = 'completed';
			mb.offlineBooks[bookId].percent = 100;
			obSaveTable();
		}

		function obSetBookProgress(bookId, progress) {
			mb.offlineBooks[bookId].percent = progress;
			obSaveTable();
		}

		function obRedrawDownloadButton(bookId) {
			if (obIsBookCompleted(bookId)) {
				return ('<span class="fa-regular fa-trash-can"></span>')
			} else if (obIsBookDownloading(bookId)) {
				return ('<span class="fa-solid fa-xmark"></span>')
			}
			else {
				return ('<span class="fa-solid fa-download"></span>')
			}
		}

		function obIsBookCompleted(bookId) {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'completed';
		}

		function obIsBookDownloading(bookId) {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'downloading';
		}

		function obIsAnyBookDownloading() {
			if (!mb.offlineBooks) return false;
			return Object.values(mb.offlineBooks).some(book => book.status === 'downloading');
		}

		function obDownloadsInProgress() {
			if (!mb.offlineBooks) return false;
			const book = mb.offlineBooks[bookId];
			return book && book.status === 'downloading';
		}

		async function obDownloadBook(bookId) {
			let request = buildRequest(mb.authToken, 'GET', null)

			let bookData = {
				bookId: bookId,
				baseUrl: `${mb.baseUrl}`,
				requestData: request
			};

			if (isElectron) await window.offlineAPI.downloadBook(bookData);
			if (isCapacitor) await capacitorDownloadBook(bookData);

		}

		async function obDeleteBookData(bookId) {
			let result = null
			if (isElectron) result = await window.offlineAPI.deleteOfflineBookData(bookId)
			if (isCapacitor) result = await capacitorDeleteBookData(bookId)

			if (result.success) {
				console.log(`Deleted offline book ${bookId} successfully.`);
			} else {
				console.warn(`Failed to delete offline book ${bookId}: ${result.message}`);
			}
			return result;
		}

		async function obLoadOfflineBook(bookId) {
			let bookData = null;
			if (isElectron) bookData = await window.offlineAPI.getOfflineBookData(bookId)
			if (isCapacitor) bookData = await capacitorGetOfflineBookData(bookId)
			return bookData;
		}

		function obRestoreDownloadOnBoot() {
			Object.entries(mb.offlineBooks).forEach(([bookId, item]) => {
				if (item.status == 'downloading') {
					obSetSpinner(true);
					obDownloadBook(bookId);
				}
			});
		}

		async function obRefreshReadStatus() {
			Object.entries(mb.offlineBooks).forEach(([bookId, item]) => {
				if (item.updated) {
					callAPI(null, `/api/v1/books/${bookId}/read-progress`, 'PATCH', JSON.stringify({ page: item.page }), false)
					item.updated = false;
				}
			});
		}

		//MB Media Cache 

		function openIndexedDB() {
			return new Promise((resolve, reject) => {
				const request = indexedDB.open('MangaBoxCache', 1);
				request.onupgradeneeded = (event) => {
					const db = event.target.result;
					if (!db.objectStoreNames.contains('media')) {
						db.createObjectStore('media');
					}
					if (!db.objectStoreNames.contains('data')) {
						db.createObjectStore('data');
					}
				};
				request.onsuccess = () => resolve(request.result);
				request.onerror = () => reject(request.error);
			});
		}

		function cacheMedia(db, url, blob) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('media', 'readwrite');
				tx.objectStore('media').put(blob, url);
				tx.oncomplete = () => resolve();
				tx.onerror = () => reject(tx.error);
			});
		}

		function getCachedMedia(db, url) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('media', 'readonly');
				const req = tx.objectStore('media').get(url);
				req.onsuccess = () => resolve(req.result || null);
				req.onerror = () => reject(req.error);
			});
		}

		function cacheData(db, key, content) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('data', 'readwrite');
				tx.objectStore('data').put(content, key);
				tx.oncomplete = () => resolve();
				tx.onerror = () => reject(tx.error);
			});
		}

		function getCachedData(db, key) {
			return new Promise((resolve, reject) => {
				const tx = db.transaction('data', 'readonly');
				const req = tx.objectStore('data').get(key);
				req.onsuccess = () => resolve(req.result || null);
				req.onerror = () => reject(req.error);
			});
		}

		async function clearIndexedDB() {
			try {
				const db = await openIndexedDB();

				const tx = db.transaction(['media', 'data'], 'readwrite');
				const mediaStore = tx.objectStore('media');
				const dataStore = tx.objectStore('data');

				mediaStore.clear();
				dataStore.clear();

				return new Promise((resolve, reject) => {
					tx.oncomplete = () => {
						console.log('Media and data caches cleared.');
						resolve();
					};
					tx.onerror = () => {
						console.error('Error clearing IndexedDB caches:', tx.error);
						reject(tx.error);
					};
				});
			} catch (err) {
				console.error('Failed to open IndexedDB for clearing:', err);
			}
		}


		async function fetchMedia(url, offlineCache = true) {

			const db = await openIndexedDB();

			// 1️⃣ Check RAM cache first
			if (mb.mediaCacheRAM.has(url)) {
				// Move the accessed item to the end to mark it as recently used
				const value = mb.mediaCacheRAM.get(url);
				mb.mediaCacheRAM.delete(url);
				mb.mediaCacheRAM.set(url, value);
				return value;
			}

			// 2️⃣ Check in IndexedDB only if in offline session and cache it in RAM too
			if (offlineSession) {
				const cachedBlob = await getCachedMedia(db, url);
				if (cachedBlob) {
					const objectURL = URL.createObjectURL(cachedBlob);
					mb.mediaCacheRAM.set(url, objectURL);
					return objectURL;
				}
			}

			try {
				const response = await fetch(url, buildRequest(mb.authToken, 'GET', null));

				if (response.ok) {
					const blob = await response.blob();
					const objectURL = URL.createObjectURL(blob);

					// Add to cache and enforce size limit
					mb.mediaCacheRAM.set(url, objectURL);
					if (mb.mediaCacheRAM.size > mb.cacheLimitRAM) {
						// Remove the oldest entry
						const oldestKey = mb.mediaCacheRAM.keys().next().value;
						URL.revokeObjectURL(mb.mediaCacheRAM.get(oldestKey)); // Revoke object URL
						mb.mediaCacheRAM.delete(oldestKey);
					}

					if (offlineCache) {
						await cacheMedia(db, url, blob);
					}

					return objectURL;
				} else {
					console.error(`Failed to load media from ${url}`, response.status);
					return 'fallback-image.png';
				}
			} catch (error) {
				console.warn(`Offline? Loading cached media for ${url}`);
				const fallbackBlob = await getCachedMedia(db, url);
				if (fallbackBlob) {
					return URL.createObjectURL(fallbackBlob);
				}
				return 'fallback-image.png';

			}
		}


		// Function to clear the cache entirely
		function clearmediaCacheRAM() {
			for (const objectURL of mb.mediaCacheRAM.values()) {
				URL.revokeObjectURL(objectURL);
			}
			mb.mediaCacheRAM.clear();
		}

		async function setReadStatus(seriesId, bookId, read, item, format) {
			console.log("bookid" + bookId + " seriesid" + seriesId);
			if (bookId == null) {
				await callAPI(null, `/api/v1/series/${seriesId}/read-progress`, read ? 'POST' : 'DELETE', null, false);
				const seriesData = await callAPI(`c_seriesdata${seriesId}`, `/api/v1/series/${seriesId}`);
				buildSeriesItem(item, seriesData, null);
				mb.currentlyScaled = item;
			} else {
				await callAPI(null, `/api/v1/books/${bookId}/read-progress`, read ? 'PATCH' : 'DELETE', read ? JSON.stringify({ completed: true }) : null, false);
				mb.currentlyScaled = item;
				const { path, params } = getHashAndParams();
				if (path == 'dashboard' || path == '') {
					mb.currentlyScaled = null;
					mb.clickingTile = null;
					const oldTop = mainContainer.scrollTop;
					await Promise.all(
						Object.entries(dashboardElements).map(async ([name, item]) => {
							const resultsObject = await item.getItems(0, 20);
							//TODO consolidate this with other places?
							item.element.style.display = resultsObject.empty ? 'none' : 'block';
							item.showItems(resultsObject.content, item.homeStrip);
						})
					);
					setTimeout(updateSliderProperties, 100);
					mainContainer.scrollTop = oldTop;
				} else {
					const bookData = await callAPI(null, `/api/v1/books/${bookId}`);
					buildBookItem(item, bookData, format, null);
				}
			}
		}

		async function setSeriesReadStatus(seriesId, read, item) {
			console.log("serSeriesreadStatus for series " + seriesId);
			setReadStatus(seriesId, null, read, item, null);
		}

		async function setBookReadStatus(bookId, read, item, format) {
			console.log("serBookReadStatus for book " + bookId);
			setReadStatus(null, bookId, read, item, format);
		}

		// Function that fetches the libraries list, sort it by name, then calls displayLibraries to show the fetched libraries
		async function fetchLibraries() {
			const gapSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-gap'));
			const libSmallSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-button-size'));
			const libLargeSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-library-large'));
			const filterButtonSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mb-filter-button-size'));
			const searchFieldSize = libLargeSize;
			const margin = 10;

			const libraries = await callAPI('c_libraries', '/api/v1/libraries');
			libraries.sort((a, b) => a.name.localeCompare(b.name));
			await displayLibraries(libraries);

			const rightBlockButtons = librariesRightBlock.childElementCount - 1;
			document.documentElement.style.setProperty('--mb-num-buttons', rightBlockButtons - 1);

			const libNum = libraries.length;
			const mainLibAndMenu = margin + libLargeSize + 40;
			mb.libSizer.large = mainLibAndMenu + libNum * (libLargeSize + gapSize);
			mb.libSizer.medium = mainLibAndMenu + libNum * (libSmallSize + gapSize);
			mb.libSizer.rightmin = margin + rightBlockButtons * (libSmallSize + gapSize) + searchFieldSize + gapSize;

			mb.filterSizer = mb.filterButtons.length * (100 + gapSize) + filterButtonSize + 2 * margin;

			updateStickyMenu();
		}


		// This function is called when a library is selected, it manages the library menu and library naming in the URL
		function libraryHighlight(libraryId, withMenu) {
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('highlighted'));
			document.querySelectorAll('.library-item').forEach(section => section.classList.remove('with-menu'));
			document.getElementById(libraryId).classList.add('highlighted');
			if (withMenu) document.getElementById(libraryId).classList.add('with-menu');
		}

		async function getFilteredSeries(filterTitle, serieId) {
			//TODO Launch this fetch at session load to pre-cache all series
			const unFilteredSeries = await callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			const filteredItems = unFilteredSeries.content.filter(item =>
				item.metadata.alternateTitles.some(
					titleIn => titleIn.title === filterTitle
				)
			);

			displaySeries(filteredItems, seriesGrid);
			focusItem('top');

		}

		//MB Touch And Hover Scaler 

		function addClickPointerEvents(item, execute) {
			item.addEventListener('pointerdown', () => {
				if (getComputedStyle(item).opacity == 0) return;
				mb.pointerItem = item
			});
			item.addEventListener('pointerup', () => {
				event.stopPropagation();

				if (mb.pointerItem != item) {
					mb.pointerItem = null;
					return;
				};

				execute();
			})
		}

		function addTouchScaler(item, execute) {
			item.addEventListener('pointerdown', async (event) => {
				mb.clickingTile = item;
			});

			item.addEventListener('pointerup', async (event) => {
				if (mb.clickingTile != item) {
					mb.clickingTile = null;
					return
				}

				if (event.pointerType === 'touch') {
					// TOUCH DEVICE
					if (mb.currentlyScaled !== item) {
						if (mb.currentlyScaled) {
							mb.currentlyScaled.classList.remove('scaled');
							mb.currentlyScaled.parentElement.classList.remove('top-pop');
						}
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');

						mb.currentlyScaled = item;
						event.preventDefault();
					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');
	
						mb.currentlyScaled = null;
						*/
						execute();
					}
				} else if (event.button == 0) {
					// MOUSE DEVICE
					if (!item.classList.contains('scaled')) {
						item.classList.add('scaled');
						item.parentElement.classList.add('top-pop');
						mb.currentlyScaled = item;
					} else {
						/*
						item.classList.remove('scaled');
						item.parentElement.classList.remove('top-pop');
						mb.currentlyScaled = null;
						*/
						execute();
					}
				}
			});

			item.addEventListener('mouseenter', () => {
				// Added this to unselect pre-scaled book
				if (mb.currentlyScaled != null) {
					mb.currentlyScaled.classList.remove('scaled');

					mb.currentlyScaled.parentElement.classList.remove('top-pop');

					// mb.currentlyScaled = null; //TODO RIMESSO IN 0.2.6 check, This was removed but maybe it was needed?
				}
				item.classList.add('scaled');
				item.parentElement.classList.add('top-pop');
			});

			item.addEventListener('mouseleave', () => {
				item.classList.remove('scaled');
				item.parentElement.classList.remove('top-pop');
				mb.clickingTile = null;
			});
		}

		function preventHyphenBreaks(str) {
			return str.replace(/-/g, '\u2011')
		}

		//MB Series Items Creation
		async function buildSeriesItem(item, serie, target) {
			const LTRvals = {
				RIGHT_TO_LEFT: '',
				LEFT_TO_RIGHT: '<span class="fa-solid fa-clapperboard fa-rotate-270 glyph-dark" style="margin-left:2px;"></span>',
				WEBTOON: '<span class="fa-solid fa-mobile glyph-dark" style="margin-left:2px;"></span>',
				VERTICAL: '<span class="fa-solid fa-mobile glyph-dark" style="margin-left:2px;"></span>',
			}

			item.childNodes[0]?.remove();

			item.title = 'Open series';

			const seriesItem = addItem('div', {
				className: 'series-item'
			});
			const LNG = serie.metadata?.language ? ((serie.metadata.language != 'en') ? `<span style="background-image:url('flags/${serie.metadata.language}.svg')" class="fa-solid fa-square-full glyph-dark glyph-flag"></span>` : '') : '';
			const LTR = serie.metadata?.readingDirection ? LTRvals[serie.metadata.readingDirection] : '';
			const spacer = ((LNG != '') && (LTR != '')) ? '&nbsp;' : '';

			const seriesTitle = addItem('div', {
				innerHTML: `
								<div class="title-row data-row top-row">
									<div style="flex-grow:1" class="series-title">${preventHyphenBreaks(serie.metadata.title)}</div>
									<div class="glyph-dark" style="text-align:right">${LTR}</div>
										${spacer}
									<div class="glyph-div" style="text-align:right">${LNG}</div>
								</div>`
			});

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper'
			});

			const seriesThumbnail = addItem('img', {
				className: 'series-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: `${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail`,
				alt: serie.metadata.title
			});

			addLazyLoading(seriesThumbnail);

			const seriesFader = addItem('div', {
				className: 'series-fader'
			});

			const seriesOverlay = addItem('div', {
				className: 'series-overlay'
			});

			const seriesStatus = addItem('div', {
				className: 'series-status'
			});

			const unreadCount = serie.booksUnreadCount;

			if (unreadCount > 0) {
				const unreadCountBadge = addItem('div', {
					className: 'unread-count',
					innerHTML: `<span>${unreadCount}</span>`
				});
				seriesStatus.append(unreadCountBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark series as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			addClickPointerEvents(markAsRead, async () => {
				console.log(serie.id);
				await setSeriesReadStatus(serie.id, true, item);
			})
			addPressEvents(markAsRead, scaleDown, scaleUp)

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark series as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			addClickPointerEvents(markAsUnread, async () => {
				await setSeriesReadStatus(serie.id, false, item);
			})
			addPressEvents(markAsUnread, scaleDown, scaleUp)

			// Find alternate title with label 'Time'
			const altTitle = getAltTitles(serie);

			// Fetch and display the number of books and alternate title
			const bookCount = serie.booksCount;
			const infoRow = addItem('div', {
				className: 'data-row info-row'
			});

			const timeLabel = addItem('span', {
				innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-calendar glyph-dark'></span>&nbsp;${altTitle.time}`,
				className: 'red search-trigger',
				title: `Filter time: ${altTitle.time}`
			});
			addClickPointerEvents(timeLabel, async () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#search?search_string=y:${altTitle.time}`);
			})

			const booksLabel = addItem('span', {
				innerHTML: `<span class='fa-solid fa-book glyph-dark'></span>&nbsp;${bookCount}`
			});

			const artistRow = addItem('div', {
				className: 'data-row artist-row'
			});

			if (altTitle.story != altTitle.art) {

				const storyLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-pen-to-square glyph-dark'></span>&nbsp;${altTitle.story}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.story}`
				});

				const artLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-palette glyph-dark'></span>&nbsp;${altTitle.art}`,
					className: 'red data-label search-trigger',
					title: `Filter artist: ${altTitle.art}`
				});

				artistRow.append(storyLabel, artLabel);

				addClickPointerEvents(storyLabel, async () => {
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
				});

				addClickPointerEvents(artLabel, async () => {
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.art.toLowerCase()}`);
				});
			} else {
				const artistLabel = addItem('div', {
					innerHTML: `<span class='fa-solid fa-user glyph-dark'></span>&nbsp;${altTitle.story}`,
					title: `Filter artist: ${altTitle.story}`,
					className: 'red data-label search-trigger'
				});
				artistRow.append(artistLabel);
				addClickPointerEvents(artistLabel, async () => {
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#search?search_string=${altTitle.story.toLowerCase()}`);
				});
			}

			item.mbSeriesTitle = serie.metadata.title ?? '';

			item.mbSeriesStart = timeSplit(altTitle.time)[0];
			item.mbSeriesStop = timeSplit(altTitle.time)[1];

			item.mbBooksCount = serie.booksCount;

			item.mbSeriesRead = (unreadCount == 0);
			//TODO This is for filtering purposes, to fix
			item.mbSeriesDirection = (serie.metadata.readingDirection);
			item.mbSeriesLanguage = serie.metadata.language;

			seriesItem.append(
				thumbnailWrapper,
				seriesTitle,
				infoRow,
				artistRow
			);
			thumbnailWrapper.append(
				seriesThumbnail,
				seriesFader,
				seriesOverlay,
				seriesStatus
			);
			seriesOverlay.append(
				markAsRead,
				markAsUnread
			);
			infoRow.append(
				timeLabel,
				booksLabel
			);

			addTouchScaler(seriesItem, () => {
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#series?library_id=${serie.libraryId}&series_id=${serie.id}`)
			});

			item.append(seriesItem);
		}

		// Creates and populates the series grid with the data from the series array.
		async function displaySeries(series, target) {

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			series.forEach(async (serie) => {

				const seriesContainer = addItem('div', {
					className: 'series-container', //XXX was ending with , 'fade-in');
					id: serie.id,
				});

				buildSeriesItem(seriesContainer, serie, target);

				target.append(seriesContainer);
			});

			sectionShow(target); //XXX serve un fade qui???
		}

		// Function that fetches all the series list within a library, sorted by name, then calls displaySeries to show the fetched series
		async function fetchAllSeries(libraryId) {
			let allSeries = [];
			const allSeriesPage = await callAPI(`c_serieslist${libraryId}`,
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"libraryId": {"operator": "is","value": "${libraryId}"}}}`
			);
			allSeries = allSeriesPage?.content || [];
			// now it gets the series sorted by name so no need to elaborate the sorting, but for custom sorting based for example on title time?
			// allSeries.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
			return (allSeries);
		}

		function focusItem(focus) {
			if (focus == 'top') {
				mainContainer.scrollTo({ top: 0 });
			} else if (focus) {
				var item = document.getElementById(focus);
				console.log("item:")
				console.log(item);

				if (item == null) {
					mainContainer.scrollTo({ top: 0 });
					return;
				}

				const yOffset = -150;
				const y = item.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop + yOffset;

				mainContainer.scrollTo({ top: y });

				mb.currentlyScaled = item.firstChild;
				console.log("item2:")
				console.log(item);
				console.log("item firstchild:")
				console.log(item.firstChild);
				if (item.firstChild != null) {
					item.firstChild.classList.add('scaled');
				}
				item.classList.add('top-pop');

			}
		}

		// Compose function that opens a specific library based on it ID
		async function openLibrary(libraryId, seriesId) {
			await libraryHighlight(libraryId, true);		// Triggers and manages the library menu
			const allSeries = await fetchAllSeries(libraryId);		// Updates the series within the library
			await displaySeries(allSeries, seriesGrid);
			fetchLibraryFilters(libraryId);
			focusItem(seriesId || 'top');
			//TODO Move here the logic that enables the library options buttons?
		}

		const menuClassUp = 'fa-caret-up';
		const menuClassDown = 'fa-caret-down'

		function libMenuClear(item) {
			item.classList.remove(menuClassUp);
			item.classList.remove(menuClassDown);
		}

		function libMenuDown(item) {
			libMenuClear(item);
			item.classList.add(menuClassDown);
		}

		function libMenuUp(item) {
			libMenuClear(item);
			item.classList.add(menuClassUp);
		}

		function clearLibrariesMenus() {
			Object.entries(mb.libraryMenuButtons).forEach(([name, item]) => {
				libMenuClear(item);
				libMenuDown(item);
			});
		}

		function pressDown(item) {
			const anim = item.animate(
				{
					transform: 'scale(0.975) translateY(1px)',
					filter: 'brightness(0.98)',
					boxShadow: 'var(--mb-button-press)'
				},
				{ duration: 150, fill: 'forwards', easing: 'ease-out' }
			);
			item._pressAnim = anim; // save reference
			return anim.finished;
		}

		function pressUp(item) {
			const finish = item._pressAnim?.finished || Promise.resolve();
			finish.then(() => {
				item.animate(
					{
						transform: 'scale(1) translateY(0px)',
						filter: 'brightness(1)',
						boxShadow: 'var(--mb-button-unpress)'
					},
					{ duration: 50, fill: 'forwards', easing: 'ease-in' }
				);
			});
		}
		function scaleDownShallow(item) {
			const anim = item.animate({ transform: 'scale(0.95)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleDown(item) {
			const anim = item.animate({ transform: 'scale(0.9)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleDownDeep(item) {
			const anim = item.animate({ transform: 'scale(0.8)' }, { duration: 150, fill: 'forwards', easing: 'ease-out' });
			item._pressAnim = anim; // save reference
			return anim.finished;
		}
		function scaleUp(item) {
			const finish = item._pressAnim?.finished || Promise.resolve();
			finish.then(() => {
				item.animate({ transform: 'scale(1.0)' }, { duration: 50, fill: 'forwards', easing: 'ease-in' }
				);
			});
		}

		function addPressEvents(item, downFunction, upFunction) {
			item.addEventListener('pointerdown', (event) => {
				event.stopPropagation();
				downFunction(item);
			});
			item.addEventListener('pointerup', () => {
				upFunction(item);
			});
			item.addEventListener('pointerleave', () => {
				upFunction(item);
			});
			item.addEventListener('pointercancel', () => {
				upFunction(item);
			});
		};

		function buildLibraryItem(itemId, libraryName, imagePath = null) {
			const isLib = (imagePath == null);

			const listItem = addItem('li', {
				id: itemId,
				className: 'library-item press-button',
				title: libraryName,
			});

			addPressEvents(listItem, pressDown, pressUp);

			const thumbnailWrapper = addItem('div', {
				className: 'button-wrapper',
			})

			const base64Image = mb.libraryIcons[itemId];
			const imageSrc = base64Image || (isLib
				? `library-thumbnails/${libraryName}.svg`
				: imagePath);

			const libraryThumbnail = addItem('img', {
				className: 'library-thumbnail',
				src: imageSrc,
				alt: isLib ? `${libraryName} Cover` : libraryName,
			})

			if (isLib) {
				libraryThumbnail.onerror = () => {
					libraryThumbnail.onerror = null;
					libraryThumbnail.src = `library-letters/${libraryName.charAt(0).toUpperCase()}.png`
				};
			}

			const libraryNameDiv = addItem('div', {
				className: 'library-name',
				textContent: libraryName
			});

			thumbnailWrapper.append(libraryThumbnail);
			listItem.append(thumbnailWrapper, libraryNameDiv);

			if (isLib) {
				mb.libraryMenuButtons[itemId] = addItem('span', {
					className: 'fa-solid ' + menuClassDown + ' is-lib-menu'
				})

				const thumbnailWrapperMenu = addItem('div', {
					className: 'button-wrapper library-menu-button press-flat-button',
				})

				thumbnailWrapperMenu.append(mb.libraryMenuButtons[itemId]);
				listItem.append(thumbnailWrapperMenu);

				addPressEvents(thumbnailWrapperMenu, scaleDownDeep, scaleUp)

				thumbnailWrapperMenu.addEventListener('click', (event) => {
					libMenuClear(mb.libraryMenuButtons[itemId]);

					const unrollTimeout = isSectionHidden(colorSwatchBar) ? 0 : 200

					if (isSectionHidden(filtersBar)) {
						libMenuUp(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = itemId;
						mb.swatchMenuVisible = false;
						sectionHide(colorSwatchBar);
					} else {
						libMenuDown(mb.libraryMenuButtons[itemId]);
						mb.libMenuVisible = null;
					}

					event.stopPropagation();
					event.preventDefault();
					setTimeout(() => {
						sectionToggle(filtersBar);
					}, unrollTimeout);
				});

			}

			return listItem;
		}

		function readFileAsBase64(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(file); // This gives you "data:image/png;base64,..." format
			});
		}

		function addLongPressListener(element, callback, duration = 1200) {
			let pressTimer;
			let wasLongPress = false;

			const start = (e) => {
				if (e.target.classList.contains('is-lib-menu')) return;
				wasLongPress = false;
				pressTimer = setTimeout(() => {
					wasLongPress = true;
					callback(e);
				}, duration);
			};

			const cancel = () => {
				clearTimeout(pressTimer);
			};

			element.addEventListener('mousedown', start);
			element.addEventListener('mouseup', cancel);
			element.addEventListener('mouseleave', cancel);
			element.addEventListener('dragstart', cancel);

			element.addEventListener('touchstart', start);
			element.addEventListener('touchend', cancel);
			element.addEventListener('touchcancel', cancel);

			// Prevent click after long press
			element.addEventListener('click', (e) => {
				if (wasLongPress) {
					e.preventDefault();
					e.stopImmediatePropagation();
					// Optionally log or debug here
				}
			}, true); // Capture phase to stop early
		}

		function cancelUpdate() {
			closeModal();
			bootSequence(offlineSession ? 'offline' : 'online');
		}

		async function applyLibraryImage(libraryId, fileOrBase64) {
			let base64 = null;

			// Case 1: It's a File
			if (fileOrBase64 instanceof File) {
				debugPrint("----Input is a file")
				if (!fileOrBase64.type.startsWith('image/')) {
					debugPrint("----But it's not a valid image file")
					showModal('circle-mark-svg.svg', true, 'Please provide a valid image.',
						[{ label: 'Ok', runfunction: cancelUpdate, high: true }]);
					return;
				}
				base64 = await readFileAsBase64(fileOrBase64);
			}

			// Case 2: It's already a base64 string
			else if (typeof fileOrBase64 === 'string' && fileOrBase64.startsWith('data:image/')) {
				debugPrint("----Input is a string")
				base64 = fileOrBase64;
			}

			// Case 3: Not valid
			else {
				debugPrint("----Input is not valid")
				debugPrint(fileOrBase64);
				showModal('circle-mark-svg.svg', true, 'Please provide a valid image.',
					[{ label: 'Ok', runfunction: cancelUpdate, high: true }]);
				return;
			}

			// Show confirmation modal
			showModal(base64, false, 'Set this image as library thumbnail?',
				[{
					label: 'Ok',
					runfunction: async () => {
						mb.libraryIcons[libraryId] = base64;
						await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons));
						closeModal();
						bootSequence(offlineSession ? 'offline' : 'online');
					},
					high: true,
				}, {
					label: 'Cancel', runfunction: cancelUpdate, high: false
				}
				]);
		}


		async function pickImage(libraryId) {
			debugPrint("PickImage");
			try {
				const image = await Capacitor.Plugins.Camera.getPhoto({
					quality: 90,
					allowEditing: false,
					resultType: 'base64',  // get base64 directly
					source: 'PHOTOS',
				});
				debugPrint(image);
				debugPrint(image.base64String);
				debugPrint("Picked");
				const base64 = `data:image/${image.format};base64,${image.base64String}`;
				applyLibraryImage(libraryId, base64);

			} catch (err) {
				debugPrint("Image picking failed:\n" + err);
			}
		}

		async function pickFile(libraryId) {
			debugPrint("PickFile");
			try {
				const result = await Capacitor.Plugins.FilePicker.pickFiles({
					extensions: ['png', 'jpg', 'jpeg', 'heic'], // common formats on iOS
					multiple: false,
					readData: true,
				});
				if (result.files.length > 0) {
					const file = result.files[0];

					if (file.data) {
						// Pass as base64 string (Case 2 of your function)
						const base64 = `data:${file.mimeType};base64,${file.data}`;
						applyLibraryImage(libraryId, base64);
					} else if (file.path) {
						// As a fallback: fetch from file system and build a File
						const response = await fetch(file.path);
						const blob = await response.blob();
						const pseudoFile = new File([blob], file.name, { type: file.mimeType });
						applyLibraryImage(libraryId, pseudoFile);
					}
				}

			} catch (err) {
				debugPrint("Image picking failed:\n" + err);
			}
		}

		function displayLibraries(libraries) {
			librariesList.innerHTML = '';

			let dashboard = buildLibraryItem('homeButton', 'Dashboard', 'logo/mangabox-logo-new.svg')
			librariesList.append(dashboard);
			homeButton.addEventListener('click', () => {
				navigateTo('#dashboard');
			});

			Array.from(libraries).forEach((library, index) => {
				const listItem = buildLibraryItem(library.id, library.name);

				addLongPressListener(listItem, async () => {

					const libraryId = listItem.id
					if (mb.libraryIcons[libraryId] == null) {
						if (isCapacitor) {
							showModal('circle-info-svg.svg', true, 'Open an image from gallery or files.',
								[{
									label: 'Gallery',
									runfunction: async () => { await pickImage(libraryId); },
									high: true
								}, {
									label: 'Files',
									runfunction: async () => { await pickFile(libraryId); },
									high: true
								}, {
									label: 'Cancel',
									runfunction: closeModal,
									high: false
								}]);

						} else {
							showModal('circle-info-svg.svg', true, 'Drop an image on the library button to change thumbnail.',
								[{ label: 'Ok', runfunction: closeModal, high: true }]
							);
						}
					} else {
						showModal(mb.libraryIcons[libraryId], false, 'Remove custom library thumbnail?', [
							{
								label: 'Ok',
								runfunction: async () => {
									await delete mb.libraryIcons[libraryId];
									await setUserSettings('mangabox.ui.libraryicons', JSON.stringify(mb.libraryIcons))

									closeModal();
									bootSequence(offlineSession ? 'offline' : 'online');
								},
								high: true
							},
							{ label: 'Cancel', runfunction: cancelUpdate, high: false }
						]);

					}
				});

				listItem.addEventListener('dragover', (event) => {
					event.preventDefault(); // This is required to allow drop
					listItem.style.backgroundColor = 'hsl(200, 60%, 70%)';
				});

				listItem.addEventListener('dragleave', () => {
					listItem.style.backgroundColor = ''; // Reset visual feedback
				});

				listItem.addEventListener('drop', async (event) => {
					event.preventDefault();

					const libraryId = listItem.id
					const file = event.dataTransfer.files[0];

					applyLibraryImage(libraryId, file);

				})

				listItem.addEventListener('click', () => {
					const { path, params } = getHashAndParams();
					if ((path == 'series') && (params.get('library_id') == library.id)) {
						navigateTo(`#library?library_id=${library.id}&series_id=${params.get('series_id')}`);
					}
					else {
						navigateTo(`#library?library_id=${library.id}`);
					}
				});

				librariesList.append(listItem);
			});

		}

		function getAltTitles(serie) {

			const labels = ['Time', 'Story', 'Art'];
			const altTitle = labels.reduce((out, label) => {
				const altTitle = serie.metadata.alternateTitles.find(
					(alt) => alt.label === label
				);
				out[label.toLowerCase()] = altTitle ? altTitle.title : 'N/A';
				return out;
			}, {});

			if ((altTitle.time == 'N/A') && (serie.booksMetadata.releaseDate != null)) {
				altTitle.time = serie.booksMetadata.releaseDate.split('-')[0];
			};

			if (altTitle.story == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'writer'
				);
				altTitle.story = bookWriter ? bookWriter.name : 'N/A';
			}
			if (altTitle.art == 'N/A') {
				const bookWriter = serie.booksMetadata.authors.find(
					(alt) => alt.role === 'penciller'
				);
				altTitle.art = bookWriter ? bookWriter.name : 'N/A';
			}
			return altTitle;

		}


		async function displayHeader(serie) {
			const altTitle = getAltTitles(serie);
			const creditString = altTitle.story == altTitle.art
				? `Story and art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>`
				: `Story by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.story.toLowerCase()}');">${altTitle.story}</a>, art by <a class="red search-trigger" href="javascript:navigateTo('#search?search_string=${altTitle.art.toLowerCase()}');">${altTitle.art}</a>`;

			seriesHeader.innerHTML = `
			<div class="header-pic-container">
				<div class="thumbnail-wrapper">
					<img id="seriesHeaderThumbnail" src="${mb.baseUrl}/api/v1/series/${serie.id}/thumbnail" class="header-pic">
				</div>
			</div>
			<div class="header-title">
				<span class="title">
				${serie.metadata.title}
				${serie.metadata?.language ? `<img width="20px" height="20px" style="margin-left:15px; margin-top:2px; vertical-align: top;" src="flags/${serie.metadata.language}.svg">` : ''}
				</span>
				<span class="notes">
					<a class="red search-trigger" href="javascript:navigateTo('#search?search_string=y:${altTitle.time}');">${altTitle.time}</a> (${serie.booksCount} ${serie.booksCount == 1 ? "book" : "books"}) - ${creditString}</span>
			</div>
			<div id="bookScrollBox" class="header-summary scrollbox" data-scroll-direction="vertical">
				<div class="scrollbox-content">${serie.metadata.summary.replace(/\n/g, '<br>')}</div>
				<div class="scrollbox-scrollbar">
					<div class="scrollbox-thumb"></div>
				</div>
			</div>
			`;

			seriesHeaderThumbnail.src = await fetchMedia(seriesHeaderThumbnail.src);
			createCustomScrollbar(bookScrollBox);
			seriesMiniHeader.innerHTML = `
				<span class="mini-title">${serie.metadata.title}</span>
			`
		}

		//MB Book Details Panel 

		function closeBookDetails() {
			sectionHide(bookDetailsContainer);
			//TODO PUT THIS BACK?
			/*
			setTimeout(() => {
				bookDetailsContainer.innerHTML = ''
			}, 300);
			*/
		}

		function jumpBookDetailsPrev() {
			if (mb.prevBook != null) {
				showBookDetails(mb.prevBook);
			}
		}
		function jumpBookDetailsNext() {
			if (mb.nextBook != null) {
				showBookDetails(mb.nextBook);
			}
		}
		function jumpBookLibrary() {
			navigateTo(`#series?library_id=${mb.currentBook.libraryId}&series_id=${mb.currentBook.seriesId}&book_id=${mb.currentBook.id}`)
		}

		async function showBookDetails(book) {
			bookDetailCover.className = "book-thumbnail hidden";
			bookDetailsTitle.style.opacity = 0;
			bookDetailsSummary.style.opacity = 0;

			removeLazyLoading(bookDetailCover);
			sectionShow(bookDetailsContainer);

			bookDetailCover.lazySrc = `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`;
			addLazyLoading(bookDetailCover);

			bookDetailsTitle.innerText = book.metadata.title;
			bookDetailsTitle.style.opacity = 1;

			let summaryArray = book.metadata.summary.split(/\r?\n/);
			bookDetailsSummary.innerHTML = summaryArray.map(element => `<li>${element}</li>`).join('');
			bookDetailsSummary.style.opacity = 1;

			const seriesData = await callAPI(`c_seriesdata${book.seriesId}`, `/api/v1/series/${book.seriesId}`);
			/*
			const seriesBooks = await callAPI(
				`/api/v1/books/list?unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${book.seriesId}"}}}`
			);
			*/

			mb.seriesData = seriesData;
			mb.currentBook = book;
			mb.prevBook = await callAPI(`c_books${book.id}prev`, `/api/v1/books/${book.id}/previous`) || null;
			mb.nextBook = await callAPI(`c_books${book.id}next`, `/api/v1/books/${book.id}/next`) || null;

			/*
						if (book.number > 1) {
							mb.prevBook = seriesBooks.content[book.number - 2];
						}
						if (book.number < seriesData.booksCount) {
							mb.nextBook = seriesBooks.content[book.number];
						}
			*/
		}

		//MB Book Item Creation

		async function buildBookItem(item, book, format, target) {

			// Check local proxy list if book is available and completed offline
			// and tell the system to use this offline copy if we are offline

			const bookIsOffline = obIsBookCompleted(book.id);
			const bookIsDownloading = obIsBookDownloading(book.id);

			const useOfflineCopy = (offlineSession && bookIsOffline);
			let offline = {};

			if (useOfflineCopy) {
				//TODO Alternative way: when read status change, and the book 
				// is offline, update the saved metadata so it will always be in sync
				// but will this sync with the reading offline? No

				// Load saved metadata
				offline = await obLoadOfflineBook(book.id);
				// Apply saved metadata to book
				book = offline.bookMetadata;
				// Pipe read progress into saved metadata
				book.readProgress.page = mb.offlineBooks[book.id].page;
			}

			item.childNodes[0]?.remove();

			item.title = 'Read book';

			const booksItem = addItem('div', {
				className: 'book-item'
			});

			const bookDownloadUI = addItem('div', {
				className: 'book-downloader'
			});

			if (bookIsOffline) {
				bookDownloadUI.classList.add('done');
			}

			if (bookIsDownloading) {
				bookDownloadUI.style.bottom = mb.offlineBooks[book.id].percent + "%";
				bookDownloadUI.innerText = mb.offlineBooks[book.id].percent + "%";
			}

			const mainRow = addItem('div', {
				className: 'data-row top-row'
			});

			if (format == 'longname') {
				mainRow.classList.add('book-row');
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Book ${book.metadata.number}`,
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				mainRow.append(volumeNumberLabel, pagesLabel);
			} else {
				mainRow.classList.add('book-series-row', 'red');
				mainRow.title = `Open series: ${book.seriesTitle}`;
				mainRow.textContent = book.seriesTitle;
				addClickPointerEvents(mainRow, () => {
					if (target?.binName) mb.dashboardBin = target.binName;
					navigateTo(`#series?library_id=${book.libraryId}&series_id=${book.seriesId}&book_id=${book.id}`);
				})
			}

			const secondRow = addItem('div', {
				className: 'data-row',
			});

			if (format == 'longname') {
				secondRow.classList.add('info-row');
				secondRow.textContent = book.metadata.title;
			} else if (format == 'compact') {
				const volumeNumberLabel = addItem('span', {
					innerHTML: `Book ${book.metadata.number}`
				});
				const pagesLabel = addItem('span', {
					innerHTML: `<span class="${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-file glyph-dark"></span>&nbsp;${book.media.pagesCount}`,
				});
				secondRow.append(volumeNumberLabel, pagesLabel);
			} else if (format == 'timeline') {
				const dateString = book.readProgress ?
					new Intl.DateTimeFormat('en-GB', {
						day: '2-digit',
						month: 'short',
						year: '2-digit'
					}).format(new Date(book.readProgress.readDate))
					: '';

				const volumeNumberLabelShort = addItem('span', {
					innerHTML: `Bk.${book.metadata.number}`
				});
				const timeLabel = addItem('span', {
					innerHTML: `<span class='${mb.darkTheme ? 'fa-solid' : 'fa-regular'} fa-clock glyph-dark'></span>&nbsp;${dateString}`
				});

				secondRow.append(volumeNumberLabelShort, timeLabel);
			}

			const thumbnailWrapper = addItem('div', {
				className: 'thumbnail-wrapper',
			});

			if (useOfflineCopy) debugPrint(`${offline.bookPath}/thumbnail.jpg`)

			const bookThumbnail = addItem('img', {
				className: 'book-thumbnail hidden',
				src: 'transparent.png',
				lazySrc: useOfflineCopy ? `${offline.bookPath}/thumbnail.jpg` : `${mb.baseUrl}/api/v1/books/${book.id}/thumbnail`,
				alt: book.metadata.title
			});

			addLazyLoading(bookThumbnail);

			const bookFader = addItem('div', { className: 'book-fader' });
			const bookOverlay = addItem('div', { className: 'book-overlay' });
			const bookStatus = addItem('div', { className: 'book-status' });

			const unread = (book.readProgress == null);

			if (unread) {
				const unreadBookBadge = addItem('div', {
					className: 'unread-book'
				});
				bookStatus.append(unreadBookBadge);
			}

			const markAsRead = addItem('div', {
				className: 'mini-buttons mark-as-read',
				title: 'Mark book as read',
				innerHTML: `<span class="fa-regular fa-circle-check"></span>`
			});
			addClickPointerEvents(markAsRead, () => {
				setBookReadStatus(book.id, true, item, format);
			})

			addPressEvents(markAsRead, scaleDown, scaleUp)

			const markAsUnread = addItem('div', {
				className: 'mini-buttons mark-as-unread',
				title: 'Mark book as unread',
				innerHTML: `<span class="fa-regular fa-circle-xmark"></span>`
			});
			addClickPointerEvents(markAsUnread, () => {
				setBookReadStatus(book.id, false, item, format);
			})
			addPressEvents(markAsUnread, scaleDown, scaleUp)



			//TODO Verificare cosa succede se il titolo di book details è troppo lungo e sposta l'immagine thumb

			//if (book.metadata.summary != '') {
			const bookDetails = addItem('div', {
				className: 'mini-buttons book-details',
				title: 'Book Details',
				innerHTML: `<span class="fa-solid fa-align-justify"></span>`
			});

			addClickPointerEvents(bookDetails, () => {
				showBookDetails(book);
			})
			addPressEvents(bookDetails, scaleDown, scaleUp)
			//	bookOverlay.append(bookDetails);
			//}

			if (book.metadata.summary == '') {
				bookDetails.classList.add('half-bright')
			};

			if (isElectron || isCapacitor || fullDebugMode) {
				const downloadButton = addItem('div', {
					className: 'mini-buttons download-book',
					title: 'Download book',
					innerHTML: obRedrawDownloadButton(book.id),
				});

				addClickPointerEvents(downloadButton, () => {
					//TODO Add here a control if we are on web or not, and call the proper download routine based on electron or capacitor
					//TODO Or even better don't show the button in web mode :O
					if (obIsBookCompleted(book.id)) {
						// Book is finished, you can delete the book!
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '100%';
						obRemoveBookFromTable(book.id);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDeleteBookData(book.id);
					} else if (obIsBookDownloading(book.id)) {
						// Book is downloading, you can cancel the process
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '100%';
						obRemoveBookFromTable(book.id);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDeleteBookData(book.id);
						obSetSpinner(false);
					} else {
						// Download the book!
						bookDownloadUI.classList.remove('done');
						bookDownloadUI.style.bottom = '0%';
						obAddBookToTable(book);
						obSetSpinner(true);
						downloadButton.innerHTML = obRedrawDownloadButton(book.id);
						obDownloadBook(book.id)
					}

				})
				addPressEvents(downloadButton, scaleDown, scaleUp)

				bookOverlay.append(markAsRead, downloadButton, bookDetails, markAsUnread);
			} else {
				bookOverlay.append(markAsRead, bookDetails, markAsUnread);
			}

			const progress = (book.readProgress ? (book.readProgress.completed ? 0 : book.readProgress.page) : 0)
			const progressBar = addItem('div', { className: 'progress-bar' });
			const progressGauge = addItem('div', { className: 'progress-gauge' });

			if (progress == 0) {
				progressBar.classList.add('no-show');
			} else {
				progressGauge.style.width = `${Math.round(100 * progress / book.media.pagesCount)}%`;
			}

			booksItem.append(
				thumbnailWrapper,
				progressBar,
				mainRow,
				secondRow
			);

			thumbnailWrapper.append(
				bookThumbnail,
				bookDownloadUI,
				bookFader,
				bookOverlay,
				bookStatus,
			);

			progressBar.append(progressGauge);

			addTouchScaler(booksItem, async () => {
				if (offlineSession && !bookIsOffline) return;

				const seriesData = useOfflineCopy ? offline.seriesMetadata : await callAPI(`c_seriesdata${book.seriesId}`, `/api/v1/series/${book.seriesId}`);
				const readingDirection = seriesData.metadata.readingDirection;

				if (target == booksGrid) {
					rd.historyPath = window.location.hash.split('&book_id=')[0] + '&book_id=' + book.id;
				} else if (target == offlineGrid) {
					rd.historyPath = window.location.hash.split('?book_id=')[0] + '?book_id=' + book.id;
				} else {
					rd.historyPath = window.location.hash.split('&book_id=')[0];
				}

				setIncognito(false);
				if (target?.binName) mb.dashboardBin = target.binName;
				navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${readingDirection}
						&pag=${(book.readProgress ? book.readProgress.page : 1)}`);
			});

			item.append(booksItem);
		}

		function displayBooks(books, target, format, focus = null) {
			/*
				"format" can be one of the follows
				- longname: will not show the series name, but the book file name
				- compact: will show series name and pages 
				- timeline: will show latest read date
			*/
			// focus is the book id to focus on

			while (target.firstChild) {
				target.removeChild(target.firstChild);
			}

			if (books.length === 0) {
				const noBooksMsg = document.createElement('p');
				noBooksMsg.textContent = 'No books available';
				booksGrid.append(noBooksMsg);
				return;
			}

			books.forEach(book => {
				const bookContainer = addItem('div', {
					className: 'book-container',
					id: book.id
				});

				buildBookItem(bookContainer, book, format, target);

				target.append(bookContainer);
			});

			if (target == booksGrid) {
				sectionShow(booksGrid);
				sectionShow(seriesHeader);
				sectionShow(seriesMiniHeader);
				seriesMiniHeader.classList.add('collapse');
				focusItem(focus);
			}

		}

		//MB Dashboard Management

		// Function to trigger the home page layout
		async function selectHome() {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = '';
			booksGrid.innerHTML = '';
			offlineGrid.innerHTML = '';
			stripGrid.innerHTML = '';

			sectionShow(homeStripsContainer);

			await Promise.all(
				Object.entries(dashboardElements).map(async ([name, item]) => {
					const resultsObject = await item.getItems(0, 20);
					item.element.style.display = resultsObject.empty ? 'none' : 'block';
					item.showItems(resultsObject.content, item.homeStrip);
				})
			);
			setTimeout(updateSliderProperties, 10);

		}

		dashboardElements = {
			keepReading: {
				headerCode: '<span class="fa-solid fa-book-bookmark glyph-dark"></span>&nbsp;Keep Reading',
				getItems: async (page, size) => {
					const out = await callAPI(`c_keepreading`,
						`/api/v1/books/list?page=0&unpaged=true&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"IN_PROGRESS"}}}`
					);
					return (out);
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
				element: null,
				scrollBar: null,
				gridButton: null,
				homeStrip: null,
			},


			onDeck: {
				headerCode: '<span class="fa-solid fa-inbox glyph-dark"></span>&nbsp;On Deck',
				getItems: async (page, size) => {
					return (await callAPI(`c_ondeck`, `/api/v1/books/ondeck`));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				},
			},

			recentBooks: {
				headerCode: '<span class="fa-solid fa-book glyph-dark"></span>&nbsp;Last Added Books',
				getItems: async (page, size) => {
					return (await callAPI(`c_recentbooks`,
						`/api/v1/books/list?page=${page}&size=${size}&sort=created,desc`,
						'POST', `{"condition":{"allOf":[]}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'compact');
				}
			},

			recentSeries: {
				headerCode: '<span class="fa-solid fa-layer-group glyph-dark"></span>&nbsp;Last Added Series',
				getItems: async (page, size) => {
					return (await callAPI(`c_recentseries`, `/api/v1/series/new?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			updatedSeries: {
				headerCode: '<span class="fa-solid fa-bullhorn glyph-dark"></span>&nbsp;Last Updated Series',
				getItems: async (page, size) => {
					return (await callAPI(`c_updatedseries`, `/api/v1/series/updated?page=${page}&size=${size}`));
				},
				showItems: async (input, target) => {
					displaySeries(input, target);
				}
			},

			readBooks: {
				headerCode: '<span class="fa-solid fa-square-check glyph-dark"></span>&nbsp;Last Read Books',
				getItems: async (page, size) => {
					return (await callAPI(`c_readbooks`,
						`/api/v1/books/list?page=${page}&size=${size}&sort=readProgress.readDate,desc`,
						'POST', `{"condition":{"readStatus":{"operator":"is","value":"READ"}}}`
					));
				},
				showItems: async (input, target) => {
					displayBooks(input, target, 'timeline');
				},
			},
		}

		async function dashboardAll(element, page) {

			libraryHighlight('homeButton', false);

			seriesGrid.innerHTML = ''; // Clear the series grid
			booksGrid.innerHTML = ''; // Clear the series grid
			offlineGrid.innerHTML = ''; // Clear the series grid
			stripGrid.innerHTML = '';

			sectionShow(stripGridContainer);

			stripGridHeader.innerHTML = dashboardElements[element].headerCode;
			const data = await dashboardElements[element].getItems(page, 50);

			const array = data.content;

			stripPrevPage.classList.remove('disabled');
			stripNextPage.classList.remove('disabled');
			if (data.first) stripPrevPage.classList.add('disabled');
			if (data.last) stripNextPage.classList.add('disabled');

			dashboardElements[element].showItems(array, stripGrid);
		}

		const dashEntries = Object.entries(dashboardElements);

		dashEntries.forEach(([name, item], index) => {
			const isLast = dashEntries.length - 1 === index;

			item.element = addItem('div', { className: 'home-strip-parent hidestrip' });
			const headerContainer = addItem('div', { className: 'strip-header-container hidestrip' });
			const stripHeader = addItem('div', {
				className: 'strip-header hidestrip',
				innerHTML: item.headerCode,
			});
			item.scrollBar = addItem('div', {
				className: 'custom-scrollbar',
			});
			item.scrollInput = addItem('input', {
				type: 'range',
				className: 'range-bar',
				min: '0',
				max: '100',
				value: '0'
			});
			item.gridButton = addItem('div', {
				className: 'strip-all press-flat-button strip-button',
				innerHTML: '<span title="View All" class="fa-solid fa-grip glyph-dark"></span>',
			});
			item.homeStrip = addItem('div', {
				className: 'home-strip' + (isLast ? ' last-strip' : ''),
				binName: name,
			})

			addClickPointerEvents(item.gridButton, async () => {
				mb.dashboardBin = name;
				navigateTo('#dashboard?all=' + name + '&page=0')
			});

			addPressEvents(item.gridButton, scaleDown, scaleUp);

			item.scrollInput.addEventListener('input', () => {
				item.homeStrip.scrollLeft = item.scrollInput.value;
			});
			item.homeStrip.addEventListener('scroll', () => {
				item.scrollInput.value = item.homeStrip.scrollLeft;
			});

			item.scrollBar.append(item.scrollInput);
			headerContainer.append(stripHeader, item.scrollBar, item.gridButton);
			item.element.append(item.homeStrip, headerContainer);
			homeStripsContainer.append(item.element);

		});

		// Open a whole series fetching all its books and showing them with the correct header
		// if seriesdata is not available at the moment of the call, it fetches it from the server
		async function openSeries(libraryId, seriesId, bookId) {

			let books = [];
			const seriesData = await callAPI(`c_seriesdata${seriesId}`, `/api/v1/series/${seriesId}`);

			const booksData = (await callAPI(`c_bookslist${seriesId}`,
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"seriesId": {"operator": "is","value": "${seriesId}"}}}`
			));

			books = booksData?.content || [];

			await libraryHighlight(libraryId, false);
			if (seriesData != null) displayHeader(seriesData);
			displayBooks(books, booksGrid, 'longname', bookId);
		}

		async function openOfflineBooks(bookId) {
			libraryHighlight('offlineLibrary', false);

			const unFilteredBooks = await callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);
			unFilteredBooks.content.sort((a, b) => a.seriesTitle.localeCompare(b.seriesTitle))

			const filteredBooks = unFilteredBooks.content.filter(item =>
				obIsBookDownloading(item.id) || obIsBookCompleted(item.id)
			);

			//books = booksData?.content || [];

			//TODO await libraryHighlight(libraryId, false);

			displayBooks(filteredBooks, offlineGrid, 'compact', bookId);
			focusItem(bookId);//TODO ERA 'top'
			setTimeout(updateSliderProperties, 10);
			sectionShow(offlineGrid);
		}

		function setNetworkStatus(netStatus) {
			offlineLed.style.opacity = (netStatus == 'offline') ? 1 : 0;
			offlineSession = (netStatus == 'offline');
		}

		async function bootSequence(netStatus = 'online') {

			setNetworkStatus(netStatus)

			userSettings = await getUserSettings();

			applyUserSettings();

			applyAccent();
			// Apply first theme change
			changeTheme();
			//changeReaderTheme();
			setIncognito(false);

			document.querySelectorAll('.blankstart').forEach(el => {
				el.classList.remove('blankstart');
			});

			buildLanguageList();

			sectionShow(stickyContainer);

			let series_data = null;
			await fetchLibraries();
			await loadContent();

			document.querySelectorAll('.hidestrip').forEach(el => {
				el.classList.remove('hidestrip');
			});

			if (enableDownload) await obRefreshReadStatus();

			// Asynchronous loading of series and books, there's no await, because it's not used unless in offline mode
			const fakerSeries = callAPI('c_serieslistall',
				`/api/v1/series/list?page=0&unpaged=true&sort=metadata.titleSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);
			const fakerBooks = callAPI('c_bookslistall',
				`/api/v1/books/list?page=0&unpaged=true&sort=metadata.numberSort,asc`,
				'POST', `{"condition": {"allOf": []}}`
			);

			if (enableDownload) obRestoreDownloadOnBoot();
		}

		//MB Reader Functions and Data

		// General reader data structure
		let rd = {
			dragbarTimer: null,

			orientationThresholdRatio: 1.0,		//Orientation threshold

			preloadCount: 15,			// TODO SET BACK TO 15 Image preload count
			preloadPicDelay: 300,	// Delay before adding new spreads to the preload stack
			loadDelay: 100,			// Delay used when jumping to a spread before really updating
			jumpTimeout: null,		// Timeout counter for jumping to spreads

			preloadStack: {}, 		// Contains all the preload timers, one for each spread that's going to be loaded
			picLoadStack: [], 		// Contains all load image objects, both direct load and preload

			direction: null,
			webtoon: null,
			webtoonScroll: false,
			webtoonScrollRatio: 0,
			webtoonResizeTimeout: null,

			rtl: null,
			currentPage: 0,
			pagesDataArray: [],		// this is the array of pages data in the form url, iscover etc
			spreadsArray: [],			// Array of spreads objects, containing:

			currentPageIndex: 0,
			currentSpreadIndex: 0,
			oldSpreadIndex: 0,
			isDraggingProgressBar: false,

			thumbZoom: false,
			thumbPosRatio: 0,

			libraryId: 0,
			seriesId: 0,
			bookId: 0,

			historyPath: '',
			bookPath: '',

			incognito: false,

			foreEdgeL: null,
			foreEdgeR: null,
			dropShadowL: null,
			dropShadowR: null,

			turnTimeout: null,
			pageTurning: null,

			turnTime: 500,				// Duration of turning page animation
			scrollSpeed: 500,			// Duration of spread page scrolling
			turnScrollDelay: 300,	// Delay of spread page scrolling during page turn
			turnScrollTime: 500,		// Duration of spread page scrolling during page turn

			pageShadowOpacityFWD: '0.4',
			pageShadowOpacityBWD: '0.3',
			pageShadowWidthFWD: '10%',
			pageShadowWidthBWD: '15%',

			spreadFocus: 'focus-center',

			focusTransition: {
				'focus-right-page': 'translate(-75%, -50%)',
				'focus-left-page': 'translate(-25%, -50%)',
				'focus-center': 'translate(-50%, -50%)',
				'none': 'translate(-50%, -50%)',
			},

			realFirstPage: 0,
			realLastPage: 0,

			nextBook: null,
			prevBook: null,

			titleBarColor: 'black',

			scale: 1,
			startDist: 0,
			originX: 0,
			originY: 0,
			touchLock: 0
		};

		// Function that prepares the page for reading a book, once the url is setup, navigateTo triggers openBookReader function
		function navigateToReadBook(book, readingDirection, force = false) {
			setIncognito(false);
			navigateTo(`#bookread
						?library_id=${book.libraryId}
						&series_id=${book.seriesId}
						&book_id=${book.id}
						&dir=${readingDirection}
						&pag=${force ? 1 : (book.readProgress ? book.readProgress.page : 1)}`);
		}

		// Function that setups the reader for a specific book, this is not run directly
		function openBookReader(libraryId, seriesId, bookId, dir, pag) {
			//TODO aggiungere funzione per pulire l'array del preload e quello delle pic
			Object.entries(dashboardElements).forEach(([name, item]) => {
				item.homeStrip.innerHTML = '';
			});
			clearReader(); //TODO forse eccessivo?
			clearAllTimeouts();
			rd.picLoadStack = [];
			rd.jumpTimeout = null;

			rd.direction = dir;
			rd.webtoon = (dir == 'WEBTOON');
			rd.webtoonScroll = false;
			rd.webtoonScrollRatio = 0;
			rd.rtl = (dir == 'RIGHT_TO_LEFT');

			rd.currentPage = pag;

			rd.spreadsArray = [];

			rd.currentPageIndex = 0;
			rd.currentSpreadIndex = 0;
			rd.oldSpreadIndex = 0;
			rd.isDraggingProgressBar = false;

			rd.libraryId = libraryId;
			rd.seriesId = seriesId;
			rd.bookId = bookId;

			rd.spreadFocus = 'focus-center';

			rd.scale = 1;
			rd.startDist = 0;
			rd.originX = 0;
			rd.originY = 0;
			rd.touchLock = 0;

			scaleWebtoon(0);

			//readerViewer.innerHTML = '';
			thumbStripShowHide();

			dragbarOnReader();

			setThumbZoom(false, true);

			changeReaderTheme();

			sectionShow(readerContainer);
			sectionShow(readerOverlay);
			sectionShow(touchPanel);

			if (isStatusBar) {
				Capacitor.Plugins.StatusBar.hide();
			}
			initViewer();

		}

		// Reader cleanup functions to remove all dangling spreads and pages
		function clearReader() {

			// Cleanup ForeEdge and drop shadows
			['foreEdgeL', 'foreEdgeR', 'dropShadowL', 'dropShadowR'].forEach(key => {
				if (rd[key]) {
					rd[key].remove();
					rd[key] = null;
				}
			});

			// Cleanup all the spreads: remove each uiItem (and their descendants) from dom, then null all the graphics item
			// like uiShadowL and uiShadowR, then cleanup the array
			rd.spreadsArray.forEach(item => {
				item.uiItem.remove();
				item.uiThumb.remove();
				item.uiItem = null;
				item.uiThumb = null;
				item.uiShadowL = null;
				item.uiShadowR = null;
				item.uiLightL = null;
				item.uiLightR = null;
				['pageObjL', 'pageObjR'].forEach(key => {
					if (item[key] != null) {
						if (rd.webtoon) webtoonPageNumberObserver.unobserve(item[key].uiPage)
						item[key].uiPage.remove();
						item[key].uiContainer.remove();
						item[key].uiThumb.remove();
						item[key].uiPage = null;
						item[key].uiContainer = null;
						item[key].uiThumb = null;
					}
					item[key] = null;
				});
			});
			rd.spreadsArray = [];

			webtoonContainer.removeAttribute('style');
			sectionHide(readerContainer);
			sectionHide(readerOverlay);
			sectionHide(touchPanel);
		}

		function spreadSetFocus(focusString, smoothMove = false, delayMove = false) {
			if (rd.webtoon) return

			let [duration, delay] = !smoothMove ? [0, 0] : (delayMove ? [rd.turnScrollTime, rd.turnScrollDelay] : [rd.scrollSpeed, 0]);

			readerViewer.animate(
				[{ transform: rd.focusTransition[focusString] }],
				{ duration: duration, easing: 'ease', fill: 'forwards', delay: delay }
			);
			rd.spreadFocus = focusString;
		}

		function spreadSetFocusSmooth(focusString) {
			spreadSetFocus(focusString, true, false)
		};

		function spreadSetFocusSmoothDelay(focusString) {
			spreadSetFocus(focusString, true, true)
		}

		// Setup close button
		function handleCloseReader() {
			hideMenu();
			setIncognito(false);
			//XXX WAS incognitoMark.classList.remove('incognito'); but why didn't I just sue setIncognito(false)?

			clearTimeout(rd.jumpTimeout);
			setTimeout(() => {
				spreadSetFocus('none');
				clearReader();
			}, 400); //300ms timeout so the reader can slide out

			purgeLoading();
			clearAllTimeouts();

			navigateTo(rd.historyPath == '' ? '#dashboard' : rd.historyPath);

			updatePWABar();
			if (isStatusBar && !isSharpCornerIphone && !((capacitorPlatform == 'android') && isOrientationLandscape())) {
				Capacitor.Plugins.StatusBar.show();
			}

		}

		readerClose.addEventListener('click', () => {
			handleCloseReader();
		});

		function changeReaderTheme() {
			mb.readerThemeControl.forEach(item => {
				readerTheme.classList.remove(item.icon);
			});
			readerTheme.classList.add(mb.readerThemeControl[mb.readerThemePrefs].icon);
			readerTheme.title = mb.readerThemeControl[mb.readerThemePrefs].label;

			document.documentElement.setAttribute('data-theme-reader', mb.readerThemeControl[mb.readerThemePrefs].style);

			rd.titleBarColor = rd.webtoon ? 'black' : getComputedStyle(document.documentElement).getPropertyValue('--color1');

			//rd.titleBarColor = "black";

			setUserSettings('mangabox.ui.readerthemeprefs', mb.readerThemePrefs);

		}

		readerTheme.addEventListener('click', () => {
			mb.readerThemePrefs = (mb.readerThemePrefs + 1) % mb.readerThemeControl.length;
			changeReaderTheme();
		});

		// Setup incognito button
		function setIncognito(status) {
			readerIncognito.classList.remove('incognito');
			incognitoMark.classList.remove('incognito');

			if (status) {
				readerIncognito.classList.add('incognito');
				incognitoMark.classList.add('incognito')
			};

			rd.incognito = status;
		}

		readerIncognito.addEventListener('click', () => {
			setIncognito(!rd.incognito);
		})

		window.addEventListener('resize', () => {
			if (rd.webtoon) webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
		});

		function setThumbZoom(status, init = false) {

			if ((!init) && (rd.thumbZoom == status)) return;

			clientSize = rd.webtoon ? 'clientHeight' : 'clientWidth';
			scrollRef = rd.webtoon ? 'scrollTop' : 'scrollLeft';
			scrollContent = rd.webtoon ? thumbStripScrollContentWT : thumbStripScrollContent;
			inner = rd.webtoon ? thumbStripInnerWT : thumbStripInner


			rd.thumbZoom = status;
			rd.thumbPosRatio = scrollContent[scrollRef] / inner[clientSize]


			scrollContent.style.overflowX = 'hidden';
			scrollContent.style.overflowY = 'hidden';

			const oldSize = inner[clientSize];

			let thumbSize = rd.webtoon ? (status ? 120 : 80) : (status ? 300 : 150);

			if (!rd.webtoon) {
				if (window.innerHeight - thumbSize - 60 - 60 - 30 < 0) {
					thumbSize = window.innerHeight - 60 - 60 - 30;
				}
			}
			document.documentElement.style.setProperty('--mb-thumb-size-px', thumbSize + 'px');



			setTimeout(() => {
				scrollContent.style.overflowX = rd.webtoon ? 'hidden' : 'auto';
				scrollContent.style.overflowY = rd.webtoon ? 'auto' : 'hidden';
			}, 500);

		}

		thumbStripButton.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});
		addPressEvents(thumbStripButton, scaleDown, scaleUp);

		thumbStripButtonWT.addEventListener('click', () => {
			setThumbZoom(!rd.thumbZoom);
		});
		addPressEvents(thumbStripButtonWT, scaleDown, scaleUp);

		//TODO This code is flexible and usable for both, an alternative is splitting all the code for the two WT and !WT

		const resizeObserver = new ResizeObserver(entries => {
			clientSize = rd.webtoon ? 'clientHeight' : 'clientWidth';
			scrollRef = rd.webtoon ? 'scrollTop' : 'scrollLeft';
			scrollContent = rd.webtoon ? thumbStripScrollContentWT : thumbStripScrollContent;
			inner = rd.webtoon ? thumbStripInnerWT : thumbStripInner

			for (let entry of entries) {
				scrollContent[scrollRef] = rd.thumbPosRatio * (inner[clientSize])
			}
		});

		resizeObserver.observe(thumbStripInner);
		resizeObserver.observe(thumbStripInnerWT);

		function updateProgressBar(currentSpreadIndex = rd.currentSpreadIndex) {
			const progressPercent = (currentSpreadIndex / (spreadsTotal() - 1)) * 100;
			readerProgress.style.width = `${progressPercent}%`;
			readerProgress.style.float = rd.rtl ? 'right' : 'left';

			[rd.currentPage, readerPage.innerText] = getPageFromSpread(currentSpreadIndex);

			readerPage.style.left = rd.rtl
				? `min(max(0px, calc(${100 - progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
				: `min(max(0px, calc(${progressPercent}% - ${readerPage.clientWidth * 0.5}px)), calc(100% - ${readerPage.clientWidth}px))`
		}

		function preloadPage(index) {
			if (picLoadStackSize() < 20000000) populateSpreadPreload(index);
		}

		function calcDelay(i, delay, scale, power) {
			return ((delay * (1 - scale) + (i ** power) * delay * scale))
		}

		// This function triggers multiple preloads starting from the current spread
		function preloadPages(startSpreadIndex, count) {
			if (isSectionHidden(readerContainer)) return;

			for (let i = 1; i <= count; i++) {
				const forwardIndex = startSpreadIndex + i;
				const backwardIndex = startSpreadIndex - i;

				if (forwardIndex < spreadsTotal() && !(forwardIndex in rd.preloadStack)) {
					startTimeout(forwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(forwardIndex));
				}
				if (backwardIndex >= 0 && !(backwardIndex in rd.preloadStack)) {
					startTimeout(backwardIndex, calcDelay(i, 300, 0.25, 2), () => preloadPage(backwardIndex));
				}
			}
		}

		function dragbarOffReader() {
			rd.dragbarTimer = setTimeout(() => {
				dragbar.classList.remove('onReader');
			}, 500);
			//dragbar.classList.remove('offReader');
		}

		function dragbarOnReader() {
			clearTimeout(rd.dragbarTimer);
			dragbar.classList.remove('onReader');
			dragbar.classList.add('onReader');
		}

		function initReaderUI(pagesData, bookData) {
			leftLimit.innerText = rd.rtl ? rd.realLastPage : rd.realFirstPage;
			rightLimit.innerText = rd.rtl ? rd.realFirstPage : rd.realLastPage;
			bookName.innerText = `${bookData.seriesTitle} Vol.${bookData.metadata.number} (${bookData.metadata.title})`
		}

		function webtoonRatio() {
			return (webtoonContainer.scrollTop + webtoonContainer.clientHeight * 0.5) / webtoonContainer.scrollHeight
		}

		function thumbStripShowHide() {
			thumbStrip.style.display = thumbStripButton.style.display = rd.webtoon ? 'none' : '';
			thumbStripWT.style.display = thumbStripButtonWT.style.display = rd.webtoon ? '' : 'none';
		}

		// Initialize viewer with page data
		async function initViewer() {
			//TODO questa si può estrarre come quella di buildbookitem
			let offline = null;

			let useOfflineCopy = offlineSession && obIsBookCompleted(rd.bookId);
			if (useOfflineCopy) {
				offline = await obLoadOfflineBook(rd.bookId);
			}
			updatePWABar(rd.titleBarColor);

			const bookData = useOfflineCopy ? offline.bookMetadata : await callAPI(`c_bookdata${rd.bookId}`, `/api/v1/books/${rd.bookId}`);

			rd.prevBook = await callAPI(`c_books${rd.bookId}prev`, `/api/v1/books/${rd.bookId}/previous`) || null;
			rd.nextBook = await callAPI(`c_books${rd.bookId}next`, `/api/v1/books/${rd.bookId}/next`) || null;

			if (!prevBookPanel.classList.contains('hidden')) prevBookPanel.classList.add("hidden");
			if (!nextBookPanel.classList.contains('hidden')) nextBookPanel.classList.add("hidden");

			const noCover = bookData.metadata.tags.includes('no-cover');
			const noWhitePage = bookData.metadata.tags.includes('no-blank-page');
			const coverIsPageOne = bookData.metadata.tags.includes('cover-is-page-one');

			const pagesData = !rd.webtoon ?
				await fetchPages(rd.bookId, noCover, noWhitePage, coverIsPageOne, offline) :
				await fetchPagesWebtoon(rd.bookId, noCover, noWhitePage, coverIsPageOne, offline);
			console.log("A:" + rd.currentSpreadIndex)
			if (!rd.incognito && bookData.readProgress && (bookData.readProgress.completed === true)) {
				console.log("current spread index set to zero")
				rd.currentSpreadIndex = 0; //TODO Maybe change this with a check with the top page?
			}
			console.log("B:" + rd.currentSpreadIndex)

			touchPanel.style.display = rd.webtoon ? 'none' : '';
			zoomControls.style.display = rd.webtoon ? '' : 'none';

			initReaderUI(pagesData, bookData)
			console.log("C:" + rd.currentSpreadIndex)

			jumpToSpreadSkipHistory(rd.currentSpreadIndex);

			if (rd.webtoon) {
				rd.webtoonScrollRatio = webtoonRatio()
			}

			readerContainer.style.transform = `scale(100%)`;
			readerContainer.style.transformOrigin = `50% 50%`;

			setTimeout(() => {
				webtoonContainer.style.overflow = 'auto';
				//thumbStripScrollContent.style.overflowX = 'auto';
				//thumbStripScrollContent.style.overflowY = 'hidden';
				//thumbStripScrollContentWT.style.overflowX = 'hidden';
				//thumbStripScrollContentWT.style.overflowY = 'auto';

			}, 500);

		}

		function buildSize(item, ratio) {
			item.style.width = `calc(min(100vw, ${100 * ratio}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh) )`;
		}

		function buildSizeCV(item, ratio) {
			//item.style.objectFit = 'fill';
			item.style.objectPosition = 'center center';
			item.style.width = `calc(min(100vw, ${100 * ratio}vh))`;
			item.style.height = `calc(min(${100 / ratio}vw, 100vh) )`;
		}

		// Size the spread for a two pages spread with fit on page
		function buildSize2P(item, ratio) {
			//item.style.width = `calc(2 * min(100vw, ${100 * ratio * 0.5}vh))`;
			//item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, 100vh))`;

			item.style.width = `calc(2 * min(100vw, ${100 * ratio * 0.5}vh))`;
			item.style.height = `calc( min(${100 / (ratio * 0.5)}vw, 100vh) )`;
		}

		// Add this once when initializing the viewer
		//readerViewer.style.transition = "left 0.3s ease, border-width 0.3s ease, border-image-slice 0.3s ease";

		function buildForeEdge(index, total) {
			// book size is a parabola based on number of spreads capped at 400 spreads
			const fullBook = (total / 400 > 1 ? 1 : ((1 - (total / 400 - 1) * (total / 400 - 1))));
			const pageRate = rd.rtl ? 1.0 - index / total : index / total;

			[clipLeft, clipRight] = [
				`inset(0 0 0 ${100 * ((1.0 - fullBook) + fullBook * (1 - pageRate))}%)`,
				`inset(0 ${100 * (1.0 - fullBook + fullBook * pageRate)}% 0 0)`]

			return ({ left: clipLeft, right: clipRight, dropL: fullBook * pageRate, dropR: fullBook * (1 - pageRate) })
		}

		//MB Reader Fetch Page Function

		function buildSpreadObject(spreadKind, spreadPages, spreadRefPage, spreadPageNums) {
			// I put the image item and container item in the array so I can target them for changes
			// and I put all the metadata like "hasSrc" in the object metadata instead of in a separate item.
			if (!rd.webtoon) {
				return ({
					// dom object, spread div and its content
					// dom object, shadow for page effect, children of uiItem in the dom
					//  "
					// dom object, thumbnail of the spread for the strip view
					uiItem: addItem('div', { className: 'spread-layout' }),
					uiShadowL: addItem('div', { className: 'page-shadow-left' }),
					uiShadowR: addItem('div', { className: 'page-shadow-right' }),
					uiLightL: addItem('div', { className: 'page-light-left' }),
					uiLightR: addItem('div', { className: 'page-light-right' }),
					uiThumb: addItem('div', { className: 'spread-thumb' }),
					pageObjL: spreadPages['left'] ?? null,
					pageObjR: spreadPages['right'] ?? null,

					pageNumL: spreadPageNums['left'] ?? null,
					pageNumR: spreadPageNums['right'] ?? null,

					spreadKind: spreadKind,	// what kind of page is this (cover, double spread, two pages etc)
					spreadRefPage: spreadRefPage
				})
			} else {
				return ({
					// dom object, spread div and its content
					// dom object, shadow for page effect, children of uiItem in the dom
					//  "
					// dom object, thumbnail of the spread for the strip view
					uiItem: addItem('div', { className: 'webtoon-layout' }),
					//uiShadowL: addItem('div', { className: 'page-shadow-left' }),
					//uiShadowR: addItem('div', { className: 'page-shadow-right' }),
					//uiLightL: addItem('div', { className: 'page-light-left' }),
					//uiLightR: addItem('div', { className: 'page-light-right' }),
					uiThumb: addItem('div', { className: 'webtoon spread-thumb' }),
					pageObjL: spreadPages ?? null,
					//pageObjR: spreadPages['right'] ?? null,

					pageNumL: spreadPageNums ?? null,
					//pageNumR: spreadPageNums['right'] ?? null,

					spreadKind: spreadKind,	// what kind of page is this (cover, double spread, two pages etc)
					spreadRefPage: spreadRefPage
				})
			}
		}

		function spreadsTotal() {
			return rd.spreadsArray.length
		}

		function buildPageObject(pageData) {
			const isBlank = (pageData == 'blank');
			const isHidden = (pageData == 'hidden');

			const pageItem = {
				uiPage: addItem('img', {
					alt: isBlank ? '' : pageData.pageNum,
					className: 'page multiply hidden',
					src: 'transparent.png',
				}),
				uiContainer: addItem('div', {
					className: isHidden ? 'page-container hidden-page' : 'page-container'
				}),
				uiThumb: addItem('img', {
					className: isHidden ? 'page-thumb multiply hidden hidden-page' : 'page-thumb multiply hidden',
					alt: (isBlank || isHidden) ? '' : pageData.pageNum,
					src: 'transparent.png',
					lazySrc: (isBlank || isHidden) ? '' : pageData.thumb,
					style: rd.webtoon ?
						{
							width: 'var(--mb-thumb-size-px)',
							aspectRatio: isHidden ? '0.001' : pageData.AR,
						} : {
							height: 'var(--mb-thumb-size-px)',
							aspectRatio: isHidden ? '0.001' : pageData.AR,
						}
				}),
				hasSrc: (isBlank || isHidden) ? true : false,
				lazySrc: (isBlank || isHidden) ? '' : pageData.url,
				size: (isBlank || isHidden) ? 0 : pageData.size,
				pageNum: (isBlank || isHidden) ? '' : pageData.pageNum,
				isCurrent: (isBlank || isHidden) ? false : pageData.isCurrent,
				AR: isBlank ? null : pageData.AR,
			}

			if ((pageData != 'blank') && (pageData != 'hidden')) addLazyLoading(pageItem.uiThumb);
			pageItem.uiContainer.append(pageItem.uiPage);

			return pageItem;
		};

		function pageTable(page1, page2) {
			return (
				rd.rtl ?
					{ left: page2, right: page1 } :
					{ left: page1, right: page2 }
			)
		}

		function animateWebtoonScale(from, to, duration = 300, easing = t => t) {
			let start;
			function frame(ts) {
				if (!start) start = ts;
				const t = Math.min(1, (ts - start) / duration);
				const v = from + (to - from) * easing(t);
				document.documentElement.style.setProperty('--webtoon-scale', v);
				webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
				if (t < 1) requestAnimationFrame(frame);
			}
			requestAnimationFrame(frame);
		}

		function scaleWebtoon(inc) {
			const oldScale = mb.webtoonScale;
			const newScale = Math.min(100, Math.max(20, mb.webtoonScale + inc));
			mb.webtoonScale = newScale;

			setUserSettings('mangabox.ui.webtoonscale', newScale);
			scaleVal.innerText = newScale + "%";

			animateWebtoonScale(oldScale, newScale, 200, t => t * (2 - t));
		}

		function scaleWebtoonOLD(inc) {
			mb.webtoonScale = Math.min(100, Math.max(20, mb.webtoonScale + inc));
			setUserSettings('mangabox.ui.webtoonscale', mb.webtoonScale);
			scaleVal.innerText = mb.webtoonScale + "%";

			document.documentElement.style.setProperty('--webtoon-scale', mb.webtoonScale);
			webtoonContainer.scrollTop = rd.webtoonScrollRatio * webtoonContainer.scrollHeight - 0.5 * webtoonContainer.clientHeight;
		}

		function addCoverSpine(pageObjectL, pageObjectR) {
			const coverlayR = addItem('div', {
				id: 'coverlayer',
				className: 'LTR',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectR.uiContainer.append(coverlayR);
			const coverlayL = addItem('div', {
				id: 'coverlayer',
				className: 'RTL',
				style: {
					width: pageObjectR.uiContainer.style.width,
					height: pageObjectR.uiContainer.style.height,
				}
			});
			pageObjectL.uiContainer.append(coverlayL);
		}

		const mimeToExt = {
			'image/jpeg': '.jpg',
			'image/png': '.png',
			'image/webp': '.webp',
			'image/gif': '.gif',
		};

		async function fetchPagesWebtoon(bookId, noCover, noWhitePage, coverIsPageOne, offline) {

			let useOfflineCopy = !(offline == null);

			// Get the pages data structure from komga for the current book
			const komgaPageData = useOfflineCopy ? offline.pagesMetadata : await callAPI(`c_bookpages${bookId}`, `/api/v1/books/${bookId}/pages`);

			/*
			readerViewer.style.width = webtoonScale * (komgaPageData.map(item => ((item.width)))
				.reduce((sum, width) => sum + width, 0) / komgaPageData.length) + 'px';
	
			readerViewer.style.height = webtoonScale * (komgaPageData.map(item => ((item.height)))
				.reduce((sum, width) => sum + width, 0)) + 'px';
			*/
			mb.readerHorizontal = isReaderHorizontal(mb.screenAR);
			thumbStripInnerWT.style.flexDirection = 'column';
			console.log("fetch pages current page" + rd.currentPage)
			const pageData = komgaPageData.map(page => ({
				url: useOfflineCopy ? `${offline.bookPath}/pages/${page.number}${mimeToExt[page.mediaType]}` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: useOfflineCopy ? `${offline.bookPath}/thumbs/t_${page.number}.jpg` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: noCover ? false : page.number == 1,
				isCurrent: page.number == rd.currentPage,
				size: page.sizeBytes
			}));

			//let imageWidth = pageData[0].width;
			let imageWidth = Math.max(...pageData.map(p => p.width));

			let screenWidth = readerContainer.clientWidth;

			//let webtoonScale = 1.0;
			//if (screenWidth < imageWidth) webtoonScale = screenWidth / imageWidth;

			let i_page = 0; 		// Index of komga page data
			let realPage = 1;		// Index of real page

			// double spread with single page are treated as this:
			// one div for the spread contains TWO pages sharing the same image, but with different alignment properties
			// therefore the pageNums are like [5, 5] and the imageRefs are like (5,6)

			rd.realFirstPage = '1';

			while (i_page < pageData.length) {
				let spreadObject = null;

				pageNum1 = realPage

				// these are two normal pages
				const page1 = buildPageObject(pageData[i_page]);

				page1.uiPage.style.width = `calc(var(--webtoon-scale) * 1vw)`
				page1.uiPage.style.height = `calc(var(--webtoon-scale) * 1vw / ${pageData[i_page].AR})`

				if (rd.webtoon) webtoonPageNumberObserver.observe(page1.uiPage);

				spreadObject = buildSpreadObject('webtoon-page', page1, pageData[i_page].pageNum, pageNum1);
				rd.realLastPage = pageNum1;

				rd.spreadsArray.push(spreadObject);
				i_page++;
				realPage++;

			}

			rd.spreadsArray.forEach((spreadObject, index) => {

				let pageObjectL = spreadObject.pageObjL;

				spreadObject.uiThumb.append(
					pageObjectL.uiThumb,
				);

				spreadObject.uiItem.append(
					pageObjectL.uiContainer,
				);

				spreadObject.uiItem.style.width = pageObjectL.uiPage.style.width
				spreadObject.uiItem.style.height = pageObjectL.uiPage.style.height

				//buildSize2P(spreadObject.uiItem, mb.readerMaxRatio);
				//TODO Ma questo serve???? Farlo uguale a readerViewer?
				//spreadObject.uiItem.style.width = `calc(min(200vw, ${100 * mb.readerMaxRatio}vh))`;

				//buildSize(pageObjectL.uiContainer, mb.readerMaxRatio * 0.5);
				//buildSize(pageObjectR.uiContainer, mb.readerMaxRatio * 0.5);

				pageObjectL.uiPage.style.float = 'right';
				pageObjectL.uiPage.style.objectFit = 'cover';
				pageObjectL.uiPage.style.objectPosition = 'left';

				if ((pageObjectL.isCurrent)) rd.currentSpreadIndex = index;
				console.log("D:" + rd.currentSpreadIndex)

				//spreadObject.uiItem.append(spreadObject.uiShadowL, spreadObject.uiShadowR);
				//spreadObject.uiItem.append(spreadObject.uiLightL, spreadObject.uiLightR);

				webtoonContainer.append(spreadObject.uiItem);
				//spreadHide(index);

				const localSpread = index;

				spreadObject.uiThumb.addEventListener('pointerup', () => {
					console.log("X-B:" + localSpread)
					jumpToSpread(localSpread);
				});
				thumbStripInnerWT.append(spreadObject.uiThumb);

			});
		}

		// Master function that builds all the pages slots for the book spreads
		async function fetchPages(bookId, noCover, noWhitePage, coverIsPageOne, offline) {

			let useOfflineCopy = !(offline == null);

			// Get the pages data structure from komga for the current book
			const komgaPageData = useOfflineCopy ? offline.pagesMetadata : await callAPI(`c_bookpages${bookId}`, `/api/v1/books/${bookId}/pages`);

			// mb.readerMaxRatioOLD = Math.max(...dataOut.map(item => (item.isCover || item.isDoubleSpread) ? 0 : ((item.width / item.height) < 1 ? 2 * item.width / item.height : 2 * item.width / item.height)));
			mb.readerMaxRatio = komgaPageData.map(item => ((item.width / item.height) < 1 ? 2 * item.width / item.height : item.width / item.height))
				.reduce((sum, ratio) => sum + ratio, 0) / komgaPageData.length;
			// readerViewer.style.height='100vh';
			readerViewer.style.height = `calc(min(${100 / (0.5 * mb.readerMaxRatio)}vw, 100vh))`;
			//readerViewer.style.width=`calc(${mb.readerMaxRatio} * 100vh)`;
			readerViewer.style.width = `calc(min(200vw, ${100 * mb.readerMaxRatio}vh))`;

			mb.readerHorizontal = isReaderHorizontal(mb.screenAR);
			thumbStripInner.style.flexDirection = rd.rtl ? 'row-reverse' : 'row';

			// Create pageData structure with the fields from fetched data
			const pageData = komgaPageData.map(page => ({
				url: useOfflineCopy ? `${offline.bookPath}/pages/${page.number}${mimeToExt[page.mediaType]}` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}`,
				thumb: useOfflineCopy ? `${offline.bookPath}/thumbs/t_${page.number}.jpg` : `${mb.baseUrl}/api/v1/books/${bookId}/pages/${page.number}/thumbnail`,
				pageNum: page.number,
				width: page.width,
				height: page.height,
				AR: page.width / page.height,
				isCover: noCover ? false : page.number == 1,
				isOrphan: noWhitePage && (page.number == 2),
				isCurrent: page.number == rd.currentPage,
				isDoubleSpread: page.width > page.height,
				size: page.sizeBytes
			}));

			rd.foreEdgeL = addItem('div', {
				id: 'foreEdgeL',
				src: 'pages-left.png',
				style: {
					clipPath: 'inset(0 0 0 100%)'
				},
			});

			rd.foreEdgeR = addItem('div', {
				id: 'foreEdgeR',
				src: 'pages-right.png',
				style: {
					clipPath: 'inset(0 100% 0 0)'
				}
			});

			//Default shadow opacity is 0, it is overriden at the time of creation so it transitions in 0.5s
			rd.dropShadowL = addItem('div', { id: 'dropShadowL' });
			rd.dropShadowR = addItem('div', { id: 'dropShadowR' });

			readerViewer.append(rd.foreEdgeL, rd.foreEdgeR, rd.dropShadowL, rd.dropShadowR);

			// Create html structure for every page and related page thumbnails
			// and organize data structur for spread formation

			let i_page = 0; 		// Index of komga page data
			let realPage = 1;		// Index of real page

			// double spread with single page are treated as this:
			// one div for the spread contains TWO pages sharing the same image, but with different alignment properties
			// therefore the pageNums are like [5, 5] and the imageRefs are like (5,6)

			const firstNonCover = coverIsPageOne ? 2 : 1;

			rd.realFirstPage = coverIsPageOne ? '1' : 'C';

			// Create spreads objects and pages objects
			while (i_page < pageData.length) {
				let spreadObject = null;

				pageNum1 = realPage == firstNonCover ? (coverIsPageOne ? 2 : ' ') : realPage;
				pageNum2 = realPage == firstNonCover ? (coverIsPageOne ? 3 : realPage) : realPage + 1
				pageCover = pageData[i_page].isCover;

				if (pageData[i_page].isCover) {
					// Element is a cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('cover-page', pageTable(hidden, cover), pageData[i_page].pageNum, pageTable(coverIsPageOne ? ' ' : ' ', coverIsPageOne ? 1 : ' '));
				}
				else if (pageData[i_page].isDoubleSpread) {
					// Element is a double spread, generate second set of images
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('double-spread', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);
				}
				else if (i_page == pageData.length - 1) {
					// Element is last single page, so back cover
					const cover = buildPageObject(pageData[i_page]);
					const hidden = buildPageObject('hidden');
					spreadObject = buildSpreadObject('back-cover', pageTable(cover, hidden), pageData[i_page].pageNum, pageTable(realPage, ' '));
					rd.realLastPage = realPage;
				}
				else if (((i_page + 1 < pageData.length) && (pageData[i_page + 1].isDoubleSpread)) || (pageData[i_page].isOrphan)) {
					// This is an orphan page!
					const page1 = buildPageObject('blank');
					const page2 = buildPageObject(pageData[i_page]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);
				}
				else {
					// these are two normal pages
					const page1 = buildPageObject(pageData[i_page]);
					const page2 = buildPageObject(pageData[i_page + 1]);
					spreadObject = buildSpreadObject('two-pages', pageTable(page1, page2), pageData[i_page].pageNum, pageTable(pageNum1, pageNum2));
					rd.realLastPage = Math.max(pageNum1, pageNum2);

					i_page++;
				}

				rd.spreadsArray.push(spreadObject);
				i_page++;

				if (pageCover) {
					if (coverIsPageOne) {
						realPage = 2;
					}
				} else {
					if (coverIsPageOne && (realPage == firstNonCover)) {
						realPage = 4
					} else {
						realPage = realPage + (realPage == firstNonCover ? 1 : 2);
					}
				}
			}

			// Style and structure the spread objects and pages
			rd.spreadsArray.forEach((spreadObject, index) => {

				let pageObjectL = spreadObject.pageObjL;
				let pageObjectR = spreadObject.pageObjR;

				spreadObject.uiThumb.append(
					pageObjectL.uiThumb,
					pageObjectR.uiThumb,
				);

				spreadObject.uiItem.append(
					pageObjectL.uiContainer,
					pageObjectR.uiContainer,
				);

				buildSize2P(spreadObject.uiItem, mb.readerMaxRatio);
				//TODO Ma questo serve???? Farlo uguale a readerViewer?
				spreadObject.uiItem.style.width = `calc(min(200vw, ${100 * mb.readerMaxRatio}vh))`;

				buildSize(pageObjectL.uiContainer, mb.readerMaxRatio * 0.5);
				buildSize(pageObjectR.uiContainer, mb.readerMaxRatio * 0.5);

				pageObjectL.uiPage.style.float = 'right';
				pageObjectR.uiPage.style.float = 'left';
				pageObjectL.uiPage.style.objectFit = 'cover';
				pageObjectR.uiPage.style.objectFit = 'cover';
				pageObjectL.uiPage.style.objectPosition = 'left';
				pageObjectR.uiPage.style.objectPosition = 'right';
				pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
				pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				if ((pageObjectL.isCurrent) || (pageObjectR.isCurrent)) rd.currentSpreadIndex = index;
				console.log("E:" + rd.currentSpreadIndex)

				if ((spreadObject.spreadKind == 'cover-page') || (spreadObject.spreadKind == 'back-cover')) {
					spreadObject.uiItem.classList.add('cover-page')

					pageObjectL.uiContainer.classList.add('cover-page-RTL');
					pageObjectR.uiContainer.classList.add('cover-page-LTR');
					pageObjectL.uiContainer.style['marginLeft'] = 'auto';
					pageObjectR.uiContainer.style['marginRight'] = 'auto';

					buildSizeCV(pageObjectL.uiPage, mb.readerMaxRatio * 0.5);
					buildSizeCV(pageObjectR.uiPage, mb.readerMaxRatio * 0.5);

					addCoverSpine(pageObjectL, pageObjectR);

				}
				else if (spreadObject.spreadKind == 'two-pages') {
					spreadObject.uiItem.classList.add('two-pages');

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR ?? pageObjectR.AR;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectR.AR ?? pageObjectL.AR;

					pageObjectL.uiPage.style.height = pageObjectL.uiContainer.style.height;
					pageObjectR.uiPage.style.height = pageObjectR.uiContainer.style.height;

				}
				else if (spreadObject.spreadKind == 'double-spread') {
					spreadObject.uiItem.classList.add('two-pages');

					// Crop double spreads thumbnails
					pageObjectL.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectR.uiThumb.style.aspectRatio = pageObjectL.AR * 0.5;
					pageObjectL.uiThumb.style.objectFit = 'cover';
					pageObjectR.uiThumb.style.objectFit = 'cover';
					pageObjectL.uiThumb.style.objectPosition = 'left';
					pageObjectR.uiThumb.style.objectPosition = 'right';

					pageObjectL.uiContainer.classList.add('left-page');
					pageObjectR.uiContainer.classList.add('right-page');

					buildSize(pageObjectL.uiPage, pageObjectL.AR * 0.5);
					buildSize(pageObjectR.uiPage, pageObjectR.AR * 0.5);

				}
				spreadObject.uiItem.append(spreadObject.uiShadowL, spreadObject.uiShadowR);
				spreadObject.uiItem.append(spreadObject.uiLightL, spreadObject.uiLightR);

				readerViewer.append(spreadObject.uiItem);
				spreadHide(index);

				const localSpread = index;

				spreadObject.uiThumb.addEventListener('pointerup', () => {
					console.log("X-C:" + localSpread)

					jumpToSpread(localSpread);
				});
				thumbStripInner.append(spreadObject.uiThumb);

			});

			//TODO Qui non funziona bene, spostato dopo initviewer, si può togliere?
			//TODO Tolto, verificare
			//spreadSetFocus(getSpreadFocus(rd.currentSpreadIndex));

			return pageData;
		}

		// Starts timeout for element id of the preload stack
		function startTimeout(id, duration, callback) {
			const timeoutId = setTimeout(() => {
				// Execute the callback when the timeout finishes
				callback();
				delete rd.preloadStack[id];
			}, duration);

			// Add the timeoutId to the stack
			rd.preloadStack[id] = timeoutId;
		}

		// Function to clear all timeouts (optional, if you need this functionality)
		function clearAllTimeouts() {
			Object.values(rd.preloadStack).forEach(timer => {
				clearTimeout(timer);
			});
			rd.preloadStack = {};
		}

		// Calculate stack size for the image loading stack
		function picLoadStackSize() {
			let out = 0;
			rd.picLoadStack.forEach(element => {
				out += element.size;
			});
			return (out);
		}

		function printStack(str_in) {
			return; //XXX Disable debug of preload stack
			let out = str_in + ' *';
			rd.picLoadStack.forEach(element => {
				out = out + ' ' + element;
			})
			out = 'tot:' + rd.picLoadStack.length + ' ' + out + ' *';
			console.log(out);
		}

		// Actually load media in the selected index, isPreload is true if the population action is
		// triggered by a preload, so it doesn't trigger further preloads

		async function populateSpread(spreadIndex, isPreload = false) {
			if (isSectionHidden(readerContainer)) return; //XXX THIS IS PROBABLY THE BEST

			let uiPageArray = [
				rd.spreadsArray[spreadIndex].pageObjL,
				rd.spreadsArray[spreadIndex].pageObjR,
			].filter(el => el != null);

			const promises = uiPageArray.map(async (element, index) => {

				if (rd.picLoadStack.indexOf(element) == -1) {
					if (!element.hasSrc) {
						rd.picLoadStack.push(element); // Add to the stack
						printStack('S');
						element.uiPage.classList.add('loading');
						try {
							// Fetch the image
							const blobUrl = await fetchMedia(element.lazySrc, false);
							if (isSectionHidden(readerContainer)) return;
							// These lines reduce stuttering
							//TODO Verify if this creates some errors when going back from reader and pages are still loading
							const img = new Image();
							img.src = blobUrl;
							await img.decode();

							element.uiPage.src = blobUrl;
							element.hasSrc = true;
							//rd.uiPages[element].src = rd.pagesDataArray[element].url;
							// Handle successful load
							element.uiPage.addEventListener('load', () => {
								element.uiPage.classList.add('loaded');
								element.uiPage.classList.remove('hidden');
								element.uiPage.classList.remove('loading');
								if (isSectionHidden(readerContainer)) {
									printStack('LX ');
									return;
								}
								const index = rd.picLoadStack.indexOf(element);
								printStack('L ' + index);
								if (index !== -1) {
									rd.picLoadStack.splice(index, 1); // Remove from stack
								};
								if (!isPreload) {
									preloadPages(spreadIndex, rd.preloadCount)
								}
							});
						} catch (error) {
							console.error(`Failed to load image for element ${element}:`, error);
							// Handle error (optional: remove from stack or show fallback)
						}
					}

					// Immediately handle cached images
					else if (element.uiPage.complete) {
						element.uiPage.classList.add('loaded');
						element.uiPage.classList.remove('hidden');
						element.uiPage.classList.remove('loading');
						const index = rd.picLoadStack.indexOf(element);
						if (index !== -1) {
							rd.picLoadStack.splice(index, 1);
						}
						//XXX REMOVED Force preload when landing on a cached image

						if (!isPreload) {
							preloadPages(spreadIndex, rd.preloadCount)
						}
					}
				}
			});

			// Wait for all fetches to complete
			await Promise.all(promises);
		}

		function populateSpreadPreload(spreadIndex) {
			populateSpread(spreadIndex, true)
		}

		function handleArrow(direction) {
			const isDirectionLeft = (direction === 'left');
			const delta = (rd.rtl === isDirectionLeft) ? 1 : -1;
			const newSpread = rd.currentSpreadIndex + delta;

			if (rd.webtoon) {
				console.log("X-C:" + newSpread)

				jumpToSpread(newSpread);
				return
			}

			if (rd.pageTurning === direction) return;
			if (newSpread < 0 || newSpread > spreadsTotal()) return;
			if ((newSpread >= spreadsTotal()) && (rd.spreadsArray[rd.currentSpreadIndex].spreadKind == 'back-cover')) return;

			const edgeFocus = isDirectionLeft ? 'focus-right-page' : 'focus-left-page';
			const targetFocus = isDirectionLeft ? 'focus-left-page' : 'focus-right-page';

			if (!mb.readerHorizontal && newSpread === spreadsTotal() && rd.spreadFocus === edgeFocus) {
				return spreadSetFocusSmooth(targetFocus);
			}

			if ((newSpread === 0 || newSpread === spreadsTotal() - 1) && rd.pageTurning) return;

			const earlyTurnBlock = (isDirectionLeft !== rd.rtl) && rd.currentSpreadIndex === spreadsTotal() - 2;
			const lateTurnBlock = (isDirectionLeft === rd.rtl) && rd.currentSpreadIndex === 1;
			if ((earlyTurnBlock || lateTurnBlock) && rd.pageTurning) return;


			if (mb.readerHorizontal) {
				jumpToSpread(newSpread);
			} else if (rd.spreadFocus === edgeFocus) {
				spreadSetFocusSmooth(targetFocus);
			} else {
				jumpToSpread(newSpread, edgeFocus);
			}
		}

		function handleLeftArrow() {
			handleArrow('left');
		}

		function handleRightArrow() {
			handleArrow('right');
		}

		function handleLeftLimit() {
			jumpToSpread(!rd.rtl ? 0 : spreadsTotal() - 1);
		}

		function handleRightLimit() {
			jumpToSpread(!rd.rtl ? spreadsTotal() - 1 : 0);
		}

		function handleSmallThumbs() {
			setThumbZoom(false);
		};

		function handleLargeThumbs() {
			setThumbZoom(true);
		};


		function getPageFromSpread(index) {
			const spreadObject = rd.spreadsArray[index];

			const twoPages = (rd.spreadsArray[index].spreadKind == 'two-pages');
			const lastSpread = (twoPages && (index == (spreadsTotal() - 1)));

			const currentPage = lastSpread ? spreadObject.spreadRefPage + 1 : spreadObject.spreadRefPage;
			const pageNumText = rd.webtoon ? spreadObject.pageNumL : spreadObject.pageNumL + ' ' + spreadObject.pageNumR;

			const out = [currentPage, pageNumText];

			return out;
		}

		//TODO con newpage calcoalto dalla funzione esterna e a ogni bar update, ripulire se serve questa cosa
		function jumpString() {

			console.log("jumpstring currentpage:" + rd.currentPage)

			const stringOut = `${mb.basePath}#bookread
			?library_id=${rd.libraryId}
			&series_id=${rd.seriesId}
			&book_id=${rd.bookId}
			&dir=${rd.direction}
			&pag=${rd.currentPage}`;

			if (!rd.incognito) {
				callAPI(null, `/api/v1/books/${rd.bookId}/read-progress`, 'PATCH', JSON.stringify({ page: rd.currentPage }), false)
					.catch(error => console.error('Error:', error));
			}

			console.log("jumpstring currentpage 2:" + rd.currentPage)

			if (obIsBookCompleted(rd.bookId)) {
				mb.offlineBooks[rd.bookId].page = rd.currentPage;
				if (offlineSession) mb.offlineBooks[rd.bookId].updated = true;
				obSaveTable();
			}

			return (stringOut);
		}

		function purgeLoading() {
			for (let i = rd.picLoadStack.length - 1; i >= 0; i--) {
				const item = rd.picLoadStack[i];
				item.hasSrc = false;
				item.uiPage.src = 'transparent.png';
				rd.picLoadStack.splice(i, 1); // Remove the element at index i
				printStack('P');
			}
			clearAllTimeouts();
		}

		// Thumbnail scrolling functions
		function thumbSmoothScrollWebtoon(container, targetScrollTop, duration = 500) {
			const start = container.scrollTop;
			const change = targetScrollTop - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollTop = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}
			requestAnimationFrame(animateScroll);
		}


		// Thumbnail scrolling functions
		function thumbSmoothScroll(container, targetScrollLeft, duration = 500) {
			const start = container.scrollLeft;
			const change = targetScrollLeft - start;
			const startTime = performance.now();

			function animateScroll(currentTime) {
				const elapsedTime = currentTime - startTime;
				const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

				// Easing function (easeInOutQuad for smooth effect)
				const ease = progress < 0.5
					? 2 * progress * progress
					: -1 + (4 - 2 * progress) * progress;

				container.scrollLeft = start + change * ease;

				if (progress < 1) {
					requestAnimationFrame(animateScroll);
				}
			}
			requestAnimationFrame(animateScroll);
		}

		function centerThumbWebtoon(fast = false) {

			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInnerWT.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInnerWT.children[rd.currentSpreadIndex]; // n-th element (0-based index)

			if (targetElement) {
				const targetScrollTop = -thumbStripScrollContentWT.clientHeight / 2 + targetElement.offsetTop - thumbStripScrollContentWT.offsetTop + targetElement.clientHeight / 2;

				if (!fast) {
					thumbSmoothScrollWebtoon(thumbStripScrollContentWT, targetScrollTop, 300);
				} else {
					thumbStripScrollContentWT.scrollTop = targetScrollTop;
				};

				thumbStripInnerWT.children[rd.currentSpreadIndex].classList.add('current');
			}
		}

		function centerThumb(fast = false) {
			//TODO this is a bit overkill, maybe simplify this as it was before? but it wasn't working on seek
			// maybe each time the old and current spreads are updated I could call this function with old and current to
			// remove one class and add the other...

			Array.from(thumbStripInner.children).forEach(element => {
				element.classList.remove('current');
			});

			const targetElement = thumbStripInner.children[rd.currentSpreadIndex]; // n-th element (0-based index)

			if (targetElement) {
				const targetScrollLeft = -thumbStripScrollContent.clientWidth / 2 + targetElement.offsetLeft - thumbStripScrollContent.offsetLeft + targetElement.clientWidth / 2;

				if (!fast) {
					thumbSmoothScroll(thumbStripScrollContent, targetScrollLeft, 300);
				} else {
					thumbStripScrollContent.scrollLeft = targetScrollLeft;
				};

				thumbStripInner.children[rd.currentSpreadIndex].classList.add('current');
			}
		}

		function animShadowFWD(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0', opacity: '0.1' },
				{ [align]: '50%', width: rd.pageShadowWidthFWD, opacity: rd.pageShadowOpacityFWD },
				{ [align]: '100%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function animShadowBWD(align, duration, ease) {
			return ([
				[{ [align]: '100%', width: '0', opacity: '0' },
				{ [align]: '75%', width: rd.pageShadowWidthBWD, opacity: rd.pageShadowOpacityBWD },
				{ [align]: '50%', width: '0', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function animLight(align, duration, ease) {
			return ([
				[{ [align]: '0%', width: '0%', opacity: '0.5' },
				{ [align]: '25%', width: '20%', opacity: '1' },
				{ [align]: '50%', width: '30%', opacity: '0' }],
				{ duration: duration, easing: ease }
			]);
		}

		function hideOldSpread(index, oldindex) {
			if (oldindex != index) spreadHide(oldindex);
		}

		function pageTurn(index, oldindex, turnDirection, force = false) {

			if (rd.webtoon) return;

			//Z-index control
			rd.spreadsArray[index].uiItem.style.zIndex = spreadsTotal() + 1;

			if (turnDirection == 'turn-right') {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.rtl ? oldindex : spreadsTotal() - oldindex;
			} else {
				rd.spreadsArray[oldindex].uiItem.style.zIndex = rd.rtl ? spreadsTotal() - oldindex : oldindex;
			}

			rd.dropShadowL.style.zIndex = rd.dropShadowR.style.zIndex = 0;

			const easeFull = 'cubic-bezier(0.42, 0, 0.58, 1)'
			const easeIn = 'cubic-bezier(0.42, 0, 0.71, 1)'
			const easeOut = 'cubic-bezier(0.29, 0.5, 0.58, 1)'

			// Animation preparation
			const turnTime = force ? 0 : rd.turnTime;
			const animData = { duration: turnTime, easing: easeFull, fill: 'forwards' };
			const animInstant = { duration: 0, easing: 'linear', fill: 'forwards' };

			const appearR2L_slideinL2R = [
				{ clipPath: 'inset(0 0 0 100%)', left: '-100%' },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearL2R = [
				{ clipPath: 'inset(0 100% 0 0)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const appearL2R_sildeinR2L = [
				{ clipPath: 'inset(0 100% 0 0)', left: '100%' },
				{ clipPath: 'inset(0 0 0 0)', left: '0%' }
			];
			const appearR2L = [
				{ clipPath: 'inset(0 0 0 100%)' },
				{ clipPath: 'inset(0 0 0 0)' }
			];
			const clipL2R = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 0 0 100%)' }
			];
			const clipR2L = [
				{ clipPath: 'inset(0 0 0 0)' },
				{ clipPath: 'inset(0 100% 0 0)' }
			];
			const unFade = [
				{ filter: 'brightness(90%) sepia(10%)' },
				{ filter: 'brightness(100%) sepia(0%)' }
			];
			const fade = [
				{ filter: 'brightness(100%) sepia(0%)' },
				{ filter: 'brightness(90%) sepia(10%)' }
			];

			if (oldindex != index) rd.spreadsArray[oldindex].uiItem.animate(fade, { duration: rd.turnTime, easing: 'ease-in' });

			const startCover = ((rd.spreadsArray[oldindex].spreadKind == 'cover-page') || (rd.spreadsArray[oldindex].spreadKind == 'back-cover'));
			const stopCover = ((rd.spreadsArray[index].spreadKind == 'cover-page') || (rd.spreadsArray[index].spreadKind == 'back-cover'));

			//turnDirection can be 'turn-right' or 'turn-left'
			rd.foreEdgeL.style.transition = 'clip-path 0.3s';
			rd.foreEdgeR.style.transition = 'clip-path 0.3s';
			rd.dropShadowL.style.transition = 'margin 0.3s, opacity 0.5s';
			rd.dropShadowR.style.transition = 'margin 0.3s, opacity 0.5s';

			clipForeEdge = buildForeEdge(index, spreadsTotal())

			// Margins are defined as percentage of total width, so to have the correct size we divide
			// by mb.readerMaxRatio, then multiply by the drop aspect ratio (0.1) and apply the dropL and dropR proportion
			rd.dropShadowL.style.marginRight = (0.1 * clipForeEdge.dropL * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.marginLeft = (0.1 * clipForeEdge.dropR * 100 * 1 / mb.readerMaxRatio) + '%';
			rd.dropShadowR.style.opacity = 1;
			rd.dropShadowL.style.opacity = 1;

			rd.pageTurning = (turnDirection == 'turn-right' ? 'right' : 'left');

			if (!startCover && !stopCover) {
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer;
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					leftPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));
				} else {
					rightPage.animate(appearR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R_sildeinR2L, animData);
					rightPage.animate(unFade, { duration: rd.turnTime, easing: 'ease-in' });

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));
				}

				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;

			} else if (startCover && stopCover) {
				let startCoverPageL = rd.spreadsArray[oldindex].pageObjL.uiContainer
				let startCoverPageR = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let stopCoverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let stopCoverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.foreEdgeL.style.transition = 'clip-path 0s';
				rd.foreEdgeR.style.transition = 'clip-path 0s';
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;
				rd.dropShadowL.style.transition = 'margin 0s';
				rd.dropShadowR.style.transition = 'margin 0s';
				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;

				if (turnDirection == 'turn-right') {
					startCoverPageR.animate(clipL2R, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageR.animate(appearR2L, animInstant);
					rd.dropShadowR.animate([{ left: '100%' }], animInstant);
					rd.dropShadowL.animate([{ right: '50%' }], animInstant);
				} else {
					startCoverPageL.animate(clipR2L, animInstant).finished.then(() => hideOldSpread(index, oldindex));
					stopCoverPageL.animate(appearL2R, animInstant);
					rd.dropShadowL.animate([{ right: '100%' }], animInstant);
					rd.dropShadowR.animate([{ left: '50%' }], animInstant);
				}
			} else if (startCover) {
				// Start Page (cover or back cover)
				//let coverPage = rd.spreadsArray[oldindex].pageObj.uiContainer
				// Stop Page (mid spread)
				let rightPage = rd.spreadsArray[index].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[index].pageObjL.uiContainer

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeR.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowR.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadShadowL.animate(...animShadowBWD('right', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					rightPage.animate(appearR2L_slideinL2R, animData).finished.then(() => hideOldSpread(index, oldindex));
					leftPage.animate(appearL2R, animData);
					rd.dropShadowR.animate(
						[{ left: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: 'forwards', delay: turnTime * 0.5 }
					);
				} else {
					rd.foreEdgeL.style.transition = `clip-path 0.15s ease-in-out ${turnTime}ms`;
					rd.dropShadowL.style.transition = `margin 0.15s ease-in-out ${turnTime}ms`;

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadShadowR.animate(...animShadowBWD('left', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					rightPage.animate(appearR2L, animData);
					leftPage.animate(appearL2R_sildeinR2L, animData).finished.then(() => hideOldSpread(index, oldindex));
					rd.dropShadowL.animate(
						[{ right: '100%' }],
						{ duration: turnTime * 0.5, easing: easeOut, fill: 'forwards', delay: turnTime * 0.5 }
					);
				}
				rd.foreEdgeL.style.clipPath = clipForeEdge.left;
				rd.foreEdgeR.style.clipPath = clipForeEdge.right;
			} else if (stopCover) {
				// Start Page (mid spread)
				let rightPage = rd.spreadsArray[oldindex].pageObjR.uiContainer
				let leftPage = rd.spreadsArray[oldindex].pageObjL.uiContainer
				// Stop Page (cover or back cover)
				let coverPageL = rd.spreadsArray[index].pageObjL.uiContainer
				let coverPageR = rd.spreadsArray[index].pageObjR.uiContainer

				rd.dropShadowL.style.marginRight = 0;
				rd.dropShadowR.style.marginLeft = 0;
				rd.foreEdgeL.style.clipPath = `inset(0 0 0 100%)`;
				rd.foreEdgeR.style.clipPath = `inset(0 100% 0 0)`;

				let newSpreadShadowL = rd.spreadsArray[index].uiShadowL;
				let newSpreadShadowR = rd.spreadsArray[index].uiShadowR;
				let newSpreadLightL = rd.spreadsArray[index].uiLightL;
				let newSpreadLightR = rd.spreadsArray[index].uiLightR;

				if (turnDirection == 'turn-right') {
					rd.foreEdgeL.style.transition = 'clip-path 0s';
					leftPage.animate(clipL2R, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowR.animate(...animShadowFWD('left', turnTime, easeFull));
					newSpreadLightR.animate(...animLight('left', turnTime, easeFull));

					coverPageR.animate(appearR2L_slideinL2R, animData);
					coverPageL.animate(appearL2R, animData);
					rd.dropShadowL.animate(
						[{ right: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: 'forwards' }
					);
				} else {
					rd.foreEdgeR.style.transition = 'clip-path 0s';
					rightPage.animate(clipR2L, animData).finished.then(() => hideOldSpread(index, oldindex));

					newSpreadShadowL.animate(...animShadowFWD('right', turnTime, easeFull));
					newSpreadLightL.animate(...animLight('right', turnTime, easeFull));

					coverPageL.animate(appearL2R_sildeinR2L, animData);
					coverPageR.animate(appearR2L, animData);
					rd.dropShadowR.animate(
						[{ left: '50%' }],
						{ duration: turnTime, easing: easeFull, fill: 'forwards' }
					);
				}
			}

			clearTimeout(rd.turnTimeout);
			rd.turnTimeout = setTimeout(() => {
				rd.pageTurning = null;
			}, turnTime);
		}

		// Generic spread class definition, not valid for arrowleft and right in portrait mode!
		function getSpreadFocus(spreadIndex) {
			const spreadKind = rd.spreadsArray[spreadIndex].spreadKind;
			if (spreadKind === 'cover-page') {
				return rd.rtl ? 'focus-left-page' : 'focus-right-page';
			}
			if (spreadKind === 'back-cover') {
				return rd.rtl ? 'focus-right-page' : 'focus-left-page';
			}
			if (mb.readerHorizontal) {
				return 'focus-center';
			}
			return rd.rtl ? 'focus-right-page' : 'focus-left-page';
		}

		function jumpToSpread(targetSpreadIndex, targetSpreadFocus = null, skipHistory = false, smoothWebtoon = false) {

			console.log("--JUMP TO SPREAD--:")
			console.log("  targetSpreadIndex:" + targetSpreadIndex);
			console.log("  targetSpreadFocus:" + targetSpreadFocus);
			console.log("  skipHistory:" + skipHistory);
			console.log("  smoothWebtoon:" + smoothWebtoon);

			if (rd.isDraggingProgressBar) {
				updateProgressBar(targetSpreadIndex);
				return;
			}

			const localOldSpreadIndex = skipHistory ? 0 : rd.currentSpreadIndex;
			const localNewSpreadIndex = targetSpreadIndex;

			if (rd.nextBook != null) {
				if (targetSpreadIndex == spreadsTotal() - 1) {
					nextBookPanel.classList.remove('hidden')
				} else {
					if (!nextBookPanel.classList.contains('hidden')) nextBookPanel.classList.add('hidden')
				}
			}
			if (rd.prevBook != null) {
				if (targetSpreadIndex == 0) {
					prevBookPanel.classList.remove('hidden')
				} else {
					if (!prevBookPanel.classList.contains('hidden')) prevBookPanel.classList.add('hidden')
				}
			}

			if ((targetSpreadIndex < 0) || (targetSpreadIndex >= spreadsTotal()) || (!skipHistory && (localOldSpreadIndex == localNewSpreadIndex))) {
				console.log("--JUMP TO SPREAD RETURN")
				return;
			}

			if (targetSpreadFocus == null) {
				console.log("--TARGET SPREAD FOCUS = NULL")
				targetSpreadFocus = getSpreadFocus(localNewSpreadIndex);
			}

			purgeLoading();

			rd.oldSpreadIndex = localOldSpreadIndex;
			rd.currentSpreadIndex = localNewSpreadIndex;

			if (isSectionHidden(readerContainer)) return;

			populateSpread(localNewSpreadIndex);

			// TODO
			// It always call spreadSetFocusSmoothDelay, because when in horiontal mode the target is 
			// center and there's no scrolling happening in that case, page turn is treated separately 
			// This adds a slight delay when jumping cover to cover
			spreadSetFocusSmoothDelay(targetSpreadFocus);

			spreadShow(localNewSpreadIndex);

			const turnDirectionCalc = (localNewSpreadIndex > localOldSpreadIndex) === rd.rtl ? 'turn-right' : 'turn-left';
			pageTurn(localNewSpreadIndex, localOldSpreadIndex, turnDirectionCalc, skipHistory)

			rd.webtoon ? centerThumbWebtoon() : centerThumb();

			if (rd.webtoon && !smoothWebtoon) {
				console.log("--WEBTOON BLOCK--")
				rd.webtoonScroll = true;

				const el = rd.spreadsArray[targetSpreadIndex].uiItem;
				const parent = el.parentElement;
				const offsetTop = el.offsetTop + 1; // 1px extra upwards

				console.log("--OFFSET TOP: " + offsetTop);

				parent.scrollTo({
					top: offsetTop,
					behavior: 'smooth'
				});

				setTimeout(() => {
					rd.webtoonScroll = false;
				}, 1000);
			}

			updateProgressBar();

			if (!skipHistory) history.replaceState(null, '', jumpString());
		}

		function jumpToSpreadSkipHistory(targetSpreadIndex) {
			jumpToSpread(targetSpreadIndex, null, true, false)
		}

		function jumpToSpreadSmoothWebtoon(targetSpreadIndex) {
			jumpToSpread(targetSpreadIndex, null, false, true)
		}

		// Reader UI Control Buttons
		function toggleMenu() {
			if (isSectionHidden(controlPanel)) {
				if (isStatusBar && !isSharpCornerIphone && !((capacitorPlatform == 'android') && isOrientationLandscape())) {
					Capacitor.Plugins.StatusBar.show();
				}
				updatePWABar();
			} else {
				if (isStatusBar) {
					Capacitor.Plugins.StatusBar.hide();
				}
				updatePWABar(rd.titleBarColor);
			}

			sectionToggle(controlPanel);
			touchPanel.classList.toggle('shrink');
		}

		function hideMenu() {
			sectionHide(controlPanel);
			touchPanel.classList.remove('shrink');
		}

		leftArrow.addEventListener('click', handleLeftArrow);
		rightArrow.addEventListener('click', handleRightArrow);
		leftLimit.addEventListener('click', handleLeftLimit);
		rightLimit.addEventListener('click', handleRightLimit);

		toLeftPage.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		toLeftPage.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			handleLeftArrow();
		});

		toRightPage.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		toRightPage.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			handleRightArrow();
		});

		openMenu.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		openMenu.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			toggleMenu();
		});

		// Seek function to move to specific spread based on click or drag
		function seek(event) {

			const progressBarWidth = readerProgressBar.offsetWidth;
			const clickX = event.clientX - readerProgressBar.getBoundingClientRect().left;
			const newProgressPercent = Math.min(1, Math.max(0, !rd.rtl ? clickX / progressBarWidth : (progressBarWidth - clickX) / progressBarWidth));

			jumpToSpread(Math.floor(newProgressPercent * (spreadsTotal() - 1)));
		}

		// Dragging the progress bar
		readerProgressBar.addEventListener('mousedown', (event) => {
			rd.isDraggingProgressBar = true;
			event.preventDefault();
			seek(event);
		});

		readerProgressBar.addEventListener('touchstart', (event) => {
			rd.isDraggingProgressBar = true;
			seek(event.touches[0]); // Use the first touch point
		});


		mainContainer.addEventListener('scroll', function () {

			if (!isSectionHidden(seriesMiniHeader)) {
				if ((mainContainer.scrollTop > 180) && (seriesMiniHeader.classList.contains('collapse'))) {
					seriesMiniHeader.classList.remove('collapse');
				} else if ((mainContainer.scrollTop < 200) && !seriesMiniHeader.classList.contains('collapse')) {
					seriesMiniHeader.classList.add('collapse');
				}
			}

			if (!isSectionHidden(stripGridContainer)) {
				if ((mainContainer.scrollTop < 5) && (stripGridHeaderContainer.classList.contains('collapse'))) {
					stripGridHeaderContainer.classList.remove('collapse');
				} else if ((mainContainer.scrollTop > 10) && !stripGridHeaderContainer.classList.contains('collapse')) {
					stripGridHeaderContainer.classList.add('collapse');
				}
			}
		});

		addClickPointerEvents(seriesMiniHeader, () => {
			mainContainer.scrollTo({ top: 0, behavior: 'smooth' });
		});

		document.addEventListener('mousemove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event);
			}
		});
		document.addEventListener('touchmove', (event) => {
			if (rd.isDraggingProgressBar) {
				seek(event.touches[0]);
			}
		});

		document.addEventListener('mouseup', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		document.addEventListener('touchend', (event) => {
			if (rd.isDraggingProgressBar) {
				rd.isDraggingProgressBar = false;
				seek(event.changedTouches[0]);
			} else {
				rd.isDraggingProgressBar = false;
			}
		});

		//TODO: RIMUOVERE ASYNC DA QUI
		document.addEventListener('keydown', async (event) => {
			const readerVisible = !isSectionHidden(readerContainer);

			switch (event.key) {
				case 'ArrowLeft':
					if (readerVisible && !rd.webtoon) {
						event.preventDefault();
						handleLeftArrow();
					}
					break;
				case 'ArrowRight':
					if (readerVisible) {
						event.preventDefault();
						!rd.webtoon ? handleRightArrow() : handleCloseReader();
					}
					break;
				case 'ArrowDown':
					if (readerVisible) {
						event.preventDefault();
						!rd.webtoon ? handleCloseReader() : handleRightArrow();
					}
					break;
				case 'ArrowUp':
					if (readerVisible && rd.webtoon) {
						event.preventDefault();
						handleLeftArrow();
					}
					break;
				case 'Escape':
					if (readerVisible) {
						event.preventDefault();
						handleCloseReader();
					}
					break;
				case ' ':
					if (readerVisible) {
						event.preventDefault();
						toggleMenu();
					}
					break;
				default:
					break;
			}
		});

		document.addEventListener('pointerup', (event) => {
			if (mb.currentlyScaled && !mb.currentlyScaled.contains(event.target)) {
				mb.currentlyScaled.classList.remove('scaled');
				mb.currentlyScaled.parentElement.classList.remove('top-pop');

				mb.currentlyScaled = null;
			}
		});

		document.addEventListener('pointerdown', (event) => {
			if (mb.clickingTile != null) return;

			if ((mb.libMenuVisible != null) && (!filtersBar.contains(event.target))) {
				libMenuDown(mb.libraryMenuButtons[mb.libMenuVisible]);
				sectionToggle(filtersBar);
				mb.libMenuVisible = null;
			}

			if ((mb.swatchMenuVisible) && (!colorSwatchBar.contains(event.target)) && (!colorChanger.contains(event.target))) {
				mb.swatchMenuVisible = false;
				sectionHide(colorSwatchBar);
			}

		});

		//MB URL Parsing and LoadContent Function 
		function getHashAndParams() {
			const fullHash = window.location.hash.substring(1); // Remove leading '#'
			const [path, paramString] = fullHash.split('?'); // Separate path and parameters

			const params = paramString == undefined ? null : new URLSearchParams(paramString ?? '');
			return { path, params };
		}

		async function loadContent() {
			const { path, params } = getHashAndParams();

			await executeFade(1);
			dragbarOffReader();
			document.querySelectorAll('.section').forEach(section => sectionHide(section));

			//In part useless because of the click outside events, but useful when loading an url
			sectionHide(filtersBar);
			sectionHide(colorSwatchBar);
			mb.libMenuVisible = null;
			mb.swatchMenuVisible = false

			clearLibrariesMenus();

			closeBookDetails();
			mb.screenAR = getScreenAR();

			switch (path) {
				case '':
				case 'dashboard':
					searchInput.value = '';
					setIncognito(false);
					if ((params == null) || (params.size == 0)) {
						await selectHome();
						if (mb.dashboardBin) {
							const y = dashboardElements[mb.dashboardBin].element.getBoundingClientRect().top - mainContainer.getBoundingClientRect().top + mainContainer.scrollTop - 10;

							mainContainer.scrollTo({ top: y });
							mb.dashboardBin = '';
						}
					} else {
						dashboardAll(params.get('all'), params.get('page'));
					}
					break;
				case 'library':
					mb.dashboardBin = '';
					searchInput.value = '';
					setIncognito(false);
					await openLibrary(params.get('library_id'), params.get('series_id'));
					break;
				case 'series':
					searchInput.value = '';
					setIncognito(false);
					await openSeries(params.get('library_id'), params.get('series_id'), params.get('book_id'));
					break;
				case 'search':
					setIncognito(false);
					searchInput.value = params.get('search_string');
					await performSearch(params.get('search_string'));
					break;
				case 'bookread':
					await openBookReader(params.get('library_id'), params.get('series_id'), params.get('book_id'), params.get('dir'), params.get('pag'));
					break;
				case 'offlinebooks':
					searchInput.value = '';
					setIncognito(false);
					await openOfflineBooks(params?.get('book_id'));
					break;
				default:
					console.log('no selection');
			}
			await executeFade(0);
		}

		// This is the most important function, it updates the history and then passes the path to the loadContent function that does all the work
		// In MB the navigateTo function with a proper path form will open the different sections and activate various states.
		function navigateTo(path) {
			console.log("navigate to:" + path)
			history.pushState(null, '', mb.basePath + path);
			loadContent();
		}

		const webtoonPageNumberObserver = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				console.log("rd.webtoonScroll:" + rd.webtoonScroll)
				if (rd.webtoonScroll) return;
				if (entry.isIntersecting) {
					console.log("X-A:" + (entry.target.alt - 1))
					jumpToSpreadSmoothWebtoon(entry.target.alt - 1)
				}
			});
		});

		// Lazy-loading setup with Intersection Observer
		const lazyLoadingObserver = new IntersectionObserver(async (entries, observer) => {
			entries.forEach(async (entry) => {
				if (entry.isIntersecting) {
					const img = entry.target;
					img.classList.add('loading');

					// TODO Set the actual src from lazySrc, check if needed
					const imageUrl = await fetchMedia(img.lazySrc);
					img.src = imageUrl;

					// Remove lazySrc to clean up
					delete img.lazySrc;

					img.addEventListener('load', () => {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
						setTimeout(() => {
							img.classList.remove('loaded');
							img.classList.add('finished');
						}, 1000);
					});
					if (img.complete) {
						img.classList.add('loaded');
						img.classList.remove('hidden');
						img.classList.remove('loading');
					}
					// Stop observing this image
					observer.unobserve(img);
				}
			});
		});

		// Function to add lazy loading to an image
		function addLazyLoading(img) {
			lazyLoadingObserver.observe(img);
		}

		function removeLazyLoading(img) {
			lazyLoadingObserver.unobserve(img);
		}

		window.addEventListener('hashchange', loadContent);
		document.addEventListener('popstate', loadContent);

		document.querySelectorAll('.press-button').forEach(item => addPressEvents(item, pressDown, pressUp));
		document.querySelectorAll('.mini-buttons-2').forEach(item => addPressEvents(item, scaleDownDeep, scaleUp));

		searchInput.addEventListener('pointerdown', (event) => {
			event.stopPropagation();
		})

		let offlineSession = false;

		sessionCheck()

		//MB Reader touch response fucntions
		function getTrueScale() {
			return window.innerWidth / window.visualViewport.width;
		}
		function getDerivedScale() {
			return rd.scale;
			return document.documentElement.clientWidth / window.visualViewport.width;
		}

		function enableTouchResponse(item, threshold, onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown) {
			item.SingleTouch = true;
			item.TouchStartX = 0;
			item.TouchStartY = 0;

			function handleTouchStart(event) {
				if (getDerivedScale() > 1.01) return;

				if (event.touches.length > 1) {
					item.SingleTouch = false; // Multiple touches: ignore for swipe
					return;
				}
				item.SingleTouch = true;
				item.TouchStartX = event.touches[0].clientX;
				item.TouchStartY = event.touches[0].clientY;
			}

			function handleTouchMove(event) {
				if (getDerivedScale() > 1.01 || !item.SingleTouch) return;

				const touchEndX = event.touches[0].clientX;
				const touchEndY = event.touches[0].clientY;

				const diffX = touchEndX - item.TouchStartX;
				const diffY = touchEndY - item.TouchStartY;

				if (Math.abs(diffX) > threshold && Math.abs(diffY) < threshold) {
					if (diffX > 0) {
						onSwipeRight?.(); // Call custom right swipe function
					} else {
						onSwipeLeft?.(); // Call custom left swipe function
					}
					item.SingleTouch = false; // Prevent repeat action on the same swipe
				} else if (Math.abs(diffY) > threshold && Math.abs(diffX) < threshold) {
					if (diffY > 0) {
						onSwipeDown?.(); // Call custom down swipe function
					} else {
						onSwipeUp?.(); // Call custom up swipe function
					}
					item.SingleTouch = false;
				}
			}

			item.addEventListener('touchstart', handleTouchStart);
			item.addEventListener('touchmove', handleTouchMove);
		}

		enableTouchResponse(touchPanel, 30, handleRightArrow, handleLeftArrow, null, handleCloseReader);
		enableTouchResponse(thumbStripWT, 20, handleLargeThumbs, handleSmallThumbs, null, null);
		enableTouchResponse(thumbStrip, 20, null, null, handleLargeThumbs, handleSmallThumbs);

		/*
		webtoonContainer.addEventListener('click', () => {
			toggleMenu();
		})
		*/

		webtoonContainer.addEventListener('pointerdown', () => {
			rd.touchLock = true;
		});
		webtoonContainer.addEventListener('pointerup', () => {
			if (!rd.touchLock) return;
			rd.touchLock = false;
			toggleMenu();
		});

		webtoonContainer.addEventListener('scroll', () => {
			rd.webtoonScrollRatio = webtoonRatio();
		})
		enableTouchResponse(webtoonContainer, 30, null, handleCloseReader, null, null);

	</script>
</body>

</html>